#+STARTUP: overview

* Custom functions
#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun sd/forward-or-backward-sexp (&optional arg)
  "Go to the matching parenthesis character if one is adjacent to point."
  (interactive "^p")
  (cond ((looking-at "\\s(") (forward-sexp arg))
        ((looking-back "\\s)" 1) (backward-sexp arg))
        ;; Now, try to succeed from inside of a bracket
        ((looking-at "\\s)") (forward-char) (backward-sexp arg))
        ((looking-back "\\s(" 1) (backward-char) (forward-sexp arg))))

;;;###autoload
(defun sd/duplicate-line-or-region(arg)
  "Duplicates the current line or region ARG times.
If there's no region, the current line will be duplicated. However, if
there's a region, all lines that region covers will be duplicated."
  (interactive "p")
  (let (beg end (origin (point)))
    (if (and mark-active (> (point) (mark)))
        (exchange-point-and-mark))
    (setq beg (line-beginning-position))
    (if mark-active
        (exchange-point-and-mark))
    (setq end (line-end-position))
    (let ((region (buffer-substring-no-properties beg end)))
      (dotimes (i arg)
        (goto-char end)
        (newline)
        (insert region)
        (setq end (point)))
      (goto-char (+ origin (* (length region) arg) arg)))))

(defvar sd/copy-word-under-cursor-regex "[^[:word:]_]"
  "Regular expression to use when copying with `copy-word-under-cursor'.
Can be customized for each major mode.")

;;;###autoload
(defun sd/copy-word-under-cursor ()
  "Copy the word under the cursor to the kill ring."
  (interactive)
  (save-excursion
    (save-excursion (re-search-backward sd/copy-word-under-cursor-regex))
    (let ((beg (+ (match-beginning 0) 1))
          (end (re-search-forward sd/copy-word-under-cursor-regex)))
      (copy-region-as-kill beg (- end 1)))))


;;;###autoload
(defun sd/update-header()
  (interactive)
  (mapc
   (lambda (window)
     (with-current-buffer (window-buffer window)
       ;; don't mess with buffers that don't have a header line
       (when header-line-format
         (let ((original-format (get 'header-line-format 'original))
               (inactive-face 'mode-line-inactive)
	       (active-face 'mode-line)
	       ) ; change this to your favorite inactive header line face
           ;; if we didn't save original format yet, do it now
           (when (not original-format)
             (put 'header-line-format 'original header-line-format)
             (setq original-format header-line-format))
           ;; check if this window is selected, set faces accordingly
           (if (eq window (selected-window))
               (setq header-line-format `(:propertize ,original-format face ,active-face))
             (setq header-line-format `(:propertize ,original-format face ,inactive-face)))))))
   (window-list)))


;;;###autoload
(defun sd/comment-line-or-region (n)
  "Comment or uncomment current line and leave point after it.
With positive prefix, apply to N lines including current one.
With negative prefix, apply to -N lines above.
If region is active, apply to active region instead."
  (interactive "p")
  (save-excursion
    (if (use-region-p)
	(comment-or-uncomment-region
	 (region-beginning) (region-end))
      (let ((range
	     (list (line-beginning-position)
		   (goto-char (line-end-position n)))))
	(comment-or-uncomment-region
	 (apply #'min range)
	 (apply #'max range)))
      (forward-line 1)
      (back-to-indentation))))
#+END_SRC

* Global settings
#+BEGIN_SRC emacs-lisp

;; fontify code in code blocks for org mode
;; somehow this does not work if I place this line
;; in the mode codfiguration section
(setq org-src-fontify-natively t)

;; Copy/Paste they way I am used to
(global-unset-key (kbd "C-c c"))
(global-set-key (kbd "C-c c") 'kill-ring-save)

;; Paste the way I am used to
(global-unset-key (kbd "C-v"))
(global-set-key (kbd "C-v") 'yank)

;; Paste the way I am used to
(global-unset-key (kbd "C-M-j"))
(global-set-key (kbd "C-M-j") 'join-line)

;; Copy word under the cursor
(global-unset-key (kbd "M-c"))
(global-set-key (kbd "M-c") 'sd/copy-word-under-cursor)

;; Comment bindings
(global-unset-key (kbd "C-c C-c"))
(global-set-key (kbd "C-c C-c") 'sd/comment-line-or-region)
(global-unset-key (kbd "C-c C-u"))
(global-set-key (kbd "C-c C-u") 'sd/comment-line-or-region)

;; Map F6 to describe-key
(global-unset-key (kbd "<f6>"))
(global-set-key (kbd "<f6>") 'describe-key)

;; Move mode line to top
(setq-default header-line-format mode-line-format)
;; Hide the bottom mode line
(setq-default mode-line-format nil)

;; display the fully qualified path in the frame title
(setq frame-title-format
      '((:eval (if (buffer-file-name)
		   (buffer-file-name))
	       "%b")))

;; display full screen
(global-unset-key (kbd "C-M-+"))
(global-set-key (kbd "C-M-+") 'toggle-frame-maximized)

;; Show corresponding paren
(show-paren-mode 1)

;; keyboard scroll one line at a time
(setq scroll-step 1)

;; suppress splash screen
(setq inhibit-startup-message t)

;; disable scrollbar, menu bar and tool bar
(scroll-bar-mode -1)
(menu-bar-mode -1)
(tool-bar-mode -1)

;; turn off blinking cursor
(blink-cursor-mode -1)

;; turn off the annoying beep
(setq visible-bell nil)

;; turn off line wrapping
(set-default 'truncate-lines t)

;; y/n instead of yes/no
(fset 'yes-or-no-p 'y-or-n-p)

;; Kill current buffer
(global-unset-key (kbd "C-<end>"))
(global-set-key (kbd "C-<end>") 'kill-this-buffer)

;; Enable deleting of selected text by subsequent input
(delete-selection-mode 1)

;; Match parens
(global-unset-key (kbd "C-]"))
(global-set-key (kbd "C-]") 'sd/forward-or-backward-sexp)

;; Duplicate line
(global-unset-key (kbd "C-c C-v"))
(global-set-key (kbd "C-c C-v") 'sd/duplicate-line-or-region)


;; Backup file configuration
;; back
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))

(setq make-backup-files t               ; backup of a file the first time it is saved.
      backup-by-copying t               ; don't clobber symlinks
      version-control t                 ; version numbers for backup files
      delete-old-versions t             ; delete excess backup files silently
      delete-by-moving-to-trash t
      kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
      kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
      auto-save-default t               ; auto-save every buffer that visits a file
      auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
      auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
      )

;; save desktop on exit
(desktop-save-mode 1)

;; toggle h-cpp
(global-unset-key (kbd "C-<return>"))
(global-set-key (kbd "C-<return>") 'ff-find-other-file)

;; the following buffers should open in the same emacs window
(add-to-list 'same-window-buffer-names "*Help*")
(add-to-list 'same-window-buffer-names "*Backtrace*")
(add-to-list 'same-window-buffer-names "*shell*")

;; mark the entire buffer
(global-set-key (kbd "M-a") 'mark-whole-buffer)
#+END_SRC

* Highlighting related customizations
#+BEGIN_SRC emacs-lisp

; adopted from the excellent exordium, by Philippe Grenet. All the credit is his.
(defvar sd/highlighted-symbols ()
  "list of regexps for the currently highlighted symbols. This
  variable is buffer-local.")

(make-variable-buffer-local 'sd/highlighted-symbols)

(defun sd/highlight-symbol ()
  "Toggles highlighting of occurrences of the symbol under point
in the current buffer. Up to 4 different symbols can be
highlighted using different colors at one time."
  (interactive)
  (let ((regex (find-tag-default-as-symbol-regexp)))
    (cond ((member regex sd/highlighted-symbols)
           ;; Remove highlight for this symbol.
           (setq sd/highlighted-symbols (remove regex sd/highlighted-symbols))
           (hi-lock-unface-buffer regex))
          (t
           ;; Add highlight for this symbol.
           (setq sd/highlighted-symbols (cons regex sd/highlighted-symbols))
           (hi-lock-face-symbol-at-point)))
    ; disable hl-mode when there are highlighted symbols as the
    ; hl-line face background interferes witht he highlighting
    (if sd/highlighted-symbols
      (progn
        (global-hl-line-mode 0)
	(setq-default cursor-type '(bar . 10))
        )
      (progn
        (setq-default cursor-type '(bar . 1))
        (global-hl-line-mode +1))
)))

(global-set-key (kbd "<f2>") 'sd/highlight-symbol)

;; hilight current line
(global-hl-line-mode +1)
;; (set-face-background hl-line-face "#005A64")
;; slightly prefer this color for the current line
(set-face-background hl-line-face "#345858")
#+END_SRC
* Color customizations
#+BEGIN_SRC emacs-lisp
;; Set cursor color to white
(set-cursor-color "cyan")
;; Make cursor a thin bar
(setq-default cursor-type '(bar . 1))
;; set background colors
(set-background-color "#2F4F4F")
;; color of border of buffer separator
(set-face-background 'fringe "#2F4F4F")
;; color of comments
(set-face-foreground 'font-lock-comment-face "#FA8278")
;; color of keyword
(set-face-foreground 'font-lock-keyword-face "#FF9664")
;; color of background
(set-face-foreground 'default "#FFF8DC")
;; color of srings
(set-face-foreground 'font-lock-string-face "#00ECC8")
;; selection/search background/foreground
(set-face-attribute 'region nil :background "black" :foreground "yellow" )
(set-face-attribute 'isearch nil :background "black" :foreground "yellow" )
(set-face-attribute 'lazy-highlight nil :background "black" :foreground "cyan" )
;; mode line colors
(set-face-attribute 'mode-line nil :background "black" :foreground "yellow" )
(set-face-attribute 'mode-line-inactive nil :background "dimgray" :foreground "white" )
;; (set-face-attribute 'header-line nil :background "black" :foreground "yellow" )
#+END_SRC

* Mac specific
#+BEGIN_SRC emacs-lisp
;; make command a meta key on Macs
(when (eq system-type 'darwin)
  (setq mac-command-modifier 'meta)
  )
#+END_SRC

* Window related
#+BEGIN_SRC emacs-lisp
;; Kill current window
(global-unset-key (kbd "M-<end>"))
(global-set-key (kbd "M-<end>") 'delete-window)
(global-set-key (kbd "C-M-<backspace>") 'delete-window)

;; Got to other window after horizontal/vertial split
(global-unset-key (kbd "\C-x2"))
(global-set-key "\C-x2"
		(lambda ()
		  (interactive)
		  (split-window-vertically)
		  (other-window 1)))

(global-unset-key (kbd "\C-x3"))
(global-set-key "\C-x3" (lambda ()
			  (interactive)
			  (split-window-horizontally)
			  (other-window 1)))

;; Window movements
(global-unset-key (kbd "M-l"))
(global-unset-key (kbd "M-<right>"))
(global-set-key (kbd "M-l") 'windmove-right)
(global-set-key (kbd "M-<right>") 'windmove-right)

(global-unset-key (kbd "M-h"))
(global-unset-key (kbd "M-<left>"))
(global-set-key (kbd "M-h") 'windmove-left)
(global-set-key (kbd "M-<left>") 'windmove-left)

(global-unset-key (kbd "M-k"))
(global-unset-key (kbd "M-<up>"))
(global-set-key (kbd "M-k") 'windmove-up)
(global-set-key (kbd "M-<up>") 'windmove-up)

(global-unset-key (kbd "M-j"))
(global-unset-key (kbd "M-<down>"))
(global-set-key (kbd "M-j") 'windmove-down)
(global-set-key (kbd "M-<down>") 'windmove-down)

;; update header line's color every time the buffer is switched
(add-hook 'buffer-list-update-hook
           'sd/update-header)

#+END_SRC
* Modes
** ace-jump-mode
#+BEGIN_SRC emacs-lisp
  ;; might want to consider switching to ivyy
  (use-package ace-jump-mode
    :ensure t
    :bind (("M-SPC" . ace-jump-word-mode )
	   ("C-M-r" . redraw-display )
	   )
    :init
    ;; disable gray background
    (setq ace-jump-mode-gray-background nil) 

    :config
    ;; use this to always push onto the global mark ring
    ;; when jumping
    (add-hook 'ace-jump-mode-before-jump-hook (lambda ()
						(back-button-push-mark-local-and-global)))
    ;; beacon blink after ace-jump
    (add-hook 'ace-jump-mode-end-hook (lambda ()
					(beacon-blink)))
    (custom-set-faces
     '(ace-jump-face-foreground
       ((t (:inherit ace-jump-face-foreground :height 1.0 :foreground "yellow" :background "black" )))))
    )
#+END_SRC

** autocomplete
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :ensure t
    :init
    (ac-config-default)
    (global-auto-complete-mode t)
    (setq ac-use-menu-map t)
    )
#+END_SRC
** backbutton
#+BEGIN_SRC emacs-lisp
  (defun sd/pop-global-mark-ring()
    (interactive)
    (back-button-global-backward)
    (setq global-mark-ring (butlast global-mark-ring 1))
    )

  (use-package back-button
    :ensure t
    :bind (("C-," . sd/pop-global-mark-ring )
	   )
    :init
    :config
    )
#+END_SRC
** beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
    (beacon-mode))
#+END_SRC
** dired
#+BEGIN_SRC emacs-lisp
  ;; Kick off dired with Ctrl-l
  (global-unset-key (kbd "C-l"))
  (global-set-key (kbd "C-l") 
		  (lambda ()
		    (interactive)
		    (dired ".") ))
  (add-hook 'dired-mode-hook
	    (lambda ()
	      (setq-local ace-jump-search-filter
			  (lambda ()
			    (get-text-property (point) 'dired-filename)))))
#+END_SRC
** iedit
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t
    :bind (("C-;" . iedit-mode))
    :config
    )
#+END_SRC
** expand-region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind (("C-=" . er/expand-region))
    )
#+END_SRC
** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :bind (("C-S-b" . helm-mini)
	   ("M-x"   . helm-M-x)             ;; meta-X is handled by Helm
	   ("<f1>"  . helm-imenu)          ;; Map F1 to helm-imenu
	   ("M-i"   . helm-occur)
	   ("M-y"   . helm-show-kill-ring)
	   )
    :init
    (setq helm-split-window-default-side 'same ; display helm in the same window
	  helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
	  helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
	  helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
	  helm-ff-file-name-history-use-recentf t
	  helm-mode-reverse-history           nil ; place helm command history on top

	  ;; need to investigate what these do
	  ;; just copied them from: https://github.com/yveszoundi/emacs.d/blob/master/bootstrap/startup.org
	  helm-ff-transformer-show-only-basename nil
	  ;;helm-adaptive-history-file             ers-helm-adaptive-history-file
	  ;;helm-boring-file-regexp-list           '("\\.git$" "\\.svn$" "\\.elc$" "*~$")
	  helm-recentf-fuzzy-match               t
	  helm-yank-symbol-first                 t
	  helm-buffers-fuzzy-matching            t
	  helm-ff-auto-update-initial-value      t
	  helm-input-idle-delay                  0.1
	  helm-idle-delay                        0.1)
    (use-package helm-projectile
      :ensure    helm-projectile
      :bind      ("M-o" . helm-projectile))
    )
#+END_SRC

** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind (("C-x g" . magit-status))
    :config
    ;; update magit heading line to yellow on black, the way I like it...  
    (set-face-attribute 'magit-diff-hunk-heading-highlight nil :background "black" :foreground "yellow" )
    )
#+END_SRC
** move-text
#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :ensure t
    ;; Text movement
    :bind (("C-S-<up>" . move-text-up )
	   ("C-S-<down>" . move-text-down ))
    :config
    )
#+END_SRC

** multiple-cursors
#+BEGIN_SRC emacs-lisp
  (defvar multiple-cursors-mode-enabled-hook nil
    "Hook that is run after `multiple-cursors-mode' is enabled.")

  (defvar multiple-cursors-mode-disabled-hook nil
    "Hook that is run after `multiple-cursors-mode' is disabled.")

  (defun sd/mc-when-enabled ()
    "Function to be added to `multiple-cursors-mode-enabled-hook'."
    (set-cursor-color "red"))

  (defun sd/mc-when-disabled ()
    "Function to be added to `multiple-cursors-mode-disabled-hook'."
    (set-cursor-color "white"))

  (use-package multiple-cursors
    :ensure t
    :bind (("C--" . mc/mark-next-like-this  )
	   )
    :init
    (add-hook 'multiple-cursors-mode-enabled-hook #'sd/mc-when-enabled)
    (add-hook 'multiple-cursors-mode-disabled-hook #'sd/mc-when-disabled)

    :config
    (set-face-background 'mc/cursor-bar-face "#2F4F4F")
    (set-face-foreground 'mc/cursor-bar-face "red")
    )
#+END_SRC
** org
#+BEGIN_SRC emacs-lisp
  ; indent propertly in org babel mode
  (setq org-src-tab-acts-natively t)
#+END_SRC

** projectile
#+BEGIN_SRC  emacs-lisp
  (use-package projectile
    :ensure    t
    :init
    (setq projectile-completion-system 'helm)
    ;; solves a performance issue
    ;; without this, every cursor movement is incredibly slow
    (setq projectile-mode-line
	  '(:eval (if (projectile-project-p)
		      (format " Proj[%s]"
			      (projectile-project-name))
		    ""))
	  )
    :config
    (projectile-global-mode t)
    )
#+END_SRC
** rectangle-mark-mode
#+BEGIN_SRC emacs-lisp
;; Select vertical region
(global-unset-key (kbd "C-M-<down>"))
(global-set-key (kbd "C-M-<down>") 'rectangle-mark-mode)

;; Use Control-w to kill selections in rectangle mode
(add-hook 'rectangle-mark-mode-hook (lambda() (define-key rectangle-mark-mode-map (kbd "C-w") 'delete-rectangle)) )
#+END_SRC
** rtags
#+BEGIN_SRC emacs-lisp
  (use-package rtags
    :ensure t
    :bind (("C-." . rtags-find-symbol-at-point)
	   ("C-," . rtags-location-stack-back)
	   ("C-x r" . rtags-find-references-at-point)
	   )
    )
#+END_SRC
** shell
#+BEGIN_SRC emacs-lisp
  ;; Run shell mode
  (global-unset-key (kbd "C-S-m"))
  (global-set-key (kbd "C-S-m") 'shell)
  ;; Don't ask to kill the shell buffer
  (add-hook 'shell-mode-hook (lambda() (set-process-query-on-exit-flag (get-process "shell") nil)) )
#+END_SRC
** try
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC
** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-mode))
#+END_SRC
** whole-line-or-region
#+BEGIN_SRC emacs-lisp
  (use-package whole-line-or-region
    :ensure t
    :bind (("C-w" . whole-line-or-region-kill-region)
	   )
    :config
    )
#+END_SRC

** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :init
    (yas-global-mode 1)
    :config
    )
#+END_SRC
** zoom-window
#+BEGIN_SRC emacs-lisp
  (use-package zoom-window
    :ensure t
    :bind (("C-M-z" . zoom-window-zoom)
	   )
    :init
    (setq zoom-window-mode-line-color "SteelBlue")
    :config
    )
#+END_SRC
** Modes to explore in the future
# 'auto-complete-c-headers
# 'ensime
# 'paredit
# 'rtags-ac

