#+STARTUP: overview

* Custom functions
#+BEGIN_SRC emacs-lisp
      ;;;###autoload
      (defun sd/forward-or-backward-sexp (&optional arg)
        "Go to the matching parenthesis character if one is adjacent to point."
        (interactive "^p")
        (cond ((looking-at "\\s(") (forward-sexp arg))
              ((looking-back "\\s)" 1) (backward-sexp arg))
              ;; Now, try to succeed from inside of a bracket
              ((looking-at "\\s)") (forward-char) (backward-sexp arg))
              ((looking-back "\\s(" 1) (backward-char) (forward-sexp arg))))

      ;;;###autoload
      (defun sd/duplicate-line-or-region(arg)
        "Duplicates the current line or region ARG times.
      If there's no region, the current line will be duplicated. However, if
      there's a region, all lines that region covers will be duplicated."
        (interactive "p")
        (let (beg end (origin (point)))
          (if (and mark-active (> (point) (mark)))
              (exchange-point-and-mark))
          (setq beg (line-beginning-position))
          (if mark-active
              (exchange-point-and-mark))
          (setq end (line-end-position))
          (let ((region (buffer-substring-no-properties beg end)))
            (dotimes (i arg)
              (goto-char end)
              (newline)
              (insert region)
              (setq end (point)))
            (goto-char (+ origin (* (length region) arg) arg)))))

      (defvar sd/copy-word-under-cursor-regex "[^[:word:]_]"
        "Regular expression to use when copying with `copy-word-under-cursor'.
      Can be customized for each major mode.")

      ;;;###autoload
      (defun sd/copy-word-under-cursor ()
        "Copy the word under the cursor to the kill ring."
        (interactive)
        (save-excursion
          (save-excursion (re-search-backward sd/copy-word-under-cursor-regex))
          (let ((beg (+ (match-beginning 0) 1))
                (end (re-search-forward sd/copy-word-under-cursor-regex)))
            (copy-region-as-kill beg (- end 1)))))


      ;;;###autoload
      (defun sd/update-header()
        (interactive)
        (mapc
         (lambda (window)
           (with-current-buffer (window-buffer window)
             ;; don't mess with buffers that don't have a header line
             (when header-line-format
               (let ((original-format (get 'header-line-format 'original))
                     (inactive-face 'mode-line-inactive)
                     (active-face 'mode-line)
                     ) ; change this to your favorite inactive header line face
                 ;; if we didn't save original format yet, do it now
                 (when (not original-format)
                   (put 'header-line-format 'original header-line-format)
                   (setq original-format header-line-format))
                 ;; check if this window is selected, set faces accordingly
                 (if (eq window (selected-window))
                     (setq header-line-format `(:propertize ,original-format face ,active-face))
                   (setq header-line-format `(:propertize ,original-format face ,inactive-face)))))))
         (window-list)))


      ;;;###autoload
      (defun sd/comment-line-or-region (n)
        "Comment or uncomment current line and leave point after it.
      With positive prefix, apply to N lines including current one.
      With negative prefix, apply to -N lines above.
      If region is active, apply to active region instead."
        (interactive "p")
        (save-excursion
          (if (use-region-p)
              (comment-or-uncomment-region
               (region-beginning) (region-end))
            (let ((range
                   (list (line-beginning-position)
                         (goto-char (line-end-position n)))))
              (comment-or-uncomment-region
               (apply #'min range)
               (apply #'max range)))
            (forward-line 1)
            (back-to-indentation))))

      ;;;###autoload
    (defun sd/open-org-init()
      (interactive)
      "Open initialization file and move to the end of the buffer."
      (sd/open-file-move-to-end "~/.emacs.d/myinit.org"))

      ;;;###autoload
    (defun sd/open-dev-notes()
      (interactive)
      "Load org initialization file and move to the end of the buffer."
      (sd/open-file-move-to-end "~/notes/development_notes.org"))

      ;;;###autoload
    (defun sd/open-file-move-to-end(file-name)
      (interactive)
      "Open a file and move to the end of the buffer."
      (find-file file-name)
      (end-of-buffer))

      ;;;###autoload
  (defmacro advise-commands-after (advice-name commands &rest body)
    "Apply advice named ADVICE-NAME to multiple COMMANDS.
  The body of the advice is in BODY."
    `(progn
       ,@(mapcar (lambda (command)
                   `(defadvice ,command (after ,(intern (concat (symbol-name command) "-" advice-name)) activate)
                      ,@body))
                 commands)))
#+END_SRC

* Global settings
#+BEGIN_SRC emacs-lisp

  ;; (advise-commands "auto-save"
  ;;                  (windmove-up windmove-down windmove-left windmove-right)
  ;;                  (prelude-auto-save))

  ;; fontify code in code blocks for org mode
  ;; somehow this does not work if I place this line
  ;; in the mode codfiguration section
  (setq org-src-fontify-natively t)

  ;; Paste the way I am used to
  (global-unset-key (kbd "C-v"))
  (global-set-key (kbd "C-v") 'yank)

  ;; Paste the way I am used to
  (global-unset-key (kbd "C-M-j"))
  (global-set-key (kbd "C-M-j") 'join-line)

  ;; Copy word under the cursor
  (global-unset-key (kbd "M-c"))
  (global-set-key (kbd "M-c") 'sd/copy-word-under-cursor)

  ;; Comment bindings
  (global-unset-key (kbd "C-c C-c"))
  (global-set-key (kbd "C-c C-c") 'sd/comment-line-or-region)
  (global-unset-key (kbd "C-c C-u"))
  (global-set-key (kbd "C-c C-u") 'sd/comment-line-or-region)

  ;; Map F6 to describe-key
  (global-unset-key (kbd "<f6>"))
  (global-set-key (kbd "<f6>") 'describe-key)

  ;; Move mode line to top
  ;(setq-default header-line-format mode-line-format)
  ;; Hide the bottom mode line
  ;(setq-default mode-line-format nil)

  ;; display the fully qualified path in the frame title
  (setq frame-title-format
        '((:eval (if (buffer-file-name)
                     (buffer-file-name))
                 "%b")))

  ;; display full screen
  (global-unset-key (kbd "C-M-+"))
  (global-set-key (kbd "C-M-+") 'toggle-frame-maximized)

  ;; Show corresponding paren
  (show-paren-mode 1)

  ;; keyboard scroll one line at a time
  (setq scroll-step 1)

  ;; suppress splash screen
  (setq inhibit-startup-message t)

  ;; disable scrollbar, menu bar and tool bar
  (scroll-bar-mode -1)
  (menu-bar-mode t)
  (tool-bar-mode -1)

  ;; turn off blinking cursor
  (blink-cursor-mode -1)

  ;; turn off the annoying beep
  (setq visible-bell nil)

  ;; turn off line wrapping
  (set-default 'truncate-lines t)

  ;; y/n instead of yes/no
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; Kill current buffer
  (global-unset-key (kbd "C-<end>"))
  (global-set-key (kbd "C-<end>") 'kill-this-buffer)

  ;; Enable deleting of selected text by subsequent input
  (delete-selection-mode 1)

  ;; Match parens
  (global-unset-key (kbd "C-]"))
  (global-set-key (kbd "C-]") 'sd/forward-or-backward-sexp)

  ;; Duplicate line
  (global-unset-key (kbd "C-c C-v"))
  (global-set-key (kbd "C-c C-v") 'sd/duplicate-line-or-region)


  ;; Backup file configuration
  ;; back
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))

  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default t               ; auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
        )

  ;; save desktop on exit
  (desktop-save-mode 1)

  ;; toggle h-cpp
  (global-unset-key (kbd "C-<return>"))
  (global-set-key (kbd "C-<return>") 'ff-find-other-file)

  ;; the following buffers should open in the same emacs window
  (add-to-list 'same-window-buffer-names "*Help*")
  (add-to-list 'same-window-buffer-names "*Backtrace*")
  (add-to-list 'same-window-buffer-names "*shell*")

  ;; mark the entire buffer
  (global-set-key (kbd "M-a") 'mark-whole-buffer)

  ;; indent with spaces
  (setq-default indent-tabs-mode nil)

  ;; unset Meta-x m, so that it can be reused for other purposes
  (global-unset-key (kbd "C-x m"))

  ;; copy text selected via a mouse to system's clipboard
  (setq mouse-drag-copy-region t)

  ;; open development notes
  (global-set-key (kbd "<f9>") 'sd/open-dev-notes)

  ;; open org initialization file
  (global-set-key (kbd "C-<f9>") 'sd/open-org-init)
#+END_SRC

* Highlighting related customizations
#+BEGIN_SRC emacs-lisp

; adopted from the excellent exordium, by Philippe Grenet. All the credit is his.
(defvar sd/highlighted-symbols ()
  "list of regexps for the currently highlighted symbols. This
  variable is buffer-local.")

(make-variable-buffer-local 'sd/highlighted-symbols)

(defun sd/highlight-symbol ()
  "Toggles highlighting of occurrences of the symbol under point
in the current buffer. Up to 4 different symbols can be
highlighted using different colors at one time."
  (interactive)
  (let ((regex (find-tag-default-as-symbol-regexp)))
    (cond ((member regex sd/highlighted-symbols)
           ;; Remove highlight for this symbol.
           (setq sd/highlighted-symbols (remove regex sd/highlighted-symbols))
           (hi-lock-unface-buffer regex))
          (t
           ;; Add highlight for this symbol.
           (setq sd/highlighted-symbols (cons regex sd/highlighted-symbols))
           (hi-lock-face-symbol-at-point)))
    ; disable hl-mode when there are highlighted symbols as the
    ; hl-line face background interferes witht he highlighting
    (if sd/highlighted-symbols
      (progn
        (global-hl-line-mode 0)
	(setq-default cursor-type '(bar . 10))
        )
      (progn
        (setq-default cursor-type '(bar . 1))
        (global-hl-line-mode +1))
)))

(global-set-key (kbd "<f2>") 'sd/highlight-symbol)

;; hilight current line
(global-hl-line-mode +1)
;; (set-face-background hl-line-face "#005A64")
;; slightly prefer this color for the current line
(set-face-background hl-line-face "#345858")
#+END_SRC
* Color customizations
#+BEGIN_SRC emacs-lisp
3  ;; Set cursor color to white
  (set-cursor-color "cyan")
  ;; Make cursor a thin bar
  (setq-default cursor-type '(bar . 1))
  ;; set background colors
  (set-background-color "#2F4F4F")
  ;; color of border of buffer separator
  (set-face-background 'fringe "#2F4F4F")
  ;; color of comments
  (set-face-foreground 'font-lock-comment-face "#FA8278")
  ;; color of keyword
  (set-face-foreground 'font-lock-keyword-face "#FF9664")
  ;; color of background
  (set-face-foreground 'default "#FFF8DC")
  ;; color of srings
  (set-face-foreground 'font-lock-string-face "#00ECC8")
  ;; selection/search background/foreground
  (set-face-attribute 'region nil :background "black" :foreground "yellow" )
  (set-face-attribute 'isearch nil :background "black" :foreground "yellow" )
  (set-face-attribute 'lazy-highlight nil :background "black" :foreground "cyan" )
  ;; mode line colors
  (set-face-attribute 'mode-line nil :background "black" :foreground "yellow" )
  (set-face-attribute 'mode-line-inactive nil :background "dimgray" :foreground "white" )
  ;(set-face-attribute 'header-line nil :background "black" :foreground "yellow" )

#+END_SRC

* Mac specific
#+BEGIN_SRC emacs-lisp
  ;; don't need this anymore as the command key is swapped with option to mimic windows keyboard layout
  ;; 
  ;; make command a meta key on Macs
  ;; (when (eq system-type 'darwin)
  ;;   (setq mac-command-modifier 'meta)
  ;;   (global-set-key (kbd "C-M-h") 'ns-do-hide-emacs)
  ;;   )
#+END_SRC

* Window related
#+BEGIN_SRC emacs-lisp
  ;; Kill current window
  (global-unset-key (kbd "M-<end>"))
  (global-set-key (kbd "M-<end>") 'delete-window)
  (global-set-key (kbd "C-M-<backspace>") 'delete-window)

  ;; Got to other window after horizontal/vertial split
  (global-unset-key (kbd "\C-x2"))
  (global-set-key "\C-x2"
                  (lambda ()
                    (interactive)
                    (split-window-vertically)
                    (other-window 1)))

  (global-unset-key (kbd "\C-x3"))
  (global-set-key "\C-x3" (lambda ()
                            (interactive)
                            (split-window-horizontally)
                            (other-window 1)))

  ;; Window movements
  (global-unset-key (kbd "M-l"))
  (global-unset-key (kbd "M-<right>"))
  (global-set-key (kbd "M-l") 'windmove-right)
  (global-set-key (kbd "M-<right>") 'windmove-right)

  (global-unset-key (kbd "M-h"))
  (global-unset-key (kbd "M-<left>"))
  (global-set-key (kbd "M-h") 'windmove-left)
  (global-set-key (kbd "M-<left>") 'windmove-left)

  (global-unset-key (kbd "M-k"))
  (global-unset-key (kbd "M-<up>"))
  (global-set-key (kbd "M-k") 'windmove-up)
  (global-set-key (kbd "M-<up>") 'windmove-up)

  (global-unset-key (kbd "M-j"))
  (global-unset-key (kbd "M-<down>"))
  (global-set-key (kbd "M-j") 'windmove-down)
  (global-set-key (kbd "M-<down>") 'windmove-down)

  ;; update header line's color every time the buffer is switched
  ;;(add-hook 'buffer-list-update-hook
  ;;          'sd/update-header)

#+END_SRC
* Modes
** ace-jump-mode
#+BEGIN_SRC emacs-lisp
  ;; might want to consider switching to ivyy
  (use-package ace-jump-mode
    :ensure t
    :bind (("M-SPC" . ace-jump-word-mode )
	   ("C-M-r" . redraw-display )
	   )
    :init
    ;; disable gray background
    (setq ace-jump-mode-gray-background nil) 

    :config
    ;; use this to always push onto the global mark ring
    ;; when jumping
    (add-hook 'ace-jump-mode-before-jump-hook (lambda ()
						(back-button-push-mark-local-and-global)))
    ;; beacon blink after ace-jump
    (add-hook 'ace-jump-mode-end-hook (lambda ()
					(beacon-blink)))
    (custom-set-faces
     '(ace-jump-face-foreground
       ((t (:inherit ace-jump-face-foreground :height 1.0 :foreground "yellow" :background "black" )))))
    )
#+END_SRC
** ace-window
#+BEGIN_SRC emacs-lisp
   (use-package ace-window
     :ensure t
     :init
     (setq aw-background nil)
     (global-set-key (kbd "C-x o") 'ace-window)
     :config
     (custom-set-faces
      '(aw-leading-char-face
        ((t (:inherit ace-jump-face-foreground :height 6.0)))))
     :diminish ace-window-mode)
#+END_SRC
** autocomplete
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :ensure t
    :init
    (ac-config-default)
    (global-auto-complete-mode t)
    (setq ac-use-menu-map t)
    (setq ac-delay 0.3)
    )
#+END_SRC
** backbutton
#+BEGIN_SRC emacs-lisp
  (defun sd/pop-global-mark-ring()
    (interactive)
    (back-button-global-backward)
    (setq global-mark-ring (butlast global-mark-ring 1))
    )

  (use-package back-button
    :ensure t
    :bind (("C-," . sd/pop-global-mark-ring )
	   )
    :init
    :config
    )
#+END_SRC
** beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
    (beacon-mode))
#+END_SRC
** cc-mode
#+BEGIN_SRC emacs-lisp
  ;; from https://github.com/philippe-grenet/exordium/blob/master/modules/init-bde-style.el

  ;;; Utility functions and constants

  (defconst exordium-bde-search-max-bound (* 80 25))
  ;;   "Maximum point to search when searching for some regexp/string. Often
  ;; the search is bound to the same line, however sometimes functionality needs to
  ;; account for multi-line definitions. In here we assume 80 (columns) * 25 (lines)
  ;; is enough for everyone.")

  (defun bde-component-name ()
    "Return the name of the component for the current buffer"
    (let ((name (file-name-sans-extension
                 (file-name-nondirectory (buffer-file-name)))))
      (cond ((string-match-p "\\.[gipu]\\.t$" name)
             (substring name 0 (- (length name) 4)))
            ((string-suffix-p ".t" name)
             (substring name 0 (- (length name) 2)))
            (t name))))

  (defun bde-package-name ()
    "Return the name of the package for the current buffer"
    (interactive)
    (let ((component-name (bde-component-name)))
      (substring
       component-name
       0
       (string-match "_" component-name
                     (if (string-prefix-p "s_" component-name)
                         2
                       0)))))

  ;;; Indentation
  ;;;
  ;;; This section define a C style named "bde" using c-add-style.  The offset
  ;;; in the specification (c-offset-alist) can be any of the following:
  ;;;
  ;;; - An integer -> specifies a relative offset. All relative offsets will be
  ;;;   added together and used to calculate the indentation relative to an
  ;;;   anchor position earlier in the buffer.
  ;;; - One of the symbols +, -, ++, --, *, or /
  ;;;   +   = c-basic-offset times 1
  ;;;   -   = c-basic-offset times −1
  ;;;   ++  = c-basic-offset times 2
  ;;;   --  = c-basic-offset times −2
  ;;;   *   = c-basic-offset times 0.5
  ;;;   /   = c-basic-offset times −0.5
  ;;;
  ;;; Note: to debug the indentation of a particular line, type 'C-c C-s'. It
  ;;; will display the variable 'c-syntactic-context' which is a list of the
  ;;; syntactic components affect the offset calculations for that line, with the
  ;;; character position in the buffer for each of them. More details in M-x
  ;;; info, then CC mode, then Interactive Customization.
  ;;; See cc-align.el for examples of line-up functions.

  (eval-when-compile (defvar c-syntactic-context))

  (defun bde-is-member-function-declaration ()
    "Return whether the line ending resembles the member function declaration."
    (re-search-forward
     (concat ") *\\(const\\)?"
             " *\\(noexcept\\|BSLS_CPP11_NOEXCEPT\\)?"
             " *\\(\\(= *\\(0\\|de\\(fault\\|lete\\)\\)\\)"
             "\\|BSLS_CPP11_DE\\(FAULT\\|LETED\\)"
             "\\|override\\|BSLS_CPP11_OVERRIDE\\)?"
             " *\\(&\\(&\\)?\\)?"
             " *; *$")
     (point-at-eol) t))

  (defun bde-comment-offset (element)
    "Custom line-up function for BDE comments.
  Return a symbol for the correct indentation level at the
  current cursor position, if the cursor is within a class definition:
  1. + for method comments:
          int foo() const = 0;
              // tab goes here
          int bar() { return 0; }
              // tab goes here
  2. column number of beginning of comment for data member comments:
          int d_data;     // my comment at whatever column I want
                          // tab goes here
          int d_someLongVariableName;
                          // my comment at whatever column I want
                          // tab goes here
  3. nil otherwise."
    (case (caar c-syntactic-context)
      ((inclass innamespace)
       (save-excursion
         (let ((class-offset         ; extra offset for inner structs
                (c-langelem-col (car c-syntactic-context) t))
               (comment-column nil)) ; column number of last //
           (loop
            (beginning-of-line)
            (cond ((= (point) (point-min))
                   (return nil))
                  ((re-search-forward "^ *//" (point-at-eol) t)
                   ;; looking at a comment line
                   (setq comment-column (- (current-column) 2))
                   (forward-line -1))
                  ((bde-is-member-function-declaration)
                   ;; looking at end of method declaration
                   (return '+))
                  ((re-search-forward "} *$" (point-at-eol) t)
                   ;; looking at end of inline method definition
                   (return '+))
                  ((re-search-forward "; *//" (point-at-eol) t)
                   ;; looking at beginning of data member comment block
                   (return (- (current-column) 2 class-offset c-basic-offset)))
                  ((and comment-column
                        (re-search-forward "[_A-Za-z0-9]+; *$"
                                           (point-at-eol) t))
                   ;; looking at end of (long?) data member declaration
                   (return (- comment-column class-offset c-basic-offset)))
                  (t
                   (return nil)))))))
      (t nil)))

  (defun bde-statement-block-intro-offset (element)
    "Custom line-up function for first line of a statement block.
  The default identation is is '+' (1 basic offset), unless we are in
  a switch statement, in which case the indentation is set to
  '*' (half basic offset). Example:
  switch(val) {
    case 100: {
        return 1;
    } break;
    default: {
        return 0;
    } break;
  }"
    (save-excursion
      (goto-char (c-langelem-pos element))
      (if (looking-at "\\(case\\|default\\)")
          '*
        '+)))

  ; associate .h file with c++ mode
  (add-to-list 'auto-mode-alist '("\\.[hc]\\'" . c++-mode))

  (use-package cc-mode
    :ensure t
    :init
    (setq c-default-style
          '((java-mode . "java")
            (awk-mode  . "awk")
            (c++-mode  . "bde")
            (other     . "gnu")))
    :config
    ; unbind c++-mode-map keys which interfer with global mappings
    (unbind-key "C-c C-c" c++-mode-map)
    (unbind-key "C-c C-u" c++-mode-map)

    ;; See http://cc-mode.sourceforge.net/html-manual/Syntactic-Symbols.html#Syntactic-Symbols
    (c-add-style
     "bde"
     '((c-basic-offset . 4)
       (c-comment-only-line-offset . 0)
       (fill-column . 79)
       (c-backslash-column . 78)
       (c-backslash-max-column . 78)
       (c-offsets-alist
        (comment-intro         . bde-comment-offset)
        (defun-open            . 0)
        (defun-close           . 0)
        (statement-block-intro . bde-statement-block-intro-offset)
        (substatement-open     . 0)
        (substatement-label    . 0)
        (label                 . 0)
        (access-label          . /)
        (case-label            . *)
        (statement-case-intro  . *)
        (statement-case-open   . 0)
        (statement-cont        . +)
        (inline-open           . 0)
        (inline-close          . 0)
        (innamespace           . 0)
        (member-init-intro     . 0)
        (extern-lang-open      . 0)
        (brace-list-entry      . /)
        (extern-lang-close     . 0))))
    )
#+END_SRC
** dired
#+BEGIN_SRC emacs-lisp
    ;; Kick off dired with Ctrl-l
    (global-unset-key (kbd "C-l"))
    (global-set-key (kbd "C-l") 
                    (lambda ()
                      (interactive)
                      (dired ".") ))
    (add-hook 'dired-mode-hook
              (lambda ()
                (setq-local ace-jump-search-filter
                            (lambda ()
                              (get-text-property (point) 'dired-filename)))
                ; End/Back key goes up one directory in dired mode
                (define-key dired-mode-map  (kbd "<end>") 'dired-up-directory)
                ; unset Cntl+Shift+b in dired mode which is by default wants to bookmark a file
                ; while I like it to bring up the helm-mini
                (local-unset-key (kbd "C-S-b"))
                (define-key dired-mode-map  (kbd "M-i") 'helm-occur)))

  (use-package dired
    :config
    ;; enable dired omit mode
    (require 'dired-x)
    (setq-default dired-omit-files-p t) ; Buffer-local variable
    (setq dired-omit-files
    ; omit files I don't care about
    (concat dired-omit-files "\\|\\.o$\\|\\.d$\\|\\.dd$\\|\\.sundev1.c$\\|\\.mapfile$\\|\\.depends$\\|\\.ibm$\\|\\.sundev1$\\|\\.trap$\\|^llcalc_\\|^00"))
    ; subpackages
    (use-package dired-hacks-utils :ensure t)
    (use-package dired-narrow
      :ensure t
      :config))
#+END_SRC
** dired+
#+BEGIN_SRC emacs-lisp
  (use-package dired+
    :ensure t
    :demand t
    :config
    (diredp-make-find-file-keys-reuse-dirs))
#+END_SRC
** iedit
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t
    :bind (("C-;" . iedit-mode))
    :config
    )
#+END_SRC
** expand-region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind (("C-=" . er/expand-region))
    )
#+END_SRC
** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :bind (("C-S-b"   . helm-mini)
           ("M-x"     . helm-M-x)             ;; meta-X is handled by Helm
           ("<f1>"    . helm-imenu)          ;; Map F1 to helm-imenu
           ("M-i"     . helm-occur)
           ("M-y"     . helm-show-kill-ring)
           ("C-x C-f" . helm-find-files))
    :init
    (setq helm-split-window-default-side 'same ; display helm in the same window
          helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
          helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
          helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
          helm-ff-file-name-history-use-recentf t
          helm-mode-reverse-history           nil ; place helm command history on top
          helm-ff-transformer-show-only-basename t; only show basename when helm-find-file, to show full path "C-]"

          ;; need to investigate what these do
          ;; just copied them from: https://github.com/yveszoundi/emacs.d/blob/master/bootstrap/startup.org
          ;;helm-adaptive-history-file             ers-helm-adaptive-history-file
          ;;helm-boring-file-regexp-list           '("\\.git$" "\\.svn$" "\\.elc$" "*~$")
          helm-recentf-fuzzy-match               t
          helm-yank-symbol-first                 t
          helm-buffers-fuzzy-matching            t
          helm-ff-auto-update-initial-value      t
          helm-input-idle-delay                  0.1
          helm-idle-delay                        0.1)

    (use-package helm-projectile
      :ensure    helm-projectile
      :bind      ("M-o" . helm-projectile))

    :config
    ; make helm selection yellow on black
    (set-face-attribute 'helm-visible-mark nil 
                    :background "black"
                    :foreground "yellow")
    ; make current line in helm pleasant to look at
    (set-face-attribute 'helm-selection nil
                        :background "DarkCyan"
                        :foreground "white")
    )
#+END_SRC

** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind (("C-x g" . magit-status)
           ("C-x m l" . magit-log-all)
           )
    :config
    ;; update magit heading line to yellow on black, the way I like it...  
    (set-face-attribute 'magit-diff-hunk-heading-highlight nil :background "black" :foreground "yellow" )
    )
#+END_SRC
** move-text
#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :ensure t
    ;; Text movement
    :bind (("C-S-<up>" . move-text-up )
           ("C-S-<down>" . move-text-down ))
    :config
    )
#+END_SRC

** multiple-cursors
#+BEGIN_SRC emacs-lisp
  (defvar multiple-cursors-mode-enabled-hook nil
    "Hook that is run after `multiple-cursors-mode' is enabled.")

  (defvar multiple-cursors-mode-disabled-hook nil
    "Hook that is run after `multiple-cursors-mode' is disabled.")

  (defun sd/mc-when-enabled ()
    "Function to be added to `multiple-cursors-mode-enabled-hook'."
    (set-cursor-color "red"))

  (defun sd/mc-when-disabled ()
    "Function to be added to `multiple-cursors-mode-disabled-hook'."
    (set-cursor-color "white"))

  (use-package multiple-cursors
    :ensure t
    :bind (("C--" . mc/mark-next-like-this  )
	   )
    :init
    (add-hook 'multiple-cursors-mode-enabled-hook #'sd/mc-when-enabled)
    (add-hook 'multiple-cursors-mode-disabled-hook #'sd/mc-when-disabled)

    :config
    (set-face-background 'mc/cursor-bar-face "#2F4F4F")
    (set-face-foreground 'mc/cursor-bar-face "red")
    )
#+END_SRC
** nxml
#+BEGIN_SRC emacs-lisp
  (use-package nxml-mode
      :config
      (unbind-key "C-c C-u" nxml-mode-map)
      (unbind-key "M-h" nxml-mode-map))
#+END_SRC
** org
#+BEGIN_SRC emacs-lisp
  (use-package org
      :ensure t
      :init
      (unbind-key "M-h" org-mode-map)
      ; indent propertly in org babel mode
      (setq org-src-tab-acts-natively t))
#+END_SRC

** projectile
#+BEGIN_SRC  emacs-lisp
  (use-package projectile
    :ensure    t
    :init
    (setq projectile-completion-system 'helm)
    ;; solves a performance issue
    ;; without this, every cursor movement is incredibly slow
    (setq projectile-mode-line
	  '(:eval (if (projectile-project-p)
		      (format " Proj[%s]"
			      (projectile-project-name))
		    ""))
	  )
    :config
    (projectile-global-mode t)
    )
#+END_SRC
** rectangle-mark-mode
#+BEGIN_SRC emacs-lisp
    (use-package rect
      :bind(("C-M-<down>" . rectangle-mark-mode)
            :map rectangle-mark-mode-map
            ("C-w" . delete-rectangle)))
#+END_SRC
** rtags
#+BEGIN_SRC emacs-lisp
  (use-package rtags
    :ensure t
    :bind (("C-." . rtags-find-symbol-at-point)
	   ("C-," . rtags-location-stack-back)
	   ("C-x r" . rtags-find-references-at-point)
	   )
    )
#+END_SRC
** shell
#+BEGIN_SRC emacs-lisp
  ;; ;; Run shell mode
  ;; (global-unset-key (kbd "C-S-m"))
  ;; (global-set-key (kbd "C-S-m") 'shell)
  ;; Don't ask to kill the shell buffer
  (add-hook 'shell-mode-hook (lambda() (set-process-query-on-exit-flag (get-process "shell") nil)) )
#+END_SRC
** shell-pop
#+BEGIN_SRC emacs-lisp
  (use-package shell-pop
    :ensure t
    :bind (("C-S-m" . shell-pop))
    :config
     ;; Don't ask to kill the shell buffer
     (add-hook 'shell-mode-hook (lambda() (set-process-query-on-exit-flag (get-process "shell") nil)) )
     (setq shell-pop-shell-type
      (quote ("eshell" "*eshell*" (lambda nil (eshell shell-pop-term-shell)))))
     (setq shell-pop-term-shell "/bin/bash")
     (setq shell-pop-window-height 60)
     (setq shell-pop-full-span t)
     (setq shell-pop-window-position "bottom"))

#+END_SRC
** swap-buffers
#+BEGIN_SRC emacs-lisp
  (use-package swap-buffers
    :ensure t
    :bind("C-<f12>" . swap-buffers)
    :init
    (setq swap-buffers-keep-focus t)
    :config
    ;;(advice-add 'swap-buffers :after 'sd/update-header)
    )
#+END_SRC
** transpose-frame
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :ensure t
    :bind("<f12>" . flop-frame)
    :config
    ;;(advice-add 'flop-frame :after 'sd/update-header)
    )
#+END_SRC
** try
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC
** vlf
#+BEGIN_SRC emacs-lisp
  (use-package vlf
    :ensure t
    :init)
    ;; (global-set-key (kbd "C-x o") 'ace-window)
    ;; :diminish ace-window-mode)

#+END_SRC
** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-mode))
#+END_SRC
** whole-line-or-region
#+BEGIN_SRC emacs-lisp
  (use-package whole-line-or-region
    :ensure t
    :bind (("C-w" . whole-line-or-region-kill-region)
	   ("C-c c" . whole-line-or-region-kill-ring-save)
	   )
    :config
    )
#+END_SRC
** wrap-region
#+BEGIN_SRC emacs-lisp
  (use-package wrap-region
    :ensure   t
    :config
    (wrap-region-global-mode t)
    (wrap-region-add-wrappers
     '(("(" ")")
       ("[" "]")
       ("{" "}")
       ("<" ">")
       ("'" "'")
       ("\"" "\"")
       ("‘" "’"   "q")
       ("“" "”"   "Q")
       ("*" "*"   "b"   org-mode)                 ; bolden
       ("*" "*"   "*"   org-mode)                 ; bolden
       ("/" "/"   "i"   org-mode)                 ; italics
       ("/" "/"   "/"   org-mode)                 ; italics
       ("~" "~"   "c"   org-mode)                 ; code
       ("~" "~"   "~"   org-mode)                 ; code
       ("=" "="   "v"   org-mode)                 ; verbatim
       ("=" "="   "="   org-mode)                 ; verbatim
       ("_" "_"   "u" '(org-mode markdown-mode))  ; underline
       ("**" "**" "b"   markdown-mode)            ; bolden
       ("*" "*"   "i"   markdown-mode)            ; italics
       ("`" "`"   "c" '(markdown-mode ruby-mode)) ; code
       ("`" "'"   "c"   lisp-mode)                ; code
       ))
    :diminish wrap-region-mode)
#+END_SRC
** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :init
    (yas-global-mode 1)
    :config
    )
#+END_SRC
** zoom-window
#+BEGIN_SRC emacs-lisp
  (use-package zoom-window
    :ensure t
    :bind (("C-M-z" . zoom-window-zoom)
	   )
    :init
    (setq zoom-window-mode-line-color "SteelBlue")
    :config
    )
#+END_SRC
** Modes to explore in the future
# 'auto-complete-c-headers
# 'ensime
# 'paredit
# 'rtags-ac
# web-mode
** Changes to do
*** find a way to reliably highlight header-line
*** try to use bear or output of make to index files via rtags
