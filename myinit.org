#+STARTUP: overview

* Global settings
#+BEGIN_SRC emacs-lisp
  ;; set the default font
  (when (member "DejaVu Sans Mono" (font-family-list))
    (set-face-attribute 'default nil :font "DejaVu Sans Mono"))

  (if (file-readable-p "/usr/local/share/emacs/site-lisp/doxymacs")
      (progn
        ;; load doxymacs installed via: brew install doxymacs
        (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/doxymacs/")
        ;; load doxymacs
        (require 'doxymacs)))

  ;; fontify code in code blocks for org mode
  ;; somehow this does not work if I place this line
  ;; in the mode codfiguration section
  (setq org-src-fontify-natively t)

  ;; Paste the way I am used to
  (global-unset-key (kbd "C-v"))
  (global-set-key (kbd "C-v") 'yank)

  (global-unset-key (kbd "C-M-v"))
  (global-set-key (kbd "C-M-v") 'yank-rectangle)

  ;; Paste the way I am used to
  (global-unset-key (kbd "C-M-j"))
  (global-set-key (kbd "C-M-j") 'join-line)

  ;; Copy word under the cursor
  (global-unset-key (kbd "M-c"))
  (global-set-key (kbd "M-c") 'sd/copy-word-under-cursor)

  ;; Copy word under the cursor
  (global-unset-key (kbd "C-M-c"))
  (global-set-key (kbd "C-M-c") 'sd/copy-buffer-name-to-clipboard)

  ;; Comment bindings
  (global-unset-key (kbd "C-c C-c"))
  (global-set-key (kbd "C-c C-c") 'sd/comment-line-or-region)
  (global-unset-key (kbd "C-c C-u"))
  (global-set-key (kbd "C-c C-u") 'sd/comment-line-or-region)

  ;; Map F6 to describe-key
  (global-unset-key (kbd "<f6>"))
  (global-set-key (kbd "<f6>") 'describe-key)

  ;; display the fully qualified path in the frame title
  (setq frame-title-format
        '((:eval (if (buffer-file-name)
                     (buffer-file-name))
                 "%b")))

  ;; display full screen
  (global-unset-key (kbd "C-M-+"))
  (global-set-key (kbd "C-M-+") 'toggle-frame-maximized)

  ;; Show corresponding paren
  (show-paren-mode 1)

  ;; keyboard scroll one line at a time
  (setq scroll-step 1)
  ;; don't jump around when scrolling
  (setq scroll-conservatively 101)

  ;; suppress splash screen
  (setq inhibit-startup-message t)

  ;; disable scrollbar, menu bar and tool bar
  (scroll-bar-mode -1)
  (menu-bar-mode t)
  (tool-bar-mode -1)

  ;; turn off blinking cursor
  (blink-cursor-mode -1)

  ;; turn off the annoying beep
  (setq visible-bell nil)

  ;; turn off line wrapping
  (set-default 'truncate-lines t)

  ;; y/n instead of yes/no
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; Kill current buffer
  (global-unset-key (kbd "C-<end>"))
  (global-set-key (kbd "C-<end>") 'kill-this-buffer)

  ;; Enable deleting of selected text by subsequent input
  (delete-selection-mode 1)

  ;; Match parens
  (global-unset-key (kbd "C-]"))
  (global-set-key (kbd "C-]") 'sd/forward-or-backward-sexp)

  ;; Duplicate line
  (global-unset-key (kbd "C-c C-v"))
  (global-set-key (kbd "C-c C-v") 'sd/duplicate-line-or-region)

  ;; Split current line
  (global-unset-key (kbd "C-M-o"))
  (global-set-key (kbd "C-M-o") 'sd/split-current-line)

  ;; Backup file configuration
  ;; back
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))

  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default t               ; auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
        )

  ;; save desktop on exit
  (desktop-save-mode 1)

  ;; toggle h-cpp
  (global-unset-key (kbd "C-<return>"))
  (global-set-key (kbd "C-<return>") 'ff-find-other-file)

  ;; the following buffers should open in the same emacs window
  (add-to-list 'same-window-buffer-names "*Help*")
  (add-to-list 'same-window-buffer-names "*Backtrace*")
  (add-to-list 'same-window-buffer-names "*shell*")

  ;; mark the entire buffer
  (global-set-key (kbd "M-a") 'mark-whole-buffer)

  ;; indent with spaces
  (setq-default indent-tabs-mode nil)

  ;; unset Meta-x m, so that it can be reused for other purposes
  (global-unset-key (kbd "C-x m"))

  ;; copy text selected via a mouse to system's clipboard
  (setq mouse-drag-copy-region t)

  ;; open development notes
  (global-set-key (kbd "<f9>") 'sd/open-dev-notes)

  ;; open org initialization file
  (global-set-key (kbd "C-<f9>") 'sd/open-org-init)

  ;; use ff-find-related-file as a poor substitute for rtags index db, but that
  ;; is needed right now
  (global-unset-key (kbd "C-M-."))
  (global-set-key (kbd "C-M-.") 'ff-find-related-file)

  ;; setting to 2, original value is t,
  ;; performance enhancement, seems to help a little when commenting out large chunks of c++ code
  (setq font-lock-maximum-decoration t)

  ;; line numbers everywhere. turn off if this feature becomes too expensive
  (global-linum-mode 1)

  ;; grep the entire project. grep seems to work better than "ag"
  (global-unset-key (kbd "C-M-i"))
  (global-set-key (kbd "C-M-i") 'helm-projectile-grep)

  ;; keybinding for re-centering the buffer
  (global-unset-key (kbd "M-r"))
  (global-set-key (kbd "M-r") 'recenter-top-bottom)

  ;; activate which-function mode
  (which-function-mode 1)

  ;; enable flyspell programming mode
  (flyspell-prog-mode)

  ;; start scrolling when within 3 lines of either top or bottom of the window
  (setq scroll-margin 3)

  ;; conveniently map repeat to F7
  (global-unset-key (kbd "<f7>"))
  (global-set-key (kbd "<f7>") 'repeat)

  ;; man pages
  (global-unset-key (kbd "C-c m"))
  (global-set-key (kbd "C-c m") 'helm-man-woman)
  ;; display man page in the current buffer
  (setq Man-notify-method 'pushy)

  ;; always select help window
  (setq help-window-select t)

  ;; Copy word under the cursor
  (global-unset-key (kbd "C-M-b"))
  (global-set-key (kbd "C-M-b") 'helm-bookmarks)

#+END_SRC

* Custom functions
#+BEGIN_SRC emacs-lisp
  (defun sd/find-last-include()
    "Find the last include in the current buffer"
    (interactive)
    (push-mark (point))
    (setq matched-position (search-backward "#include" nil t))
    (if matched-position
        (progn
          (next-line)
          (recenter-top-bottom))
      (message "Did not find a #include")))

            ;;;###autoload
  (defun sd/forward-or-backward-sexp (&optional arg)
    "Go to the matching parenthesis character if one is adjacent to point."
    (interactive "^p")
    (cond ((looking-at "\\s(") (forward-sexp arg))
          ((looking-back "\\s)" 1) (backward-sexp arg))
          ;; Now, try to succeed from inside of a bracket
          ((looking-at "\\s)") (forward-char) (backward-sexp arg))
          ((looking-back "\\s(" 1) (backward-char) (forward-sexp arg))))

            ;;;###autoload
  (defun sd/duplicate-line-or-region(arg)
    "Duplicates the current line or region ARG times.
            If there's no region, the current line will be duplicated. However, if
            there's a region, all lines that region covers will be duplicated."
    (interactive "p")
    (let (beg end (origin (point)))
      (if (and mark-active (> (point) (mark)))
          (exchange-point-and-mark))
      (setq beg (line-beginning-position))
      (if mark-active
          (exchange-point-and-mark))
      (setq end (line-end-position))
      (let ((region (buffer-substring-no-properties beg end)))
        (dotimes (i arg)
          (goto-char end)
          (newline)
          (insert region)
          (setq end (point)))
        (goto-char (+ origin (* (length region) arg) arg)))))

  (defvar sd/copy-word-under-cursor-regex "[^[:word:]_]"
    "Regular expression to use when copying with `copy-word-under-cursor'.
            Can be customized for each major mode.")

            ;;;###autoload
  (defun sd/copy-word-under-cursor ()
    "Copy the word under the cursor to the kill ring."
    (interactive)
    (save-excursion
      (save-excursion (re-search-backward sd/copy-word-under-cursor-regex))
      (let ((beg (+ (match-beginning 0) 1))
            (end (re-search-forward sd/copy-word-under-cursor-regex)))
        (copy-region-as-kill beg (- end 1)))))

            ;;;###autoload
  (defun sd/update-header()
    (interactive)
    (mapc
     (lambda (window)
       (with-current-buffer (window-buffer window)
         ;; don't mess with buffers that don't have a header line
         (when header-line-format
           (let ((original-format (get 'header-line-format 'original))
                 (inactive-face 'mode-line-inactive)
                 (active-face 'mode-line)
                 ) ; change this to your favorite inactive header line face
             ;; if we didn't save original format yet, do it now
             (when (not original-format)
               (put 'header-line-format 'original header-line-format)
               (setq original-format header-line-format))
             ;; check if this window is selected, set faces accordingly
             (if (eq window (selected-window))
                 (setq header-line-format `(:propertize ,original-format face ,active-face))
               (setq header-line-format `(:propertize ,original-format face ,inactive-face)))))))
     (window-list)))


            ;;;###autoload
  (defun sd/comment-line-or-region (n)
    "Comment or uncomment current line and leave point after it.
     With positive prefix, apply to N lines including current one.
     With negative prefix, apply to -N lines above.
     If region is active, apply to active region instead."
    (interactive "p")
    (save-excursion
      (if (use-region-p)
          (comment-or-uncomment-region
           (region-beginning) (region-end))
        (let ((range
               (list (line-beginning-position)
                     (goto-char (line-end-position n)))))
          (comment-or-uncomment-region
           (apply #'min range)
           (apply #'max range)))
        (forward-line 1)
        (back-to-indentation))))

            ;;;###autoload
  (defun sd/open-org-init()
    (interactive)
    "Open initialization file and move to the end of the buffer."
    (sd/open-file-move-to-end "~/.emacs.d/myinit.org"))

            ;;;###autoload
  (defun sd/open-dev-notes()
    (interactive)
    "Load org initialization file and move to the end of the buffer."
    (sd/open-file-move-to-end "~/notes/development_notes.org"))

            ;;;###autoload
  (defun sd/open-file-move-to-end(file-name)
    (interactive)
    "Open a file and move to the end of the buffer."
    (find-file file-name)
    (end-of-buffer))

            ;;;###autoload
  (defmacro sd/advise-commands-after (advice-name commands &rest body)
    "Apply advice named ADVICE-NAME to multiple COMMANDS.
        The body of the advice is in BODY."
    `(progn
       ,@(mapcar (lambda (command)
                   `(defadvice ,command (after ,(intern (concat (symbol-name command) "-" advice-name)) activate)
                      ,@body))
                 commands)))

            ;;;###autoload
  (defun sd/copy-file-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the clipboard." filename))))

            ;;;###autoload
  (defun sd/copy-buffer-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (kill-new (buffer-name)))

  (defun sd/revert-all-buffers ()
    "Refreshes all open buffers from their respective files."
    (interactive)
    (dolist (buf (buffer-list))
      (with-current-buffer buf
        (when (and (buffer-file-name) (file-exists-p (buffer-file-name)) (not (buffer-modified-p)))
          (revert-buffer t t t) )))
    (message "Refreshed open files.") )

  (defun sd/man-follow ()
    "When viewing cppman man page, format the arguments in a way built in man command understands."
    (interactive)
    (if ( and (string-match-p "std::" (buffer-name)) (string-match-p "::" (Man-default-man-entry)))
        (man-follow (concat "std::" (Man-default-man-entry))))
    (man (Man-default-man-entry)))

  (defun sd/split-current-line ()
    "Split current line."
    (interactive)
    (move-beginning-of-line nil)
    (set-mark-command nil)
    (move-end-of-line nil)
    (replace-regexp "[ \t]+" "\n" nil (region-beginning) (region-end)))

#+END_SRC

* Highlighting related customizations
#+BEGIN_SRC emacs-lisp

; adopted from the excellent exordium, by Philippe Grenet. All the credit is his.
(defvar sd/highlighted-symbols ()
  "list of regexps for the currently highlighted symbols. This
  variable is buffer-local.")

(make-variable-buffer-local 'sd/highlighted-symbols)

(defun sd/highlight-symbol ()
  "Toggles highlighting of occurrences of the symbol under point
in the current buffer. Up to 4 different symbols can be
highlighted using different colors at one time."
  (interactive)
  (let ((regex (find-tag-default-as-symbol-regexp)))
    (cond ((member regex sd/highlighted-symbols)
           ;; Remove highlight for this symbol.
           (setq sd/highlighted-symbols (remove regex sd/highlighted-symbols))
           (hi-lock-unface-buffer regex))
          (t
           ;; Add highlight for this symbol.
           (setq sd/highlighted-symbols (cons regex sd/highlighted-symbols))
           (hi-lock-face-symbol-at-point)))
    ; disable hl-mode when there are highlighted symbols as the
    ; hl-line face background interferes witht he highlighting
    (if sd/highlighted-symbols
      (progn
        (global-hl-line-mode 0)
	(setq-default cursor-type '(bar . 7))
        (set-cursor-color "red")
        )
      (progn
        (setq-default cursor-type '(bar . 1))
        (set-cursor-color "cyan")
        (global-hl-line-mode +1))
)))

(global-set-key (kbd "<f2>") 'sd/highlight-symbol)

;; hilight current line
(global-hl-line-mode +1)
;; slightly prefer this color for the current line
;; (set-face-background hl-line-face "#345858")
(set-face-background hl-line-face "#345865")
#+END_SRC
* Color customizations
#+BEGIN_SRC emacs-lisp
  ;; Set cursor color to white
  (set-cursor-color "cyan")
  ;; Make cursor a thin bar
  (setq-default cursor-type '(bar . 1))
  ;; set background colors
  (set-background-color "#2F4F4F")
  ;; color of border of buffer separator
  (set-face-background 'fringe "#2F4F4F")
  ;; color of comments
  (set-face-foreground 'font-lock-comment-face "#FA8278")
  ;; color of keyword
  (set-face-foreground 'font-lock-keyword-face "#FF9664")
  ;; color of background
  (set-face-foreground 'default "#FFF8DC")
  ;; color of srings
  (set-face-foreground 'font-lock-string-face "#00ECC8")
  ;; selection/search background/foreground
  (set-face-attribute 'region nil :background "black" :foreground "yellow" )
  (set-face-attribute 'isearch nil :background "black" :foreground "yellow" )
  (set-face-attribute 'lazy-highlight nil :background "black" :foreground "cyan" )
#+END_SRC

* Mac specific
#+BEGIN_SRC emacs-lisp
  ;; don't need this anymore as the command key is swapped with option to mimic windows keyboard layout
  ;;
  ;; make command a meta key on Macs
  ;; (when (eq system-type 'darwin)
  ;;   (setq mac-command-modifier 'meta)
  ;;   (global-set-key (kbd "C-M-h") 'ns-do-hide-emacs)
  ;;   )
#+END_SRC

* Window related
#+BEGIN_SRC emacs-lisp
  ;; Kill current window
  (global-unset-key (kbd "M-<end>"))
  (global-set-key (kbd "M-<end>") 'delete-window)
  (global-set-key (kbd "C-M-<backspace>") 'delete-window)

  ;; Got to other window after horizontal/vertial split
  (global-unset-key (kbd "\C-x2"))
  (global-set-key "\C-x2"
                  (lambda ()
                    (interactive)
                    (split-window-vertically)
                    (other-window 1)))

  (global-unset-key (kbd "\C-x3"))
  (global-set-key "\C-x3" (lambda ()
                            (interactive)
                            (split-window-horizontally)
                            (other-window 1)))

  ;; Window movements
  (global-unset-key (kbd "M-l"))
  (global-unset-key (kbd "M-<right>"))
  (global-set-key (kbd "M-l") 'windmove-right)
  (global-set-key (kbd "M-<right>") 'windmove-right)

  (global-unset-key (kbd "M-h"))
  (global-unset-key (kbd "M-<left>"))
  (global-set-key (kbd "M-h") 'windmove-left)
  (global-set-key (kbd "M-<left>") 'windmove-left)

  (global-unset-key (kbd "M-k"))
  (global-unset-key (kbd "M-<up>"))
  (global-set-key (kbd "M-k") 'windmove-up)
  (global-set-key (kbd "M-<up>") 'windmove-up)

  (global-unset-key (kbd "M-j"))
  (global-unset-key (kbd "M-<down>"))
  (global-set-key (kbd "M-j") 'windmove-down)
  (global-set-key (kbd "M-<down>") 'windmove-down)

  ;; update header line's color every time the buffer is switched
  ;;(add-hook 'buffer-list-update-hook
  ;;          'sd/update-header)

#+END_SRC
* Modes
** ac-rtags
#+BEGIN_SRC emacs-lisp
(use-package ac-rtags
    :ensure t)
#+END_SRC
** ace-jump-mode
#+BEGIN_SRC emacs-lisp
  ;; might want to consider switching to ivyy
  (use-package ace-jump-mode
    :ensure t
    :bind (("M-SPC" . ace-jump-word-mode )
	   ("C-M-r" . redraw-display )
	   )
    :init
    ;; disable gray background
    (setq ace-jump-mode-gray-background nil)

    :config
    ;; use this to always push onto the global mark ring
    ;; when jumping
    (add-hook 'ace-jump-mode-before-jump-hook (lambda ()
						(back-button-push-mark-local-and-global)))
    ;; beacon blink after ace-jump
    (add-hook 'ace-jump-mode-end-hook (lambda ()
					(beacon-blink)))
    (custom-set-faces
     '(ace-jump-face-foreground
       ((t (:inherit ace-jump-face-foreground :height 1.0 :foreground "yellow" :background "black" )))))
    )
#+END_SRC
** ace-window
#+BEGIN_SRC emacs-lisp
   (use-package ace-window
     :ensure t
     :init
     (setq aw-background nil)
     (global-set-key (kbd "C-x o") 'ace-window)
     :config
     (custom-set-faces
      '(aw-leading-char-face
        ((t (:inherit ace-jump-face-foreground :height 6.0)))))
     :diminish ace-window-mode)
#+END_SRC
** autocomplete
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :diminish auto-complete-mode
    :ensure t
    :bind (("C-S-SPC" . auto-complete))
    :init
    (ac-config-default)
    (global-auto-complete-mode t)
    (setq ac-use-menu-map t)
    (setq ac-delay 0.1)
    ;; auto-completion after 2 characters
    (setq ac-auto-start 2))
#+END_SRC
** auto-complete-c-headers
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete-c-headers
    :ensure t)
#+END_SRC
** backbutton
#+BEGIN_SRC emacs-lisp
  (defun sd/pop-global-mark-ring()
    (interactive)
    (back-button-global-backward)
    (setq global-mark-ring (butlast global-mark-ring 1))
    )

  (use-package back-button
    :ensure t
    ;; :bind (("C-," . sd/pop-global-mark-ring )
           ;; )
    :init
    :config
    )
#+END_SRC
** beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
    (beacon-mode)
    (setq beacon-color "Green"))
#+END_SRC
** company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (global-company-mode)
    (setq company-idle-delay 0))
#+END_SRC
** company-rtags
#+BEGIN_SRC emacs-lisp
  (use-package company-rtags
    ;; disable for now, very slow and most importantly doesn't work
    :disabled
    :ensure t
    :config
    (push 'company-rtags company-backends))
#+END_SRC
** company-irony
#+BEGIN_SRC emacs-lisp
  (use-package company-irony
    :ensure t
    :bind (("C-SPC" . company-complete))
    :init
    (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
    (setq company-backends (delete 'company-semantic company-backends))
    (setq company-backends (delete 'company-clang company-backends))
    :config
    (eval-after-load 'company
    '(add-to-list
      'company-backends '(company-irony-c-headers company-irony))))
#+END_SRC
** company-irony-c-headers
#+BEGIN_SRC emacs-lisp
  (use-package company-irony-c-headers
    :ensure t)
#+END_SRC
** cc-mode
#+BEGIN_SRC emacs-lisp
  ;; from https://github.com/philippe-grenet/exordium/blob/master/modules/init-bde-style.el

  ;;; Utility functions and constants

  (defconst exordium-bde-search-max-bound (* 80 25))
  ;;   "Maximum point to search when searching for some regexp/string. Often
  ;; the search is bound to the same line, however sometimes functionality needs to
  ;; account for multi-line definitions. In here we assume 80 (columns) * 25 (lines)
  ;; is enough for everyone.")

  (defun bde-component-name ()
    "Return the name of the component for the current buffer"
    (let ((name (file-name-sans-extension
                 (file-name-nondirectory (buffer-file-name)))))
      (cond ((string-match-p "\\.[gipu]\\.t$" name)
             (substring name 0 (- (length name) 4)))
            ((string-suffix-p ".t" name)
             (substring name 0 (- (length name) 2)))
            (t name))))

  (defun bde-package-name ()
    "Return the name of the package for the current buffer"
    (interactive)
    (let ((component-name (bde-component-name)))
      (substring
       component-name
       0
       (string-match "_" component-name
                     (if (string-prefix-p "s_" component-name)
                         2
                       0)))))

  ;;; Indentation
  ;;;
  ;;; This section define a C style named "bde" using c-add-style.  The offset
  ;;; in the specification (c-offset-alist) can be any of the following:
  ;;;
  ;;; - An integer -> specifies a relative offset. All relative offsets will be
  ;;;   added together and used to calculate the indentation relative to an
  ;;;   anchor position earlier in the buffer.
  ;;; - One of the symbols +, -, ++, --, *, or /
  ;;;   +   = c-basic-offset times 1
  ;;;   -   = c-basic-offset times −1
  ;;;   ++  = c-basic-offset times 2
  ;;;   --  = c-basic-offset times −2
  ;;;   *   = c-basic-offset times 0.5
  ;;;   /   = c-basic-offset times −0.5
  ;;;
  ;;; Note: to debug the indentation of a particular line, type 'C-c C-s'. It
  ;;; will display the variable 'c-syntactic-context' which is a list of the
  ;;; syntactic components affect the offset calculations for that line, with the
  ;;; character position in the buffer for each of them. More details in M-x
  ;;; info, then CC mode, then Interactive Customization.
  ;;; See cc-align.el for examples of line-up functions.

  (eval-when-compile (defvar c-syntactic-context))

  (defun bde-is-member-function-declaration ()
    "Return whether the line ending resembles the member function declaration."
    (re-search-forward
     (concat ") *\\(const\\)?"
             " *\\(noexcept\\|BSLS_CPP11_NOEXCEPT\\)?"
             " *\\(\\(= *\\(0\\|de\\(fault\\|lete\\)\\)\\)"
             "\\|BSLS_CPP11_DE\\(FAULT\\|LETED\\)"
             "\\|override\\|BSLS_CPP11_OVERRIDE\\)?"
             " *\\(&\\(&\\)?\\)?"
             " *; *$")
     (point-at-eol) t))

  (defun bde-comment-offset (element)
    "Custom line-up function for BDE comments.
  Return a symbol for the correct indentation level at the
  current cursor position, if the cursor is within a class definition:
  1. + for method comments:
          int foo() const = 0;
              // tab goes here
          int bar() { return 0; }
              // tab goes here
  2. column number of beginning of comment for data member comments:
          int d_data;     // my comment at whatever column I want
                          // tab goes here
          int d_someLongVariableName;
                          // my comment at whatever column I want
                          // tab goes here
  3. nil otherwise."
    (case (caar c-syntactic-context)
      ((inclass innamespace)
       (save-excursion
         (let ((class-offset         ; extra offset for inner structs
                (c-langelem-col (car c-syntactic-context) t))
               (comment-column nil)) ; column number of last //
           (loop
            (beginning-of-line)
            (cond ((= (point) (point-min))
                   (return nil))
                  ((re-search-forward "^ *//" (point-at-eol) t)
                   ;; looking at a comment line
                   (setq comment-column (- (current-column) 2))
                   (forward-line -1))
                  ((bde-is-member-function-declaration)
                   ;; looking at end of method declaration
                   (return '+))
                  ((re-search-forward "} *$" (point-at-eol) t)
                   ;; looking at end of inline method definition
                   (return '+))
                  ((re-search-forward "; *//" (point-at-eol) t)
                   ;; looking at beginning of data member comment block
                   (return (- (current-column) 2 class-offset c-basic-offset)))
                  ((and comment-column
                        (re-search-forward "[_A-Za-z0-9]+; *$"
                                           (point-at-eol) t))
                   ;; looking at end of (long?) data member declaration
                   (return (- comment-column class-offset c-basic-offset)))
                  (t
                   (return nil)))))))
      (t nil)))

  (defun bde-statement-block-intro-offset (element)
    "Custom line-up function for first line of a statement block.
  The default identation is is '+' (1 basic offset), unless we are in
  a switch statement, in which case the indentation is set to
  '*' (half basic offset). Example:
  switch(val) {
    case 100: {
        return 1;
    } break;
    default: {
        return 0;
    } break;
  }"
    (save-excursion
      (goto-char (c-langelem-pos element))
      (if (looking-at "\\(case\\|default\\)")
          '*
        '+)))

  ; associate .h file with c++ mode
  (add-to-list 'auto-mode-alist '("\\.[hc]\\'" . c++-mode))

  (use-package cc-mode
    :ensure t
    :bind(;; for the time being pop global mark
          ;; after rtags is configured, will need to integrate
          ;; with rtags ring
          :map c++-mode-map
               ("C-x i". sd/find-last-include)
               ("<f1>". rtags-helm-select-taglist)
               ("C-M-f" . rtags-find-symbol))
    :init
    ;; enable electric pair mode for buffers in c-mode
    (add-hook 'c++-mode-hook #'electric-pair-local-mode)
    (setq c-default-style
          '((java-mode . "java")
            (awk-mode  . "awk")
            (c++-mode  . "bde")
            (other     . "gnu")))
    :config
    ;; unbind c++-mode-map keys which interfer with global mappings
    (unbind-key "C-c C-c" c++-mode-map)
    (unbind-key "C-c C-u" c++-mode-map)

    ;; trigger company completion via tab
    ;; (define-key c-mode-map [(tab)] 'company-complete)
    ;; (define-key c++-mode-map [(tab)] 'company-complete)

    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)

    ;; See http://cc-mode.sourceforge.net/html-manual/Syntactic-Symbols.html#Syntactic-Symbols
    (c-add-style
     "bde"
     '((c-basic-offset . 4)
       (c-comment-only-line-offset . 0)
       (fill-column . 79)
       (c-backslash-column . 78)
       (c-backslash-max-column . 78)
       (c-offsets-alist
        (comment-intro         . bde-comment-offset)
        (defun-open            . 0)
        (defun-close           . 0)
        (statement-block-intro . bde-statement-block-intro-offset)
        (substatement-open     . 0)
        (substatement-label    . 0)
        (label                 . 0)
        (access-label          . /)
        (case-label            . *)
        (statement-case-intro  . *)
        (statement-case-open   . 0)
        (statement-cont        . +)
        (inline-open           . 0)
        (inline-close          . 0)
        (innamespace           . 0)
        (member-init-intro     . 0)
        (extern-lang-open      . 0)
        (brace-list-entry      . /)
        (extern-lang-close     . 0))))
    )
#+END_SRC
** diminish
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t)
#+END_SRC

** dired
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :bind ( ("C-l" . dired-jump)
            :map dired-mode-map
            ("C-M-i" . helm-projectile-grep)
            ("M-i" . helm-occur)
            ;; End/Back key goes up one directory in dired mode
            ("<end>" . dired-up-directory))
    :config
    ;; enable dired omit mode
    (require 'dired-x)
    (setq-default dired-omit-files-p t) ; Buffer-local variable
    (setq dired-omit-files
          ;; omit files I don't care about
          (concat dired-omit-files "\\|\\.o$\\|\\.d$\\|\\.dd$\\|\\.sundev1.c$\\|\\.mapfile$\\|\\.depends$\\|\\.ibm$\\|\\.sundev1$\\|\\.trap$\\|^llcalc_\\|^00"))
    ;; unset Cntl+Shift+b in dired mode which is by default wants to bookmark a file
    ;; while I like it to bring up the helm-mini
    (local-unset-key (kbd "C-S-b"))
    (setq-local ace-jump-search-filter
                          (lambda ()
                            (get-text-property (point) 'dired-filename)))
    ;; set up better colors
    (set-face-attribute 'diredp-flag-mark-line nil :background "black" :foreground "yellow" )
    (set-face-attribute 'diredp-flag-mark nil :background "black" :foreground "green" )
    (set-face-attribute 'diredp-deletion nil :background "black" :foreground "firebrick1" )
    ;; subpackages
    (use-package dired-hacks-utils :ensure t)
    (use-package dired-narrow
      :ensure t
      :config))
#+END_SRC
** dired+
#+BEGIN_SRC emacs-lisp
  (use-package dired+
    :ensure t
    :demand t
    :config
    (diredp-make-find-file-keys-reuse-dirs))
#+END_SRC
** esup
#+BEGIN_SRC emacs-lisp
(use-package esup
  :ensure t)
#+END_SRC
** exordium
Relevant code from exordium, by Philippe Grenet. All the credit is his.
*** init-prefs
#+BEGIN_SRC emacs-lisp
(defcustom exordium-complete-mode :auto-complete
  "Slect the completion engine for exordium. Possible values are
  :auto-complete, :company, and nil. Default is :auto-complete. See also
  `exordium-rtags-auto-complete'."
  :group 'exordium
  :type  'symbol)
;;; RTags

;;; See init-rtags.el
(defcustom exordium-rtags-rdm-args nil
  "Command-line arguments passed to rdm, if needed. This should
be a list of strings."
  :group 'exordium
  :type  'sexp)

(defcustom exordium-rtags-syntax-checker :flymake
  "The syntax checker to be used with rtags. If set to :flycheck the
`flycheck-rtags' will be used. Otherwise, the built-in flymake will be used."
  :group 'exordium
  :type  'symbol)

;;; See init-rtags-cdb.el
(defcustom exordium-rtags-source-file-extensions '("*.cpp" "*.c")
  "List of source file extension patterns for creating a
  compilation database using command
  `rtags-create-compilation-database'. Not needed for CMake projects."
  :group 'exordium
  :type  'sexp)

;;; See init-helm.el
(defcustom exordium-helm-everywhere t
  "Whether Helm should be used as a substitute for common key bindings."
  :group 'exordium
  :type  'boolean)

;;; See init-rtags-helm.el
(defcustom exordium-rtags-helm-everywhere t
  "Whether RTags uses Helm to display list of results, rather
  than its own UI"
  :group 'exordium
  :type  'boolean)

#+END_SRC
*** init-lib
#+BEGIN_SRC emacs-lisp
  ;;;; Init lib
  ;;;
  ;;; This file defines utility functions reused in other modules. It should be
  ;;; loaded before any other module.

  (with-no-warnings (require 'cl))

  
  ;;; Files

  (defun exordium-directory-tree (dir)
    "Returns the list of subdirs of 'dir' excluding any dot
  dirs. Input is a string and output is a list of strings."
    (let* ((dir   (directory-file-name dir))
           (dirs  '())
           (files (directory-files dir nil nil t)))
      (dolist (f files)
        (unless (string-equal "." (substring f 0 1))
          (let ((f (concat dir "/" f)))
            (when (file-directory-p f)
              (setq dirs (append (cons f (exordium-directory-tree f))
                                 dirs))))))
      dirs))

  (defun exordium-read-file-lines (file)
    "Return a list of lines (strings) of the specified file"
    (with-temp-buffer
      (insert-file-contents file)
      (split-string (buffer-string) "\n" t)))

  (defun exordium-read-file-as-string (file)
    "Return the content of the specified file as a string."
    (with-temp-buffer
      (insert-file-contents file)
      (buffer-string)))

  (defun exordium-parent-directory (dir)
    "Return the path of the dir's parent directory"
    (file-name-directory (directory-file-name dir)))

  
  ;;; String manipulation functions

  (require 'subr-x)

  ;; string-prefix-p has been in Emacs for years, but string-suffix-p was
  ;; introduced only in Emacs 24.4.

  (unless (fboundp 'string-suffix-p)
    (defun string-suffix-p (suffix string  &optional ignore-case)
      "Return non-nil if SUFFIX is a suffix of STRING.
  If IGNORE-CASE is non-nil, the comparison is done without paying
  attention to case differences."
      (let ((start-pos (- (length string) (length suffix))))
        (and (>= start-pos 0)
             (eq t (compare-strings suffix nil nil
                                    string start-pos nil ignore-case))))))

  ;; Other string functions introduced in Emacs 24.4:

  (unless (fboundp 'string-trim-left)
    (defsubst string-trim-left (string)
      "Remove leading whitespace from STRING."
      (if (string-match "\\`[ \t\n\r]+" string)
          (replace-match "" t t string)
        string)))

  (unless (fboundp 'string-trim-right)
    (defsubst string-trim-right (string)
      "Remove trailing whitespace from STRING."
      (if (string-match "[ \t\n\r]+\\'" string)
          (replace-match "" t t string)
        string)))

  (unless (fboundp 'string-trim)
    (defsubst string-trim (string)
      "Remove leading and trailing whitespace from STRING."
      (string-trim-left (string-trim-right string))))

  (eval-when-compile (assert (not (fboundp 'string-truncate))))

  (defun string-truncate (string n)
    "Return STRING minus the last N characters."
    (substring string 0 (max 0(- (length string) n))))

  
  ;;; Add backtick to electric pair mode. It makes buffer local variable with
  ;;; an extra back tick added
  (defun exordium-electric-mode-add-back-tick ()
    (when exordium-enable-electric-pair-mode
      (setq-local electric-pair-pairs
                  (append electric-pair-pairs '((?` . ?`))))
      (setq-local electric-pair-text-pairs
                  (append electric-pair-text-pairs '((?` . ?`))))))
#+END_SRC
*** init-rtags
#+BEGIN_SRC emacs-lisp
  ;;;; Rtags - see `https://github.com/Andersbakken/rtags'
  ;;;
  ;;; Rtags keys use prefix C-c r
  ;;; ---------- ----------------------------------------------------------------
  ;;; Key        Function
  ;;; ---------- ----------------------------------------------------------------
  ;;; C-c r .    `rtags-find-symbol-at-point'
  ;;; M-.
  ;;; C-c r ,    `rtags-find-references-at-point'
  ;;; M-,
  ;;;
  ;;; C-c r >    `rtags-find-symbol' (prompts for symbol name)
  ;;; C-c r <    `rtags-find-references' (prompts for symbol name)
  ;;;
  ;;; M-C-g      List all buffer symbols with Helm
  ;;;
  ;;; ---------- ----------------------------------------------------------------
  ;;; C-c r v    `rtags-find-virtuals-at-point' list all impl. of function
  ;;; C-c r ;    `rtags-find-file' find file in project using partial name
  ;;;
  ;;; C-c r R    `rtags-rename-symbol'
  ;;; C-c r F    `rtags-fixit' fix the error using clang "did you mean".
  ;;;
  ;;; C-c r [    `rtags-location-stack-back' go back to previous location
  ;;; C-{
  ;;; C-c r ]    `rtags-location-stack-forward' the opposite
  ;;; C-}
  ;;;
  ;;; ---------- ----------------------------------------------------------------
  ;;;            `rtags-start': start rdm in a subprocess and start RTags
  ;;;            diagnostics.
  ;;;            `rtags-stop': kill rdm subprocess and RTags diagnostics.
  ;;; C-c r l    `rtags-show-rdm-buffer' show rdm log buffer.
  ;;;            `rtags-set-current-project' switch between projects
  ;;; C-c r e    `rtags-reparse-file' force recompile current buffer.
  ;;;
  ;;; ---------- ----------------------------------------------------------------
  ;;; C-c r D    `rtags-diagnostics' start diagnostics/force reparse
  ;;; C-c r Q    `rtags-stop-diagnostics' stop the diagnostic subprocess
  ;;; C-c r d    `rtags-show-diagnostics-buffer' toggle diag window
  ;;;            (without reparsing)
  ;;; C-c r down `rtags-next-diag' goes to the next problem.
  ;;; C-c r up   `rtags-previous-diag' goes to previous problem.
  ;;; C-c r c    `rtags-clear-diagnostics' clears any error or warning overlay.
  ;;;            `rtags-stop-diagnostics' stops the process.
  ;;;
  ;;; ---------- ----------------------------------------------------------------
  ;;; C-c r U    `rtags-print-cursorinfo' show what we know about symbol
  ;;; C-c r P    `rtags-print-dependencies' show all includes
  ;;; C-c r T    `rtags-taglist' show all tags in a window on left side
  ;;;
  ;;;
  ;;; Building rtags
  ;;; ==============
  ;;; $ git clone https://github.com/Andersbakken/rtags.git
  ;;; $ cd rtags
  ;;; $ git submodule init && git submodule update
  ;;; $ cmake .
  ;;; $ make
  ;;;
  ;;; Files
  ;;; =====
  ;;; Rtags uses the following files:
  ;;; `~/.rtags' (created automatically)
  ;;;     Where rdm stores its index files. They are reloaded when it restarts.
  ;;; `~/.rdmrc' (optional)
  ;;;     Config file for rdm (see rdm.cpp) containing default command line args.
  ;;; `.rtags-config' (optional, located in project root dir)
  ;;;     Project configuration file. Not needed if there is a .git or .svn at
  ;;;     the project root.
  ;;; `compile_commands.json' (optional, located in project root dir)
  ;;;     Compilation database for a given project, containing for each file the
  ;;;     clang command to build it. Not needed if you use RTags's compiler
  ;;;     wrapper scripts.
  ;;;
  ;;; Running rdm in a shell
  ;;; ======================
  ;;; Run `rdm' in a shell or in the background. Use -L to specify a log file.
  ;;; Use --help for the list of options. You can stop it gracefully with: rc -q
  ;;;
  ;;; You can control rdm with the rc client (use --help to see all options):
  ;;; $ rc -w
  ;;;     List the loaded projects and show the active one.
  ;;; $ rc -w proj
  ;;;     Make "proj" the active project ("proj" is a regex).
  ;;; $ rc -J
  ;;;     Reload the compilation DB from the current directory.
  ;;; $ rc -W proj
  ;;;     Delete project.
  ;;; $ rc --find-project-root /path/to/sourcefile.cpp
  ;;;     Print what it determines to be the correct project root.
  ;;; $ rc -T sourcefile.cpp
  ;;;     Say wether this component is indexed or not.
  ;;; $ rc -q
  ;;;     Shutdown rdm.
  ;;;
  ;;; Running rdm in Emacs
  ;;; ====================
  ;;; M-x `rtags-start'. A buffer will be created with rdm logs; you can show
  ;;; it with "C-c r l".
  ;;; M-x `rtags-stop' to kill it.
  ;;;
  ;;; Setting up a new project
  ;;; ========================
  ;;; 1. If the project root dir does not contain a .git or .svn repo, create a
  ;;;    file `.rtags-config' in the root dir with the specified content:
  ;;;    project: /path/to/project
  ;;;
  ;;; 2. The next step is to create the compilation database
  ;;;    `compile_commands.json'. For that, use CMake or use module
  ;;;     init-rtags-cdb.el.
  ;;;
  ;;; Diagnostics mode
  ;;; ================
  ;;; RTags diagnostics is a subprocess that highlight compilation errors and
  ;;; warnings in the code (using flymake or flycheck). Click on a highlighted
  ;;; region to view the error message. Use "C-c r d" (lowercase d) to display
  ;;; the diagnostics buffer containing the error messages without forcing a
  ;;; reparsing of the current file.
  ;;;
  ;;; It is started by default, but you can control it with:
  ;;; - "C-c r D" or M-x `rtags-diagnostics' to start,
  ;;; - "C-c r q" or M-x `rtags-stop-diagnostics' to terminate the subprocess.

  (with-no-warnings (require 'cl))
  (require 'rtags)
  (require 'ac-rtags)
  (require 'auto-complete-c-headers)
  (require 'projectile)

  
  ;;; Turn on flycheck support when requested
  (when (eq exordium-rtags-syntax-checker :flycheck)
    (require 'flycheck-rtags)
    ;; As per: https://github.com/Andersbakken/rtags#rtags-flycheck-integration
    (cl-flet ((flycheck-rtags-hook ()
                                   (flycheck-select-checker 'rtags)
                                   (setq-local flycheck-highlighting-mode nil)
                                   (setq-local flycheck-check-syntax-automatically nil)))
      (add-hook 'c-mode-hook #'flycheck-rtags-hook)
      (add-hook 'c++-mode-hook #'flycheck-rtags-hook)
      (add-hook 'objc-mode-hook #'flycheck-rtags-hook)))

  ;;; Key bindings

  ;; Enable default keys from rtags with prefix "Ctrl-C r"".
  ;; The default prefix is "Ctrl-x r" but almost all keys are bound;
  ;; "Ctrl-c r" is not defined by default, so we get the whole keyboard.
  (rtags-enable-standard-keybindings c-mode-base-map "\C-cr")

  (defun exordium-rtags-find-symbol-at-point (&optional prefix other-window)
    "Redefinition of `rtags-find-symbol-at-point' that returns t on
  success and nil if not found. This implementation comes from
  https://github.com/Andersbakken/rtags/blob/master/src/rtags.el c75467b"
    (interactive "P")
    (rtags-delete-rtags-windows)
    (rtags-location-stack-push)
    (let ((arg (rtags-current-location))
          (tagname (or (rtags-current-symbol) (rtags-current-token)))
          (fn (buffer-file-name))
          (found-it nil))
      (rtags-reparse-file-if-needed)
      (with-current-buffer (rtags-get-buffer)
        (rtags-call-rc :path fn :path-filter prefix "-f" arg)
        (cond ((or (not rtags-follow-symbol-try-harder)
                   (= (length tagname) 0))
               (setq found-it (rtags-handle-results-buffer nil nil fn other-window)))
              ((setq found-it (rtags-handle-results-buffer nil t fn other-window)))
              (t
               (erase-buffer)
               (rtags-call-rc :path fn "-F" tagname "--definition-only" "-M" "1" "--dependency-filter" fn :path-filter prefix
                              (when rtags-wildcard-symbol-names "--wildcard-symbol-names")
                              (when rtags-symbolnames-case-insensitive "-I"))
               (unless (setq found-it (rtags-handle-results-buffer nil nil fn other-window))
                 (erase-buffer)
                 (rtags-call-rc :path fn "-F" tagname "-M" "1" "--dependency-filter" fn :path-filter prefix
                                (when rtags-wildcard-symbol-names "--wildcard-symbol-names")
                                (when rtags-symbolnames-case-insensitive "-I"))
                 (setq found-it (rtags-handle-results-buffer nil nil fn other-window)))))
        (recenter))
      found-it))

  ;; Alias for C-c r . This key recenters the buffer if needed.
  (define-key c-mode-base-map "\M-."
    (lambda (other-window)
      (interactive "P")
      (exordium-rtags-find-symbol-at-point nil other-window)))

  ;; Alias for C-c r ,
  (define-key c-mode-base-map "\M-," (function rtags-find-references-at-point))

  ;; Alias for C-c r [
  (define-key c-mode-base-map [(control c) (r) (left)] (function rtags-location-stack-back))
  ;; Alias for C-c r [
  (define-key c-mode-base-map [(control c) (r) (right)] (function rtags-location-stack-forward))

  (define-key c-mode-base-map [(meta control g)] (function rtags-imenu))

  (define-key c-mode-base-map [(control c) (r) (down)] (function rtags-next-diag))
  (define-key c-mode-base-map [(control c) (r) (up)] (function rtags-previous-diag))
  (define-key c-mode-base-map [(control c) (r) (c)] (function rtags-clear-diagnostics))

  (define-key c-mode-base-map "\C-crQ" (function rtags-stop-diagnostics))

  
  ;;; Start rdm as a subprocess, with output in a buffer

  (defun exordium-rtags-start-rdm-maybe ()
    "Start rdm if not already running. Return t if started and nil
  otherwise."
    (unless (exordium-rtags-rdm-running-p)
      (exordium-rtags-start-rdm-impl nil)
      t))

  (defun exordium-rtags-rdm-running-p ()
    "Predicate testing if rdm is running"
    (let ((process (get-process "rdm")))
      (or
       ;; Rdm runs in a process started from Emacs
       (and (processp process)
            (not (eq (process-status process) 'exit))
            (not (eq (process-status process) 'signal)))
       ;; User has started rdm outside of Emacs
       ;; Note: sadly this does not work on macOS
       (let ((uuid (user-uid)))
         (dolist (pid (reverse (list-system-processes)))
           (let* ((attrs (process-attributes pid))
                  (pname (cdr (assoc 'comm attrs)))
                  (puid  (cdr (assoc 'euid attrs))))
             (when (and (eq puid uuid)
                        (string= pname "rdm"))
                (return t))))))))

  (defun exordium-rtags-start-rdm-impl (&optional open-buffer)
    "Start rdm in a subprocess. Open the rdm log buffer if
  open-buffer is true."
    (let ((buffer (get-buffer-create "*RTags rdm*")))
      (when open-buffer
        (switch-to-buffer buffer))
      (with-current-buffer buffer
        (rtags-rdm-mode)
        (read-only-mode))
      (let ((process
             (apply #'start-process "rdm" buffer "rdm" exordium-rtags-rdm-args)))
        (message "Started rdm - PID %d" (process-id process))))
    ;; Add RTags to company backends
    (when (and (eq exordium-complete-mode :company)
               (not (member 'company-rtags company-backends)))
      (push 'company-rtags company-backends)))

  (defun rtags-start ()
    "Start the rdm deamon in a subprocess and display output in a
  buffer. Also start the RTag diagostics mode."
    (interactive)
    (setq rtags-autostart-diagnostics t)
    (exordium-rtags-start-rdm-impl t))

  (defun rtags-stop ()
    "Stop both RTags diagnostics and rdm, if they are running."
    (interactive)
    ;; Remove RTags from company backends
    (when (and (eq exordium-complete-mode :company)
               (member 'company-rtags company-backends))
      (setq company-backends (delete 'company-rtags company-backends)))
    ;; Stop RTags Diagnostics and kill its buffer without prompt
    (when (and rtags-diagnostics-process
               (not (eq (process-status rtags-diagnostics-process) 'exit)))
      (kill-process rtags-diagnostics-process))
    (when (get-buffer "*RTags Diagnostics*")
      (let ((kill-buffer-query-functions nil))
        (kill-buffer "*RTags Diagnostics*")))
    ;; Stop rdm and kill its buffer without prompt
    (rtags-quit-rdm)
    (when (get-buffer "*RTags rdm*")
      (let ((kill-buffer-query-functions nil))
        (kill-buffer "*RTags rdm*"))))

  (defun rtags-show-rdm-buffer ()
    "Show/hide the rdm log buffer"
    (interactive)
    (let* ((buffer-name "*RTags rdm*")
           (buffer (get-buffer buffer-name))
           (window (and buffer (get-buffer-window buffer))))
      (cond (window
             (bury-buffer buffer)
             (delete-window window))
            (buffer
             (display-buffer buffer))
            (t
             (message "Rtags rdm is not running (use M-x rtags-start)")))))

  (define-key c-mode-base-map [(control c)(r)(l)] 'rtags-show-rdm-buffer)

  
  ;;; Mode for rdm log output
  ;;; See http://ergoemacs.org/emacs/elisp_syntax_coloring.html

  (defsubst rtags-rdm-record-search-forward (&optional regexp bound)
    "Search forward from point for a log line matching REGEXP.
  Set point to the end of the occurrence found, and return point.
  An optional second argument BOUND bounds the search: the match
  found must not extend after that position. This function also
  sets `match-data' to the entire match."
    (let ((org-pos (point)))
      (block while-loop
        ;; While there are more matches for REGEXP
        (while (re-search-forward regexp bound t)
          (if (re-search-backward "^" org-pos t)
              (let ((begin-pos (point)))
                ;; If we found a matching log line, set match data and return
                (if (re-search-forward "$" bound t)
                    (progn
                      (set-match-data (list begin-pos (point)))
                      (return-from while-loop (point)))
                  (return-from while-loop))))))))

  (defun rtags-rdm-match-record-error (bound)
    "Search forward from point to BOUND for error."
    (rtags-rdm-record-search-forward "\\(error:\\)" bound))

  (defun rtags-rdm-match-record-warning (bound)
    "Search forward from point to BOUND for warning."
    (rtags-rdm-record-search-forward "\\(warning:\\)" bound))

  (defun rtags-rdm-match-record-note (bound)
    "Search forward from point to BOUND for note."
    (rtags-rdm-record-search-forward "\\(note:\\)" bound))

  (defun rtags-rdm-match-record-done (bound)
    "Search forward from point to BOUND for Jobs."
    (rtags-rdm-record-search-forward "\\(Jobs\\)" bound))

  (defconst rtags-rdm-mode-keywords
    (list '(rtags-rdm-match-record-error 0 'compilation-error)
          '(rtags-rdm-match-record-warning 0 'compilation-warning)
          '(rtags-rdm-match-record-note 0 'compilation-info)
          '(rtags-rdm-match-record-done 0 'underline))
    "Describes how to syntax highlight keywords in rtags-rdm-mode.")

  (defconst rtags-rdm-mode-syntax-table
    ;; Defines a "comment" as anything that starts with a square bracket, e.g.
    ;; [100%] /path/to/file.cpp in 437ms. (1259 syms, etc) (dirty)
    (let ((synTable (make-syntax-table)))
      (modify-syntax-entry ?\[ "< b" synTable)
      (modify-syntax-entry ?\n "> b" synTable)
      synTable))

  (define-derived-mode rtags-rdm-mode fundamental-mode
    "rdm-log"
    "Mode for viewing rdm logs"
    :syntax-table rtags-rdm-mode-syntax-table
    ;; Syntax highlighting:
    (setq font-lock-defaults '(rtags-rdm-mode-keywords t t)))

  
  ;;; Using the diagnostics buffer

  (defun rtags-show-diagnostics-buffer ()
    "Show/hide the diagnostics buffer in a dedicated
  window (similar to `rtags-diagnostics' but without reparsing)."
    (interactive)
    (if (rtags-has-diagnostics)
        (let* ((buffer-name "*RTags Diagnostics*")
               (buffer (get-buffer buffer-name))
               (window (get-buffer-window buffer)))
          (cond (window
                 (bury-buffer buffer)
                 (delete-window window))
                (buffer
                 (display-buffer buffer-name)
                 (other-window 1)
                 (goto-char (point-min))
                 (fit-window-to-buffer (get-buffer-window (current-buffer)) 10 2)
                 (set-window-dedicated-p (get-buffer-window (current-buffer)) t)
                 (other-window -1))))
      (message "Rtags diagnostics is not running (use C-c r D)")))

  (define-key c-mode-base-map [(control c)(r)(d)] 'rtags-show-diagnostics-buffer)

  ;; Used in powerline:
  (defun rtags-diagnostics-has-errors ()
    "Return t or nil depending if RTags diagnostics displays errors"
    (let ((diag-buff (get-buffer "*RTags Diagnostics*")))
      (if (and diag-buff
               rtags-diagnostics-process
               (not (eq (process-status rtags-diagnostics-process) 'exit))
               (not (eq (process-status rtags-diagnostics-process) 'signal)))
          (> (buffer-size diag-buff) 0)
        nil)))

  
  ;;; RTags auto-complete (EXPERIMENTAL)
  ;;; FIXME: this is broken, need to revisit the whole thing.

  ;;; AC source for #include

  ;;; The following function fixes a bug in achead:documentation-for-candidate
  (defun my-documentation-for-candidate (candidate)
    "Generate documentation for a candidate `candidate'. For now,
  just returns the path and content of the header file which
  `candidate' specifies."
    (let ((path
           (assoc-default candidate achead:ac-latest-results-alist 'string=)))
      (ignore-errors
        (with-temp-buffer
          (insert path)
          (unless (file-directory-p path)
            (insert "\n--------------------------\n")
            (insert-file-contents path nil 0 200)) ;; first 200 content bytes
          (buffer-string)))))

  (ac-define-source my-c-headers
    `((init       . (setq achead:include-cache nil))
      (candidates . achead:ac-candidates)
      (prefix     . ,achead:ac-prefix)
      (document   . my-documentation-for-candidate)
      (requires   . 0)
      (symbol     . "h")
      (action     . ac-start)
      (limit      . nil)))

  ;;; AC source for RTags

  (defun ac-rtags-init ()
    (unless rtags-diagnostics-process
      (rtags-diagnostics)))

  (ac-define-source my-rtags
    '((init       . rtags-ac-init)
      (prefix     . rtags-ac-prefix)
      (candidates . rtags-ac-candidates)
      (action     . rtags-ac-action)
      (document   . rtags-ac-document)
      (requires   . 0)
      (symbol     . "r")))

  ;;; Functions to enable auto-complete

  (defun rtags-auto-complete ()
    "Enables auto-complete with RTags.
  Note that RTags becomes the only source for auto-complete in all
  C and C++ buffers. Also note that RTags Diagostics must be turned
  on."
    (interactive)
    (require 'ac-rtags)
    (setq rtags-completions-enabled t)
    (add-hook 'c++-mode-hook
              (lambda ()
                (setq ac-sources '(ac-source-my-rtags)))))

  (defun rtags-diagnostics-auto-complete ()
    "Starts diagnostics and auto-complete with RTags and #includes.
  Note that this function replaces all other sources of auto-complete
   for C++ files. Any previously opened C++ file needs to be reopen
  for this to be effective."
    (interactive)
    ;; Require
    ;; Start RTags diagnostics
    (unless rtags-diagnostics-process
      (rtags-diagnostics))
    ;; FIXME: this is broken, should not depend on compile_includes
    ;; Create an auto-complete source for headers using compile_includes
    ;; (let ((plist (rtags-load-compile-includes-file (projectile-project-root))))
    ;;   (dolist (dir (plist-get plist :src-dirs))
    ;;     (add-to-list 'achead:include-directories dir))
    ;;   (dolist (dir (plist-get plist :include-dirs))
    ;;     (add-to-list 'achead:include-directories dir)))
    ;; Turn on RTags auto-complete
    (setq rtags-completions-enabled t)
    (add-hook 'c++-mode-hook
              (lambda ()
                (setq ac-sources '(ac-source-my-rtags
                                   ;;ac-source-my-c-headers
                                   )))))

  (define-key c-mode-base-map [(control c)(r)(A)]
    'rtags-diagnostics-auto-complete)

  
  ;; Local Variables:
  ;; byte-compile-warnings: (not cl-functions)
  ;; End:
#+END_SRC
*** init-rtags-cdb
#+BEGIN_SRC emacs-lisp
;;;; Command to create a compilation database.
;;;
;;; ---------- ----------------------------------------------------------------
;;; Key        Command
;;; ---------- ----------------------------------------------------------------
;;;            `rtags-create-compilation-database': see doc below.
;;; ---------- ----------------------------------------------------------------
;;;
;;; This module provides a single command, `rtags-create-compilation-database',
;;; which is an easy way to generate a CLang compilation database
;;; (`compile_commands.json') for non-CMake projects.
;;;
;;; The first step is to create a file `compile_includes' in the project root
;;; dir, which specifies how to compile your project and in particular where
;;; are all the source files and all the include files. For example:
;;;
;;;   # Where are the source files (there could be multiple directories).
;;;   # We will scan recursively any subdirectories that do not match any
;;;   # 'exclude' regex.
;;;   src .
;;;
;;;   # What to put in -I directives (in addition to the source files above).
;;;   # We will scan recursively any subdirectories that do not match any
;;;   # 'exclude' regex.
;;;   include /Users/phil/Code/cpp/include/bsl
;;;   include /Users/phil/Code/cpp/include/bdl
;;;
;;;   # Optional: patterns to exclude in -I directives and for looking for
;;;   # sources:
;;;   exclude /test$
;;;   exclude /doc$
;;;   exclude /group$
;;;   exclude /package$
;;;
;;;   # Optional: if any file name pattern must be excluded from the "src" files,
;;;   # use the "excludesrc" directive. For example this will exclude all test
;;;   # drivers:
;;;   excludesrc \.t\.cpp$
;;;
;;; In addition, the creation of a compilation database uses these variables:
;;;
;;; - `rtags-compile-includes-base-dir': set this to your workspace path
;;;   if you want to use relative paths in `compile_includes' (by default any
;;;   relative path in this file is relative to the project root dir).
;;; - `rtags-clang-command-prefix': default is "/usr/bin/clang++ -Irelative"
;;;   (Note that rtags ignores the clang++ command because it uses libclang).
;;; - `rtags-clang-command-suffix': default is "-c -o".
;;;
;;; Once you have created the `compile_includes' file, run the command
;;; M-x `rtags-create-compilation-database'. It will:
;;;
;;; - Prompt for the project root dir
;;; - Scan all source dirs and include dirs
;;; - Create `compilation_database.json' (it overwrites without asking)
;;; - Ask if you want to reload it (if rdm is running).

(with-no-warnings (require 'cl))

;; Override these variables in your .emacs as needed:

(defvar rtags-clang-command-prefix
  "/usr/bin/clang++ "
  "Compilation command prefix to use for creating compilation
  databases. Override this variable for your local environment.")

(defvar rtags-clang-command-suffix
  " -c -o "
  "Compilation command suffix to use for creating compilation
  databases. Override this variable for you local environment.")

(defvar rtags-compile-includes-base-dir
  nil
  "If non-nil, base directory to use for all relative paths in
  `compile_include'. Use nil for absolute paths.")


;;; Creating a compilation DB

(defun rtags-load-compile-includes-file-content (compile-includes-file)
  "Read and parse the specified compile-includes file, and return
a list of five sublists:
- The list of `src' directives,
- The list of `include' directives,
- The list of `exclude' directives,
- The list of `excludesrc' directives,
- The list of `macro' directives."
  (let ((line-number      1)
        (value            nil)
        (src-list         ())
        (include-list     ())
        (exclude-list     ())
        (exclude-src-list ())
        (macro-list       ()))
    (dolist (record (exordium-read-file-lines compile-includes-file))
      (incf line-number)
      (setq value (second (split-string record " ")))
      (cond ((or (eq "" record)
                 (string-prefix-p "#" record))
             ;; Comment or empty string; skip it
             nil)
            ((string-prefix-p "src" record)
             (when value
               (setq src-list (cons value src-list))))
            ((string-prefix-p "include" record)
             (when value
               (setq include-list (cons value include-list))))
            ((string-prefix-p "excludesrc" record)
             (when value
               (setq exclude-src-list (cons value exclude-src-list))))
            ((string-prefix-p "exclude" record)
             (when value
               (setq exclude-list (cons value exclude-list))))
            ((string-prefix-p "macro" record)
             (when value
               (setq macro-list (cons value macro-list))))
            (t
             (error "Syntax error line %d: %s" line-number record))))
    (list src-list include-list exclude-list exclude-src-list macro-list)))

(defun rtags-is-excluded-p (path excluded-regexs)
  "Return non-nil if the specified path matches any regex in
the list of excluded regexs"
  (catch 'return
    (dolist (excluded excluded-regexs)
      (when (string-match excluded path)
        (throw 'return t)))
    (throw 'return nil)))

(defun rtags-directory-contains-sources-p (path)
  "Return non-nil if the specified path contains any C/C++ source
  or header file"
  (directory-files path nil ".*\\.\\(c\\|cpp\\|h\\|hpp\\)$" nil))

(defun rtags-scan-subdirectories (dir excluded-regexs)
  "Return a list of subdirectories under the specified root dir,
excluding any that match any regex in the specified excluded
regex list."
  (let ((result ()))
    (dolist (subdir (cons dir (exordium-directory-tree dir)))
      (when (and (rtags-directory-contains-sources-p subdir)
                 (not (rtags-is-excluded-p subdir excluded-regexs)))
        (setq result (cons subdir result))))
    result))

(defun rtags-load-compile-includes-file (dir)
  "Loads the `compile_includes' file from the specified directory
and returns its content as a property list, or nil if the file
could not be loaded. The property list looks like this:
'(:src-dirs (...)
  :include-dirs (...)
  :exclude-src (...)
  :macros (...))"
  (let ((compile-includes-file (concat (file-name-as-directory dir)
                                       "compile_includes")))
    (cond ((file-exists-p compile-includes-file)
           ;; Parse the file and return 3 lists: src, include, exclude
           (let ((directives (rtags-load-compile-includes-file-content
                              compile-includes-file)))
             (let ((src-dirs    (first directives))
                   (incl-dirs   (second directives))
                   (excl-regexs (third directives))
                   (excl-src    (fourth directives))
                   (macros      (fifth directives))
                   (result      ()))
               ;; Scan src to get all subdirs that do not match the excludes
               (let (dirs)
                 (dolist (path src-dirs)
                   (unless (file-name-absolute-p path)
                     (setq path (expand-file-name path
                                                  (or rtags-compile-includes-base-dir
                                                      dir))))
                   (message "Scanning source dir: %s ..." path)
                   (setq dirs (nconc dirs (rtags-scan-subdirectories path excl-regexs))))
                 (setq result (list :src-dirs dirs)))
               ;; Same with includes
               (let (dirs)
                 (dolist (path incl-dirs)
                   (setq path (expand-file-name path rtags-compile-includes-base-dir))
                   (message "Scanning include dir: %s ..." path)
                   (setq dirs (nconc dirs (rtags-scan-subdirectories path excl-regexs))))
                 (setq result (nconc result (list :include-dirs dirs))))
               ;; Add exclude-src and macros into the result
               (setq result (nconc result (list :exclude-src excl-src
                                                :macros macros)))
               ;; Done
               (message "Project has %d source dirs and %d include dirs"
                        (length (plist-get result :src-dirs))
                        (length (plist-get result :include-dirs)))
               result)))
          (t
           (message "No compilation_includes file")
           nil))))

(defun rtags-create-compilation-command (plist)
  "Returns a string containing the clang compilation command to
use for the compilation database, using the content of PLIST."
  (let ((command rtags-clang-command-prefix))
    ;; -D options:
    (dolist (m (plist-get plist :macros))
      (setq command (concat command " -D" m)))
    ;; -I options
    (dolist (path (plist-get plist :src-dirs))
      (setq command (concat command " -I" path)))
    (dolist (path (plist-get plist :include-dirs))
      (setq command (concat command " -I" path)))
    (concat command rtags-clang-command-suffix)))

(defun rtags-prompt-compilation-database-dir ()
  "Prompts the user for the directory where to generate the
compilation database. If we're in a projectile project, propose
the project root first, and prompt for a dir if the user
declines. Returns the directory string."
  (let ((project-root (and (featurep 'projectile)
                           (projectile-project-root))))
    (if (and project-root
             (y-or-n-p (format "Create at project root (%s)?" project-root)))
        project-root
      (read-directory-name "Project root: "))))

(defun rtags-create-compilation-database (dir)
  "Regenerates `compile_commands.json' from `compile_includes' in
the specified directory."
  (interactive (list (rtags-prompt-compilation-database-dir)))
  (let ((plist (rtags-load-compile-includes-file dir)))
    (when plist
      (let ((dbfilename (concat (file-name-as-directory dir)
                                "compile_commands.json"))
            (compile-command (rtags-create-compilation-command plist))
            (exclude-files (plist-get plist :exclude-src))
            (num-files 0))
        (with-temp-buffer
          (insert "[")
          (newline)
          ;; Note: dynamic binding of variable default-directory
          (dolist (default-directory (plist-get plist :src-dirs))
            (message "Processing directory: %s ..." default-directory)
            (let ((files (mapcan #'file-expand-wildcards
                                 exordium-rtags-source-file-extensions))
                  ;; rdm does not like directories starting with "~/"
                  (dirname (if (string-prefix-p "~/" default-directory)
                               (substitute-in-file-name
                                (concat "$HOME/" (substring default-directory 2)))
                             default-directory)))
              (dolist (file files)
                (unless (rtags-is-excluded-p file exclude-files)
                  (incf num-files)
                  (insert "  { \"directory\": \"" dirname "\",")
                  (newline)
                  (insert "    \"command\":   \""
                          compile-command
                          (file-name-sans-extension file) ".o "
                          file "\",")
                  (newline)
                  (insert "    \"file\":      \"" file "\" },")
                  (newline)))))
          (insert "];")
          (newline)
          (write-region (buffer-string) nil dbfilename))
        (when (yes-or-no-p
               (format "Wrote compile_commands.json (%d files). Reload it?" num-files))
          ;; FIXME: rtags-call-rc does not work if you don't specify a current buffer?
          ;; That seems broken.
          (rtags-call-rc :path t :output nil :unsaved (current-buffer) "-J" dir)
          (message "Reloaded (check rdm's logs)"))))))


;;; Mode for compile_includes files

(defconst rtags-compile-includes-mode-keywords
  ;; Words and associated face.
  `(( "\\(^src\\|^include\\|^excludesrc\\|^exclude\\|^macro\\)"
     . font-lock-keyword-face)))

(defconst rtags-compile-includes-mode-syntax-table
  ;; Defines a "comment" as anything that starts with hash tag
  (let ((synTable (make-syntax-table)))
    (modify-syntax-entry ?\# "< b" synTable)
    (modify-syntax-entry ?\n "> b" synTable)
    synTable))

(define-derived-mode rtags-compile-includes-mode fundamental-mode
  "compile-includes"
  "Mode for editing compile_includes files"
  :syntax-table rtags-compile-includes-mode-syntax-table
  ;; Syntax highlighting:
  (setq font-lock-defaults '((rtags-compile-includes-mode-keywords))))

(add-to-list 'auto-mode-alist
             '("compile_includes" . rtags-compile-includes-mode))
#+END_SRC
*** init-rtags-helm
#+BEGIN_SRC emacs-lisp
  ;;;; RTags and Helm integration
  ;;;
  ;;; -------------- -------------------------------------------------------
  ;;; Key            Definition
  ;;; -------------- -------------------------------------------------------
  ;;; M-C-g          `rtags-helm-select-taglist' = select a symbol in the
  ;;;                current file using Helm.
  ;;; C-c r r        `helm-flycheck' show rtags errors in helm buffer
  ;;; -------------- -------------------------------------------------------

  (require 'rtags)
  (require 'helm)

  (when (eq exordium-rtags-syntax-checker :flycheck)
    (require 'helm-flycheck)
    (define-key c-mode-base-map
      (kbd "C-c r r")
      (lambda ()
        (interactive)
        (unless flycheck-mode
          (flycheck-mode)
          (diminish 'flycheck-mode))
        (helm-flycheck))))

  (defcustom rtags-helm-show-variables nil
    "Whether `rtags-helm-select-taglist' shows variables and parameters"
    :group 'rtags
    :type 'boolean)

  (defcustom rtags-helm-show-enums nil
    "Whether `rtags-helm-select-taglist' shows enums"
    :group 'rtags
    :type 'boolean)

  (when (or exordium-helm-everywhere exordium-rtags-helm-everywhere)
    (setq rtags-helm-show-variables t)
    (setq rtags-helm-show-enums t)
    (setq rtags-use-helm t))

  (defun rtags-helm-sort-list (pairs)
    (sort pairs #'(lambda (p1 p2) (< (cdr p1) (cdr p2)))))

  (defun rtags-helm-jump-to-line (line)
    ;;Compiler-happy equivalent of (goto-line line):
    (goto-char (point-min))
    (forward-line (1- line))
    (recenter))

  (defun rtags-helm-propertize-function (text)
    "Return a colored string for a method, constructor or function declaration"
    (cond ((string-match "^\\(.*\\) \\(.*\\)::\\(.*\\)$" text)
           (let ((return-type (match-string-no-properties 1 text))
                 (class (match-string-no-properties 2 text))
                 (method (match-string-no-properties 3 text)))
             (format "%s %s::%s"
                     (propertize return-type 'face 'font-lock-type-face)
                     (propertize class 'face 'font-lock-constant-face)
                     (propertize method 'face 'font-lock-function-name-face))))
          ((string-match "^\\(.*\\)::\\(.*\\)$" text)
           (let ((class (match-string-no-properties 1 text))
                 (ctor (match-string-no-properties 2 text)))
             (format "%s::%s"
                     (propertize class 'face 'font-lock-constant-face)
                     (propertize ctor 'face 'font-lock-function-name-face))))
          ((string-match "^\\(.*\\) \\(.*\\)$" text)
           (let ((return-type (match-string-no-properties 1 text))
                 (function (match-string-no-properties 2 text)))
             (format "%s %s"
                     (propertize return-type 'face 'font-lock-type-face)
                     (propertize function 'face 'font-lock-function-name-face))))
          (t text)))

  (defun rtags-helm-propertize-variable (text)
    "Return a colored string for a variable declaration"
    (cond ((string-match "^const \\(.*\\) \\(.*\\)$" text)
           (let ((type (match-string-no-properties 1 text))
                 (var (match-string-no-properties 2 text)))
             (format "%s %s %s"
                     (propertize "const" 'face 'font-lock-keyword-face)
                     (propertize type 'face 'font-lock-type-face)
                     var)))
          ((string-match "^\\(.*\\) \\(.*\\)$" text)
           (let ((type (match-string-no-properties 1 text))
                 (var (match-string-no-properties 2 text)))
             (format "%s %s"
                     (propertize type 'face 'font-lock-type-face)
                     var)))
          (t text)))

  (defun rtags-helm-propertize-macro (text)
    "Return a colored string for a #include or a #define"
    (cond ((string-match "^#include \\(.*\\)$" text)
           (let ((file (match-string-no-properties 1 text)))
             (format "%s %s"
                     (propertize "#include" 'face 'font-lock-preprocessor-face)
                     (propertize (concat "<" file ">") 'face 'font-lock-string-face))))
          (t text)))

  ;;;###autoload
  (defun rtags-helm-select-taglist ()
    "Display the list of symbols of the current file in an Helm
  buffer (classes, functions, variables, enums and other)"
    (interactive)
    (let* ((fn (buffer-file-name))
           functions classes variables enums macros other)
      ;; Fetch taglists. Each list is a list of pairs (text . line-number)
      (with-temp-buffer
        (rtags-call-rc :path fn :path-filter fn "-F" "--cursor-kind" "--display-name" "--no-context")
        ;;(message "%s" (buffer-string))
        (unless (= (point-min) (point-max))
          (while (not (eobp))
            (let ((line (buffer-substring-no-properties (point-at-bol) (point-at-eol))))
              (when (string-match "^\\(.*:\\)\\([0-9]+\\)\\(:[0-9]+:\\)\t\\(.*\\)\t\\(.*\\)$" line)
                  (let ((loc-start (match-string-no-properties 1 line))
                        (linenum (match-string-no-properties 2 line))
                        (loc-end (match-string-no-properties 3 line))
                        (text (match-string-no-properties 4 line))
                        (type (match-string-no-properties 5 line)))
                    (cond ((or (string= type "FunctionDecl")
                               (string= type "CXXMethod")
                               (string= type "CXXConstructor")
                               (string= type "CXXDestructor"))
                           (add-to-list 'functions
                                        (cons (rtags-helm-propertize-function text)
                                              (string-to-number linenum))))
                          ((or (string= type "ClassDecl")
                               (string= type "StructDecl"))
                           (add-to-list 'classes
                                        (cons (propertize text 'face 'font-lock-type-face)
                                              (string-to-number linenum))))
                          ((string= type "FieldDecl")
                           (add-to-list 'variables
                                        (cons (rtags-helm-propertize-variable text)
                                              (string-to-number linenum))))
                          ((and rtags-helm-show-variables
                                (or (string= type "VarDecl")
                                    (string= type "ParmDecl")))
                           (add-to-list 'variables
                                        (cons (rtags-helm-propertize-variable text)
                                              (string-to-number linenum))))
                          ((and rtags-helm-show-enums
                                (or (string= type "EnumDecl")
                                    (string= type "EnumConstantDecl")))
                           (add-to-list 'enums
                                        (cons text (string-to-number linenum))))
                          ((or (string= type "macro definition")
                               (string= type "include directive")
                               (string= type "inclusion directive"))
                           (add-to-list 'macros
                                        (cons (rtags-helm-propertize-macro text)
                                              (string-to-number linenum))))
                          (t
                           (add-to-list 'other
                                        (cons text (string-to-number linenum))))))))
            (forward-line))))
      ;; Display them in Helm
      (helm :sources
            `(((name . "Classes")
               (candidates . ,(rtags-helm-sort-list classes))
               (action . rtags-helm-jump-to-line))
              ((name . "Functions")
               (candidates . ,(rtags-helm-sort-list functions))
               (action . rtags-helm-jump-to-line))
              ((name . ,(if rtags-helm-show-variables "Fields and Variables" "Fields"))
               (candidates . ,(rtags-helm-sort-list variables))
               (action . rtags-helm-jump-to-line))
              ((name . "Enums")
               (candidates . ,(rtags-helm-sort-list enums))
               (action . rtags-helm-jump-to-line))
              ((name . "Macros and Includes")
               (candidates . ,(rtags-helm-sort-list macros))
               (action . rtags-helm-jump-to-line))))))

  (define-key c-mode-base-map [(meta control g)] 'rtags-helm-select-taglist)
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
  ;; (use-package flycheck
  ;;   :disabled
  ;;   :ensure t
  ;;   :init
  ;;   ;;(setq-default flycheck-disabled-checkers '(c/c++-clang))
  ;;   (global-flycheck-mode)
  ;;   :config
  ;;   (setq-default flycheck-c/c++-clang-executable "/usr/local/opt/llvm/bin/clang" )
  ;;   (setq-default flycheck-clang-standard-library "libc++")
  ;;   (setq-default flycheck-clang-language-standard "c++11"))
#+END_SRC
** flyspell
#+BEGIN_SRC emacs-lisp
  ;; dictionary installed via:
  ;; brew install aspell
  (use-package flyspell
    :init
    (unbind-key "C-." flyspell-mode-map)
    (unbind-key "C-," flyspell-mode-map)
    (unbind-key "C-M-i" flyspell-mode-map)
    (setq ispell-program-name "/usr/local/bin/aspell")
    (add-hook 'prog-mode-hook 'flyspell-prog-mode))
#+END_SRC
** git-timemachine
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t )
#+END_SRC
** iedit
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t
    :bind (("C-;" . iedit-mode))
    :config
    )
#+END_SRC
** expand-region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind (("C-=" . er/expand-region)
           ("C-M-=" . er/contract-region)))
#+END_SRC
** git-gutter-fringe+
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter-fringe+
    :ensure    t
    :init
    (global-git-gutter+-mode t))
#+END_SRC
** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :bind (("C-S-b"   . helm-mini)
           ("M-x"     . helm-M-x)             ;; meta-X is handled by Helm
           ("<f1>"    . helm-imenu)          ;; Map F1 to helm-imenu
           ("M-i"     . helm-occur)
           ("M-y"     . helm-show-kill-ring)
           ("C-x C-f" . helm-find-files))
    :init
    (setq helm-split-window-default-side 'same ; display helm in the same window
          helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
          helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
          helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
          helm-ff-file-name-history-use-recentf t
          helm-mode-reverse-history           nil ; place helm command history on top
          helm-ff-transformer-show-only-basename t; only show basename when helm-find-file, to show full path "C-]"

          ;; need to investigate what these do
          ;; just copied them from: https://github.com/yveszoundi/emacs.d/blob/master/bootstrap/startup.org
          ;;helm-adaptive-history-file             ers-helm-adaptive-history-file
          ;;helm-boring-file-regexp-list           '("\\.git$" "\\.svn$" "\\.elc$" "*~$")

          helm-buffer-max-length                 45
          helm-recentf-fuzzy-match               t
          helm-yank-symbol-first                 t
          helm-buffers-fuzzy-matching            t
          helm-ff-auto-update-initial-value      t
          helm-input-idle-delay                  0.1
          helm-idle-delay                        0.1
          )

    (use-package helm-ag
      :ensure    t
      :ensure    helm-projectile
      :bind      )

    (use-package helm-grep
      :defer t
      :bind
      :config
      ;; color file names in helm grep mode using a sensible color
      (set-face-attribute 'helm-grep-file nil
                          :foreground "azure")
      ;; the original value is "grep --color=always -a -d skip %e -n%cH -e %p %f"
      ;; the --color option would override helm-grep-match face and force the "red"
      ;; to be displayed, which does not play well with my color scheme
      ;; hence remove the --color from the command and override the helm-grep-match
      ;; with the color I like better
      (setq helm-grep-default-command "grep -a -d skip %e -n%cH -e %p %f")
      (set-face-attribute 'helm-grep-match nil
                          :background "black"
                          :foreground "yellow")
      )

    :config
    ;; somehow ":diminish helm-mode does not work
    (diminish 'helm-mode)
    ;; make helm selection yellow on black
    (set-face-attribute 'helm-visible-mark nil
                        :background "black"
                        :foreground "yellow")
    ;; make current line in helm pleasant to look at
    (set-face-attribute 'helm-selection nil
                        :background "DarkCyan"
                        :foreground "white")
    )
#+END_SRC
** helm-projectile
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :ensure    t
    :bind      ("M-o" . helm-projectile)
    :after     (projectile))
#+END_SRC
** helm-rtags
#+BEGIN_SRC emacs-lisp
  (use-package helm-rtags
      :ensure    t )
#+END_SRC
** irony
#+BEGIN_SRC emacs-lisp
  (defun my-irony-mode-hook ()
    (define-key irony-mode-map [remap completion-at-point]
      'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol]
      'irony-completion-at-point-async))

  (use-package irony
    :ensure t
    :init
    (add-hook 'irony-mode-hook 'my-irony-mode-hook)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC
** ivy
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish ivy-mode
    :ensure t
    ;:diminish ivy-mode
    :config
    (ivy-mode 1))
#+END_SRC
** json-mode
#+BEGIN_SRC emacs-lisp
(use-package json-mode
    :ensure t)
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind (("C-x g" . magit-status)
           ("C-x m l" . magit-log-all)
           )
    :config
    ;; update magit heading line to yellow on black, the way I like it...
    (set-face-attribute 'magit-diff-hunk-heading-highlight nil :background "black" :foreground "yellow")
    ;; make changes look nice
    (set-face-attribute 'magit-diff-removed-highlight nil :background "black" :foreground "red")
    (set-face-attribute 'magit-diff-added-highlight nil :background "black" :foregroundq "SeaGreen3")
    (set-face-attribute 'magit-diff-removed nil :background "DarkRed")
    (set-face-attribute 'magit-diff-hunk-heading nil :background "black" :foreground "turquoise1" ))
#+END_SRC
** man
#+BEGIN_SRC emacs-lisp
  (use-package man
    :bind ( :map Man-mode-map
                 ("<return>" . sd/man-follow)))
#+END_SRC
** modern-cpp-font-lock
#+BEGIN_SRC emacs-lisp
  (use-package modern-cpp-font-lock
    :diminish ‘modern-c++-font-lock-mode
    :ensure t)
  (modern-c++-font-lock-global-mode t)
#+END_SRC
** move-text
#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :ensure t
    ;; Text movement
    :bind (("C-S-<up>" . move-text-up )
           ("C-S-<down>" . move-text-down ))
    :config
    )
#+END_SRC

** multiple-cursors
#+BEGIN_SRC emacs-lisp
  (defvar multiple-cursors-mode-enabled-hook nil
    "Hook that is run after `multiple-cursors-mode' is enabled.")

  (defvar multiple-cursors-mode-disabled-hook nil
    "Hook that is run after `multiple-cursors-mode' is disabled.")

  (defun sd/mc-when-enabled ()
    "Function to be added to `multiple-cursors-mode-enabled-hook'."
    (setq-default cursor-type '(box . 7)))

  (defun sd/mc-when-disabled ()
    "Function to be added to `multiple-cursors-mode-disabled-hook'."
    (setq-default cursor-type '(bar . 1)))

  (use-package multiple-cursors
    :ensure t
    :demand t
    :bind (("C--" . mc/mark-next-like-this  )
           :map mc/keymap
           ("<return>" . nil))
    :init
    (add-hook 'multiple-cursors-mode-enabled-hook #'sd/mc-when-enabled)
    (add-hook 'multiple-cursors-mode-disabled-hook #'sd/mc-when-disabled)
    ;; add mc cursors on Meta-left mouse click
    (global-unset-key (kbd "M-<down-mouse-1>"))
    (global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click)
    :config
    (set-face-foreground 'mc/cursor-face "red"))

#+END_SRC
** nxml
#+BEGIN_SRC emacs-lisp
  (use-package nxml-mode
      :config
      (unbind-key "C-c C-u" nxml-mode-map)
      (unbind-key "M-h" nxml-mode-map))
#+END_SRC
** org
#+BEGIN_SRC emacs-lisp
  (use-package org
    :diminish org-mode
    :ensure t
    :init
    (unbind-key "M-h" org-mode-map)
    ;; indent propertly in org babel mode
    (setq org-src-tab-acts-natively t)
    ;; support shift-selection-mode
    (setq org-support-shift-select t))
#+END_SRC

** projectile
#+BEGIN_SRC  emacs-lisp
  (use-package projectile
    :ensure t
    :demand t
    :init
    (setq projectile-completion-system 'helm)
    ;; solves a performance issue
    ;; without this, every cursor movement is incredibly slow
    (setq projectile-mode-line
          '(:eval (if (projectile-project-p)
                      (format " Proj[%s]"
                              (projectile-project-name))
                    "")))
    :config
    ;; ignore files
    (add-to-list 'grep-find-ignored-files "*.d")
    (add-to-list 'grep-find-ignored-files "*.dd")
    (add-to-list 'grep-find-ignored-files "*.mapfile")
    (add-to-list 'grep-find-ignored-files "*.tsk")
    (add-to-list 'grep-find-ignored-files "*.depends")
    ;; ignore directories
    (add-to-list 'projectile-globally-ignored-directories "llcalc*")
    (add-to-list 'projectile-globally-ignored-directories "SunWS_cache*")
    (add-to-list 'projectile-globally-ignored-directories ".svn")
    ;; ignore specific file suffixes from projectile
    (setq projectile-globally-ignored-file-suffixes '(".svn-base"))

    (projectile-global-mode t))
#+END_SRC
** python
#+BEGIN_SRC emacs-lisp
  (use-package python
    :bind( :map python-mode-map
                ("C-c C-c" . sd/comment-line-or-region)
                ("C-c C-v" . sd/duplicate-line-or-region)))

#+END_SRC
** rectangle-mark-mode
#+BEGIN_SRC emacs-lisp
    (use-package rect
      :bind(("C-M-<down>" . rectangle-mark-mode)
            :map rectangle-mark-mode-map
            ("C-w" . kill-rectangle)))
#+END_SRC
** rtags
#+BEGIN_SRC emacs-lisp
  (use-package rtags
    :ensure t
    :bind (("C-." . rtags-find-symbol-at-point)
           ("C-," . rtags-location-stack-back)
           ("C-x r" . rtags-find-references-at-point)
           ("C-<f1>" . rtags-imenu))
    :config
    (setq rtags-display-result-backend 'helm))
#+END_SRC
** shackle
#+BEGIN_SRC emacs-lisp
  ;; make sure pop up buffers such as helm, help, etc pop up below, always in the same place
  (use-package shackle
    :ensure t
    :init
    (setq helm-display-function 'pop-to-buffer)
    (setq shackle-rules '(("\\`\\*helm.*?\\*\\'" :regexp t :align t :ratio 0.5)
                          ("\\`\\*Help.*?\\*\\'" :regexp t :align t :ratio 0.5)
                          ("*RTags*" :select t :align t :ratio 0.5)))
    :config
    (shackle-mode))
#+END_SRC
** shell
#+BEGIN_SRC emacs-lisp
  (use-package shell-mode
    :bind(:map shell-mode-map
               ("C-p" . comint-previous-input)
               ("C-n" . comint-next-input))
    :config
    (add-hook 'shell-mode-hook (lambda() (set-process-query-on-exit-flag (get-process "shell") nil)) ))
#+END_SRC
** shell-pop
#+BEGIN_SRC emacs-lisp
  (use-package shell-pop
    :ensure t
    :bind (("C-S-m" . shell-pop))
    :config
     ;; Don't ask to kill the shell buffer
     (add-hook 'shell-mode-hook (lambda() (set-process-query-on-exit-flag (get-process "shell") nil)) )
     (setq shell-pop-shell-type
      (quote ("eshell" "*eshell*" (lambda nil (eshell shell-pop-term-shell)))))
     (setq shell-pop-term-shell "/bin/bash")
     (setq shell-pop-window-height 60)
     (setq shell-pop-full-span t)
     (setq shell-pop-window-position "bottom"))

#+END_SRC
** spaceline
#+BEGIN_SRC emacs-lisp
  (use-package spaceline :ensure t
    :config
    (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main)))))

  (use-package spaceline-config :ensure spaceline
    :config
    (spaceline-helm-mode 1)

    (spaceline-define-segment my/buffer-status
      "Buffer status (read-only, modified), with color"
      (cond (buffer-read-only (propertize "RO" 'face 'my/spaceline-read-only))
            ((buffer-modified-p) (propertize "MODIFIED" 'face 'my/spaceline-modified))
            (t "  ")))

    (spaceline-define-segment amitp/buffer-id
      "Name of filename relative to project, or buffer id"
      (propertize
       (amitp/spaceline-buffer-id)
       'face 'amitp/spaceline-filename))

    ;; When there are segments that may or may not appear, they will
    ;; affect the alternating background colors. I try to put the
    ;; indicators that appear/disappear the most towards the center.
    (spaceline-install
      'main
      '((my/buffer-status :tight-left t)
        (amitp/buffer-id :tight-left t :face highlight-face)
        (which-function :tight-left t)
        (("L" line column) :separator ":" :when active)
        (selection-info :face region :when mark-active))
      '(((flycheck-error flycheck-warning flycheck-info) :when active)
        (version-control :when active)
        (global :face highlight-face)
        (major-mode))))

  (defun amitp/spaceline-buffer-id ()
    (cond (buffer-file-name
           (file-name-nondirectory buffer-file-name))
          (t (s-trim (powerline-buffer-id 'mode-line-buffer-id)))))

  (defun hsl (H S L) ; convenience fn
    (apply 'color-rgb-to-hex (color-hsl-to-rgb (/ H 360.0) S L)))
  (defun face (face &rest spec) ; convenience fn
    (face-spec-set face (list (cons t spec))))
  (setq powerline-text-scale-factor 0.8)

  (face 'mode-line :family "M+ 1m" :height 1.0 :background "gray20" :foreground "gray80" :box nil)
  (face 'mode-line-inactive :inherit 'mode-line :background "gray55" :foreground "gray80" :box nil)
  (face 'mode-line-highlight :inherit 'mode-line :background "GoldenRod2" :foreground "white"
        :box '(:line-width -2 :color "GoldenRod2" :style released-button))

  (face 'powerline-active1   :inherit 'mode-line          :height powerline-text-scale-factor :background "gray30")
  (face 'powerline-inactive1 :inherit 'mode-line-inactive :height powerline-text-scale-factor)
  (face 'powerline-active2   :inherit 'mode-line          :height powerline-text-scale-factor :background "gray40")
  (face 'powerline-inactive2 :inherit 'mode-line-inactive :height powerline-text-scale-factor)

  (face 'spaceline-highlight :inherit 'mode-line :foreground "white" :background "gray80" :height powerline-text-scale-factor)

  (face 'my/spaceline-read-only :background (hsl 300 0.15 0.5) :foreground "gray80" :box `(:line-width -2 :color ,(hsl 300 0.4 0.5)))
  (face 'my/spaceline-modified :background "Red" :foreground "Black" :weight 'extra-bold)
  (face 'my/spaceline-unicode-character :inherit 'mode-line :foreground "black" :background (hsl 50 1.0 0.5))
  (face 'amitp/spaceline-filename :family "Helvetica Neue" :foreground nil :background nil :weight 'normal :height (/ 1.0 powerline-text-scale-factor))
#+END_SRC
** swap-buffers
#+BEGIN_SRC emacs-lisp
  (use-package swap-buffers
    :ensure t
    :bind("C-<f12>" . swap-buffers)
    :init
    (setq swap-buffers-keep-focus t)
    :config
    ;;(advice-add 'swap-buffers :after 'sd/update-header)
    )
#+END_SRC
** transpose-frame
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :ensure t
    :bind("<f12>" . flop-frame)
    :config
    ;;(advice-add 'flop-frame :after 'sd/update-header)
    )
#+END_SRC
** try
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC
** vlf
#+BEGIN_SRC emacs-lisp
  (use-package vlf
    :ensure t
    :init)
    ;; (global-set-key (kbd "C-x o") 'ace-window)
    ;; :diminish ace-window-mode)
#+END_SRC
** which-function
#+BEGIN_SRC emacs-lisp
  (use-package which-func
    :config
    (set-face-attribute 'which-func nil :background "Black" :foreground "Orange" :height 1.5))
#+END_SRC
** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :ensure t
    :config
    (which-key-mode))
#+END_SRC
** whitespace
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :init
    (dolist (hook '(prog-mode-hook))
      (add-hook hook #'whitespace-mode))
    (add-hook 'before-save-hook #'whitespace-cleanup)
    :config
    (setq whitespace-style '(face trailing)))
#+END_SRC
** whole-line-or-region
#+BEGIN_SRC emacs-lisp
  (defun sd/whole-line-or-region-kill-ring-save()
    "When in rectangle mode, copy the rectangle"
    (interactive)
    (if rectangle-mark-mode
        (progn
          (message "Copying rectangle.")
          (copy-rectangle-as-kill (region-beginning) (region-end)))
      (progn
        (message "Copying region.")
        (whole-line-or-region-kill-ring-save nil))))

    (use-package whole-line-or-region
      :ensure t
      :bind (("C-w" . whole-line-or-region-kill-region)
             ;; ("C-c c" . whole-line-or-region-kill-ring-save)
             ("C-c c" . sd/whole-line-or-region-kill-ring-save)
             )
      :config)
#+END_SRC
** wrap-region
#+BEGIN_SRC emacs-lisp
  (use-package wrap-region
    :diminish wrap-region-mode
    :ensure   t
    :config
    (wrap-region-global-mode t)
    (wrap-region-add-wrappers
     '(("(" ")")
       ("[" "]")
       ("{" "}")
       ("<" ">")
       ("'" "'")
       ("\"" "\"")
       ("‘" "’"   "q")
       ("“" "”"   "Q")
       ("*" "*"   "b"   org-mode)                 ; bolden
       ("*" "*"   "*"   org-mode)                 ; bolden
       ("/" "/"   "i"   org-mode)                 ; italics
       ("/" "/"   "/"   org-mode)                 ; italics
       ("~" "~"   "c"   org-mode)                 ; code
       ("~" "~"   "~"   org-mode)                 ; code
       ("=" "="   "v"   org-mode)                 ; verbatim
       ("=" "="   "="   org-mode)                 ; verbatim
       ("_" "_"   "u" '(org-mode markdown-mode))  ; underline
       ("**" "**" "b"   markdown-mode)            ; bolden
       ("*" "*"   "i"   markdown-mode)            ; italics
       ("`" "`"   "c" '(markdown-mode ruby-mode)) ; code
       ("`" "'"   "c"   lisp-mode)                ; code
       )))
#+END_SRC
** undo-tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :init
    (global-undo-tree-mode)
    (unbind-key "C-x r u" undo-tree-map)
    (unbind-key "C-x r U" undo-tree-map)
    (unbind-key "C-x r" undo-tree-map))
#+END_SRC
** yasnippet
#+BEGIN_SRC emacs-lisp
        ;;;###autoload
  (defun sd/yas-no-expand-in-comment/string ()
    "Don't expand snippet while in comment."
    (setq yas-buffer-local-condition
          '(if (nth 8 (syntax-ppss)) ;; non-nil if in a string or comment
               '(require-snippet-condition . force-in-comment)
             t)))

  (add-hook 'prog-mode-hook 'sd/yas-no-expand-in-comment/string)
  (use-package yasnippet
    :diminish yas-minor-mode
    :ensure t
    :init
    (yas-global-mode 1)
    :config
    (define-key yas-minor-mode-map (kbd "<tab>") nil)
    (define-key yas-minor-mode-map (kbd "TAB") nil)
    (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)

    ;;keys for navigation
    ;; (define-key yas-keymap [(tab)]       nil)
    ;; (define-key yas-keymap (kbd "TAB")   nil)
    ;; (define-key yas-keymap [(shift tab)] nil)
    ;; (define-key yas-keymap [backtab]     nil)

    ;; (define-key yas-keymap (kbd "<new-next-field-key>") 'yas-next-field-or-maybe-expand)
    ;; (define-key yas-keymap (kbd "<new-prev-field-key>") 'yas-prev)
    )
#+END_SRC
** zoom-window
#+BEGIN_SRC emacs-lisp
  (use-package zoom-window
    :ensure t
    :bind (("C-M-z" . zoom-window-zoom)
	   )
    :init
    (setq zoom-window-mode-line-color "SteelBlue")
    :config
    )
#+END_SRC
** Modes to explore in the future
# 'ensime
# 'paredit
# 'rtags-ac
# web-mode
* TODO
** try to use bear or output of make to index files via rtags
** Add snippets
*** for include
*** for return true & false
** shortcut/macro for going to the includes section and being able to come back by popping the stack with ctrl-,
** random snippets
(use-package projectile
  :diminish "Pj"
  :init
  (progn
    (projectile-global-mode)
    (setq projectile-indexing-method 'alien
          projectile-sort-order 'recentf
          projectile-cache-file "~/.emacs.d/cache/projectile.cache"
          projectile-known-projects-file "~/.emacs.d/cache/projectile-bookmarks.eld"
          projectile-enable-caching t)
    (add-to-list 'projectile-globally-ignored-directories "elpa")
    (add-to-list 'projectile-globally-ignored-directories ".cask")
    (add-to-list 'projectile-globally-ignored-directories ".cache")))
** invistigate origami mode
** undo-tree mode
** smartparens mode
** exec-path-from-shell mode
** hydra
** swiper
** rtags-helm/helm-rtags
http://syamajala.github.io/c-ide.html
(require 'rtags)
(require 'company-rtags)
(setq rtags-completions-enabled t)

(eval-after-load 'company
  '(add-to-list
    'company-backends 'company-rtags))
(setq rtags-autostart-diagnostics t)

(require 'rtags-helm)
(setq rtags-use-helm t)
** pcre2el
** ediff horizontally
(setq ediff-split-window-function 'split-window-horizontally)
