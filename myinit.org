#+STARTUP: overview

* Prerequisites
brew install findutils
brew install coreutils
brew install/reinstall ccls
echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf
* Global settings
#+BEGIN_SRC emacs-lisp
  ;; native comp
  (setq comp-speed 2)

  ;; set the default font
  (when (member "DejaVu Sans Mono" (font-family-list))
    (set-face-attribute 'default nil :font "DejaVu Sans Mono"))

  (if (file-readable-p "/usr/local/share/emacs/site-lisp/doxymacs")
      (progn
        ;; load doxymacs installed via: brew install doxymacs
        (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/doxymacs/")
        ;; load doxymacs
        (require 'doxymacs)))

  ;; Store custom-file separately, don’t freak out when it’s not found.
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file 'noerror)

  ;; prefer newer source to old bytecode
  (setq load-prefer-newer t)

  ;; when deleting in dired, move to trash
  (setq delete-by-moving-to-trash t)

  ;; this is needed for delete-by-moving-to-trash setting
  ;; to take effect under OSX
  (defun system-move-file-to-trash (file)
    "Use \"trash\" to move FILE to the system trash.
        When using Homebrew, install it using \"brew install trash\"."
    (call-process (executable-find "trash")
                  nil 0 nil
                  file))

  ;; set gc threshold high to limit number of invocations
;;  (setq gc-cons-threshold 100000000)

  ;; enable recursive minibuffer
  (setq enable-recursive-minibuffers t)

  ;; scroll faster
  (setq fast-but-imprecise-scrolling t)

  ;; fontify code in code blocks for org mode
  ;; somehow this does not work if I place this line
  ;; in the mode codfiguration section
  (setq org-src-fontify-natively t)

  ;; prevent accidental exits
  (global-unset-key (kbd "C-x C-c"))

  ;; Paste the way I am used to
  (global-unset-key (kbd "C-v"))
  (global-set-key (kbd "C-v") 'yank)

  (global-unset-key (kbd "C-M-y"))
  (global-set-key (kbd "C-M-y") 'yank-rectangle)

  ;; Paste the way I am used to
  (global-unset-key (kbd "C-M-j"))
  (global-set-key (kbd "C-M-j") 'sd/smart-join-line)

  ;; Copy region to register 1
  (global-unset-key (kbd "M-c"))
  (global-set-key (kbd "M-c") 'sd/copy-word-under-cursor)

;;  ;; Paste from register 1
;;  (global-unset-key (kbd "M-v"))
;;  (global-set-key (kbd "M-v") 'xah-paste-from-register-1)

  ;; Copy buffer name to clipboard
  (global-unset-key (kbd "C-M-c"))
  (global-set-key (kbd "C-M-c") 'sd/copy-buffer-name-to-clipboard)

  ;; Copy path of the current buffer
  (global-unset-key (kbd "C-M-x"))
  (global-set-key (kbd "C-M-x") 'sd/copy-full-path-of-current-buffer)

  ;; Map F6 to describe-key
  (global-unset-key (kbd "<f6>"))
  (global-set-key (kbd "<f6>") 'describe-key)

  ;; Map F6 to scroll-lock-mode
  (global-unset-key (kbd "<f8>"))
  (global-set-key (kbd "<f8>") 'scroll-lock-mode)

  ;; display the fully qualified path in the frame title
  (setq frame-title-format
        '((:eval (if (buffer-file-name)
                     (buffer-file-name))
                 "%b")))

  ;; display full screen
  (global-unset-key (kbd "C-M-+"))
  (global-set-key (kbd "C-M-+") 'toggle-frame-maximized)

  ;; Show corresponding paren
  (show-paren-mode 1)

  ;; keyboard scroll one line at a time
  (setq scroll-step 1)
  ;; don't jump around when scrolling
  (setq scroll-conservatively 101)

  ;; suppress splash screen
  (setq inhibit-startup-message t)

  ;; disable scrollbar, menu bar and tool bar
  (scroll-bar-mode -1)
  (menu-bar-mode t)
  (tool-bar-mode -1)

  ;; turn off blinking cursor
  (blink-cursor-mode -1)

  ;; turn off the annoying beep
  (setq visible-bell nil)

  ;; turn off line wrapping
  (set-default 'truncate-lines t)

  ;; y/n instead of yes/no
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; enable saveplace mode
  (save-place-mode 1)

  ;; Kill current buffer
  (global-unset-key (kbd "C-<end>"))
  (global-set-key (kbd "C-<end>") 'kill-this-buffer)

  ;; Enable deleting of selected text by subsequent input
  (delete-selection-mode 1)

  ;; Match parens
  (global-unset-key (kbd "C-]"))
  (global-set-key (kbd "C-]") 'sd/forward-or-backward-sexp)

  ;; Duplicate line
  (global-unset-key (kbd "C-c C-v"))
  (global-set-key (kbd "C-c C-v") 'sd/duplicate-line-or-region)

  ;; Split current line
  (global-unset-key (kbd "C-M-o"))
  (global-set-key (kbd "C-M-o") 'sd/split-current-line)

  ;; Backup file configuration
  ;; back
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))

  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default nil             ; stop creating #autosave# files
        create-lockfiles nil              ; stop creating #lock files
        )

  (when window-system
    (add-to-list 'default-frame-alist '(width . 132))
    (add-to-list 'default-frame-alist '(height . 32))
    (add-to-list 'default-frame-alist '(ns-appearance . dark))
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t)))

  ;; toggle h-cpp
  (global-unset-key (kbd "C-<return>"))
  (global-set-key (kbd "C-<return>") 'sd/ff-find-other-file)

  ;; toggle test to implementation and vice versa
  (global-unset-key (kbd "C-t"))
  (global-set-key (kbd "C-t") 'sd/toggle-implementation-test-cpp)

  ;; the following buffers should open in the same emacs window
  (add-to-list 'same-window-buffer-names "*Help*")
  (add-to-list 'same-window-buffer-names "*Backtrace*")
  (add-to-list 'same-window-buffer-names "*shell*")

  ;; mark the entire buffer
  (global-set-key (kbd "M-a") 'mark-whole-buffer)

  ;; indent with spaces
  (setq-default indent-tabs-mode nil)

  ;; unset Meta-x m, so that it can be reused for other purposes
  (global-unset-key (kbd "C-x m"))

  ;; copy text selected via a mouse to system's clipboard
  (setq mouse-drag-copy-region t)

  ;; open org initialization file
  (global-set-key (kbd "C-<f9>") 'sd/open-org-init)

  ;; use ff-find-related-file as a poor substitute for rtags index db, but that
  ;; is needed right now
  (global-unset-key (kbd "C-M-."))
  (global-set-key (kbd "C-M-.") 'ff-find-related-file)

  ;; setting to 2, original value is t,
  ;; performance enhancement, seems to help a little when commenting out large chunks of c++ code
  (setq font-lock-maximum-decoration t)

  ;; native line number implementation
  (global-display-line-numbers-mode)

  ;; search the entire project
  (global-unset-key (kbd "C-M-i"))
  ;; counsel-project-ag does not seem to work anymore, switching to native counsel command
  ;; (global-set-key (kbd "C-M-i") 'counsel-projectile-ag)
  (global-set-key (kbd "C-M-i") 'counsel-git-grep)

  ;; activate which-function mode
  (which-function-mode 1)

  ;; enable flyspell programming mode
  ;; (flyspell-prog-mode)

  ;; start scrolling when within 3 lines of either top or bottom of the window
  (setq scroll-margin 3)

  ;; conveniently map repeat to F7
  (global-unset-key (kbd "<f7>"))
  (global-set-key (kbd "<f7>") 'repeat)

  ;; man pages
  (global-unset-key (kbd "C-c m"))
  (global-set-key (kbd "C-c m") 'helm-man-woman)
  ;; display man page in the current buffer
  (setq Man-notify-method 'pushy)

  ;; always select help window
  (setq help-window-select t)

  ;; bookmarks
  (global-unset-key (kbd "C-M-b"))
  (global-set-key (kbd "C-M-b") 'counsel-bookmark)

  ;; recenter after imenu jump
  (add-hook 'imenu-after-jump-hook #'recenter-top-bottom)

  ;; helps to prevent weirdly split windows in golden-ratio mode
  (setq split-width-threshold nil)

  ;; leave one space around the point
  (global-unset-key (kbd "C-M-d"))
  (global-set-key (kbd "C-M-d") 'just-one-space)

  ;; move to first non-blank character of the line
  (global-unset-key (kbd "C-b"))
  (global-set-key (kbd "C-b") 'back-to-indentation)

  ;; mark to the end of line
  (global-unset-key (kbd "M-="))
  (global-set-key (kbd "M-=") 'sd/mark-from-point-to-end-of-line)

  ;; mark whole lines
;  (global-unset-key (kbd "M-="))
;  (global-set-key (kbd "M-=") 'sd/mark-line)

  ;; go to beginning of the next defun
  (global-unset-key (kbd "M-p"))
  (global-set-key (kbd "M-p") 'sd/begin-of-prev-defun)

  ;; go to beginning of the prev defun
  (global-unset-key (kbd "M-n"))
  (global-set-key (kbd "M-n") 'sd/beginning-of-next-defun)

  ;; map goto line to shit-space
  (global-unset-key (kbd "S-SPC"))
  (global-set-key (kbd "S-SPC") 'goto-line)

  ;; choose a snippet
  (global-unset-key (kbd "s-m"))
  (global-set-key (kbd "s-m") 'yas-insert-snippet)

  ;; copy text to register
  (global-unset-key (kbd "C-c r"))
  (global-set-key (kbd "C-c r") 'copy-to-register)

  ;; scroll text down
  (global-unset-key (kbd "s-j"))
  (global-set-key (kbd "s-j") 'scroll-up-command)

  ;; scroll text up
  (global-unset-key (kbd "s-k"))
  (global-set-key (kbd "s-k") 'scroll-down-command)

  ;; previous-buffer
  (global-unset-key (kbd "<end>"))
  (global-set-key (kbd "<end>") 'previous-buffer)

  ;; next-buffer
  (global-unset-key (kbd "<home>"))
  (global-set-key (kbd "<home>") 'next-buffer)

  (global-unset-key [f5])
  (global-set-key [f5] 'sd/vc-refresh-state-all)

  (global-unset-key (kbd "C-x K"))
  (global-set-key (kbd "C-x K") 'tab-bar-close-tab)

  ;; remove C-j/C-j from all prog modes
  (add-hook 'prog-mode-hook
            (function (lambda ()
                        (local-unset-key '[s-j])
                        (local-unset-key '[s-k])
                      )))

  ;; stop emacs from making any sounds
  (setq ring-bell-function 'ignore)

  ;; disable electric indent mode globally
  (electric-indent-mode -1)

  ;; setup minibuffer to my liking
  (add-hook 'minibuffer-setup-hook 'sd/minibuffer-setup)

  ;; on emacs exit don't ask whether ok to kill processes
  (setq confirm-kill-processes nil)

  ;; confirm before killing emacs
  (setq confirm-kill-emacs 'yes-or-no-p)

  ;; don't ask to kill a buffer with a running processes
  (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

* Custom functions
#+BEGIN_SRC emacs-lisp
  (defun sd/toggle-implementation-test-cpp()
    "Toggle between C++ implementation and test buffers."
    "Relies on the test files to follow \"t.cpp\" convention"
    (interactive)
    (let ((current-file-name-sans-ext (file-name-base buffer-file-name))
          (dominating-file (locate-dominating-file "." ".git")))
      (if (string-suffix-p ".t" current-file-name-sans-ext)
          ;; toggle from test to implementation
          (when dominating-file
            (let ((found-files (directory-files-recursively dominating-file
                                                            (concat (file-name-base current-file-name-sans-ext) ".cpp$") )))
              ;; file found, switch
              (if found-files
                  (find-file (car found-files))
                ;; .cpp file not found, fall back to looking for .h, as the implementation can be templatized
                (progn
                  (setq found-files (directory-files-recursively dominating-file
                                                                 (concat (file-name-base current-file-name-sans-ext) ".h$") ))
                  (if found-files
                      (find-file (car found-files))))))))
      ;; toggle from implementation to test
      (when dominating-file
        (let ((found-files (directory-files-recursively dominating-file
                                                        (concat current-file-name-sans-ext ".t.cpp$") )))
          (if found-files
              (find-file (car found-files)))))))

  (defun sd/find-last-include()
    "Find the last include in the current buffer"
    (interactive)
    (xref-push-marker-stack)
    (setq matched-position (search-backward "#include" nil t))
    (if matched-position
        (progn
          (next-line)
          (recenter-top-bottom))
      (message "Did not find a #include")))

  (defun sd/pop-marker-stack()
    "Pop marker stack and re-center"
    (interactive)
    (xref-pop-marker-stack)
    (recenter-top-bottom))

                              ;;;###autoload
  (defun sd/forward-or-backward-sexp (&optional arg)
    "Go to the matching parenthesis character if one is adjacent to point."
    (interactive "^p")
    (cond ((looking-at "\\s(") (forward-sexp arg))
          ((looking-back "\\s)" 1) (backward-sexp arg))
          ;; Now, try to succeed from inside of a bracket
          ((looking-at "\\s)") (forward-char) (backward-sexp arg))
          ((looking-back "\\s(" 1) (backward-char) (forward-sexp arg))))

                              ;;;###autoload
  (defun sd/duplicate-line-or-region(arg)
    "Duplicates the current line or region ARG times.
                              If there's no region, the current line will be duplicated. However, if
                              there's a region, all lines that region covers will be duplicated."
    (interactive "p")
    (let (beg end (origin (point)))
      (if (and mark-active (> (point) (mark)))
          (exchange-point-and-mark))
      (setq beg (line-beginning-position))
      (if mark-active
          (exchange-point-and-mark))
      (setq end (line-end-position))
      (let ((region (buffer-substring-no-properties beg end)))
        (dotimes (i arg)
          (goto-char end)
          (newline)
          (insert region)
          (setq end (point)))
        (goto-char (+ origin (* (length region) arg) arg)))))

  (defvar sd/copy-word-under-cursor-regex "[^[:word:]_]"
    "Regular expression to use when copying with `copy-word-under-cursor'.
                              Can be customized for each major mode.")

                              ;;;###autoload
  (defun sd/copy-word-under-cursor ()
    "Copy the word under the cursor to the kill ring."
    (interactive)
    (save-excursion
      (save-excursion (re-search-backward sd/copy-word-under-cursor-regex))
      (let ((beg (+ (match-beginning 0) 1))
            (end (re-search-forward sd/copy-word-under-cursor-regex)))
        (copy-region-as-kill beg (- end 1))
        (message "Copied %s" (car kill-ring)))))

                              ;;;###autoload
  (defun sd/update-header()
    (interactive)
    (mapc
     (lambda (window)
       (with-current-buffer (window-buffer window)
         ;; don't mess with buffers that don't have a header line
         (when header-line-format
           (let ((original-format (get 'header-line-format 'original))
                 (inactive-face 'mode-line-inactive)
                 (active-face 'mode-line)
                 ) ; change this to your favorite inactive header line face
             ;; if we didn't save original format yet, do it now
             (when (not original-format)
               (put 'header-line-format 'original header-line-format)
               (setq original-format header-line-format))
             ;; check if this window is selected, set faces accordingly
             (if (eq window (selected-window))
                 (setq header-line-format `(:propertize ,original-format face ,active-face))
               (setq header-line-format `(:propertize ,original-format face ,inactive-face)))))))
     (window-list)))


                              ;;;###autoload
  (defun sd/comment-line-or-region (n)
    "Comment or uncomment current line and leave point after it.
                       With positive prefix, apply to N lines including current one.
                       With negative prefix, apply to -N lines above.
                       If region is active, apply to active region instead."
    (interactive "p")
    (save-excursion
      (if (use-region-p)
          (comment-or-uncomment-region
           (region-beginning) (region-end))
        (let ((range
               (list (line-beginning-position)
                     (goto-char (line-end-position n)))))
          (comment-or-uncomment-region
           (apply #'min range)
           (apply #'max range)))
        (forward-line 1)
        (back-to-indentation))))

                              ;;;###autoload
  (defun sd/open-org-init()
    (interactive)
    "Open initialization file and move to the end of the buffer."
    (sd/open-file-move-to-end "~/.emacs.d/myinit.org"))

                              ;;;###autoload
  (defun sd/open-dev-notes()
    (interactive)
    "Load org initialization file and move to the end of the buffer."
    (sd/open-file-move-to-end "~/notes/development_notes.org"))

                              ;;;###autoload
  (defun sd/open-file-move-to-end(file-name)
    (interactive)
    "Open a file and move to the end of the buffer."
    (find-file file-name)
    (end-of-buffer))

                              ;;;###autoload
  (defmacro sd/advise-commands-after (advice-name commands &rest body)
    "Apply advice named ADVICE-NAME to multiple COMMANDS.
                          The body of the advice is in BODY."
    `(progn
       ,@(mapcar (lambda (command)
                   `(defadvice ,command (after ,(intern (concat (symbol-name command) "-" advice-name)) activate)
                      ,@body))
                 commands)))

                              ;;;###autoload
  (defun sd/copy-file-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the clipboard." filename))))

                              ;;;###autoload
  (defun sd/copy-buffer-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (kill-new (buffer-name)))

                              ;;;###autoload
  (defun sd/copy-full-path-of-current-buffer ()
    "copy full path into the yank ring and OS clipboard"
    (interactive)
    (when buffer-file-name
      (let ((current-directory (file-name-directory (file-truename buffer-file-name))))
        (kill-new current-directory)
        (message "%s" current-directory))))

  (defun sd/revert-all-buffers ()
    "Refreshes all open buffers from their respective files."
    (interactive)
    (dolist (buf (buffer-list))
      (with-current-buffer buf
        (when (and (buffer-file-name) (file-exists-p (buffer-file-name)) (not (buffer-modified-p)))
          (revert-buffer t t t) )))
    (message "Refreshed open files.") )

  (defun sd/man-follow ()
    "When viewing cppman man page, format the arguments in a way built in man command understands."
    (interactive)
    (if ( and (string-match-p "std::" (buffer-name)) (string-match-p "::" (Man-default-man-entry)))
        (man-follow (concat "std::" (Man-default-man-entry))))
    (man (Man-default-man-entry)))

  (defun sd/split-current-line ()
    "Split current line."
    (interactive)
    (move-beginning-of-line nil)
    (set-mark-command nil)
    (move-end-of-line nil)
    (replace-regexp "[ \t]+" "\n" nil (region-beginning) (region-end)))


  (defun sd/region-delete-blank-lines()
    (interactive)
    "Delete blank lines in a region"
    (flush-lines "^$" (region-beginning) (region-end)))

  (defun sd/mark-from-point-to-end-of-line ()
    "Marks everything from point to end of line"
    (interactive)
    (set-mark (line-end-position))
    (activate-mark))

  (defun sd/beginning-of-next-defun ()
    "Go to the beginning of the next defun"
    (interactive)
    (let ((current-prefix-arg -1))
      (call-interactively 'beginning-of-defun)))

  (defun sd/begin-of-prev-defun ()
    "Go to the beginning of the prev defun"
    (interactive)
    (let ((current-prefix-arg 1))
      (call-interactively 'beginning-of-defun)))

  (defun sd/mark-line (&optional arg)
    (interactive "p")
    (if (not mark-active)
        (progn
          (beginning-of-line)
          (push-mark)
          (setq mark-active t)))
    (forward-line))

  (defun sd/smart-join-line (beg end)
    "If in a region, join all the lines in it. If not, join the current line with the next line."
    (interactive "r")
    (if mark-active
        (sd/join-region beg end)
      (sd/top-join-line)))

  (defun sd/top-join-line ()
    "Join the current line with the next line."
    (interactive)
    (delete-indentation 1))

  (defun sd/join-region (beg end)
    "Join all the lines in the region."
    (interactive "r")
    (if mark-active
        (let ((beg (region-beginning))
              (end (copy-marker (region-end))))
          (goto-char beg)
          (while (< (point) end)
            (join-line 1)))))

  (defun sd/vc-refresh-state-all ()
    "Refresh version control mode line indicator for all buffers."
    (interactive)
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (vc-refresh-state))))

  (defun sd/ff-find-other-file ()
    (interactive)
    "ff-find-other-file ignoring #include lines."
    (ff-find-other-file nil t))

  (defun sd/protect-lcldev-buffers ()
    (interactive)
    "Make buffers in .lcldev directory read-only."
    (when (and (stringp buffer-file-name)
               (string-match "\\.lcldev" buffer-file-name))
      (message "Making %s file protected." buffer-file-name)
      (setq buffer-read-only t)))

  (defun diff-last-two-kills ()
    "Write the last two kills to temporary files and diff them."
    (interactive)
    (let ((old "/tmp/old-kill") (new "/tmp/new-kill"))
      (with-temp-file new
        (insert (current-kill 0 t)))
      (with-temp-file old
        (insert (current-kill 1 t)))
      (diff old new "-u" t)))

  (defun sd/switch-to-scratch ()
    "Switch to scratch buffer"
    (interactive)
    (switch-to-buffer "*scratch*"))

  (defun sd/json-format-region()
    (interactive)
    (save-excursion
      (shell-command-on-region (region-beginning)
                               (region-end)
                               "python3.9 -m json.tool"
                               (buffer-name)
                               t)))

  (defun sd/json-format-buffer()
    (interactive)
    (save-excursion
      (shell-command-on-region (point-min)
                               (point-max)
                               "python3.9 -m json.tool"
                               (buffer-name) t)))

  (defun sd/minibuffer-setup ()
    (set (make-local-variable 'face-remapping-alist)
         '((default :background "black"))))


  (defun xah-copy-to-register-1 ()
    "Copy current line or text selection to register 1.
  See also: `xah-paste-from-register-1', `copy-to-register'.

  URL `http://ergoemacs.org/emacs/elisp_copy-paste_register_1.html'
  Version 2017-01-23"
    (interactive)
    (let ($p1 $p2)
      (if (region-active-p)
          (progn (setq $p1 (region-beginning))
                 (setq $p2 (region-end)))
        (progn (setq $p1 (line-beginning-position))
               (setq $p2 (line-end-position))))
      (copy-to-register ?1 $p1 $p2)
      (message "Copied to register 1")))

  (defun xah-paste-from-register-1 ()
    "Paste text from register 1.
  See also: `xah-copy-to-register-1', `insert-register'.
  URL `http://ergoemacs.org/emacs/elisp_copy-paste_register_1.html'
  Version 2015-12-08"
    (interactive)
    (when (use-region-p)
      (delete-region (region-beginning) (region-end)))
    (insert-register ?1 t))

  (defun sd/go-to-column (column)
    (interactive "nColumn: ")
    (move-to-column column t))

    (defun prot/display-buffer-at-bottom ()
      "Move the current buffer to the bottom of the frame.  This is
  useful to take a buffer out of a side window.

  The window parameters of this function are provided mostly for
  didactic purposes."
      (interactive)
      (let ((buffer (current-buffer)))
        (with-current-buffer buffer
          (delete-window)
          (display-buffer-at-bottom
           buffer `((window-parameters . ((mode-line-format . (" "
                                                               mode-line-buffer-identification)))))))))


  (defun sd/remove-hexadecimal-numbers-from-buffer()
    "Remove all hexadecimal numbers from the current buffer"
    (interactive)
    (save-excursion
      (vr/replace "0x[[:xdigit:]]+" "" (point-min) (point-max))))

#+END_SRC
* Highlighting related customizations
#+BEGIN_SRC emacs-lisp

  ;; adopted from the excellent exordium, by Philippe Grenet. All the credit is his.
  (defvar sd/highlighted-symbols ()
    "list of regexps for the currently highlighted symbols. This
      variable is buffer-local.")

  (make-variable-buffer-local 'sd/highlighted-symbols)

  (defun sd/highlight-symbol ()
    "Toggles highlighting of occurrences of the symbol under point
    in the current buffer. Up to 4 different symbols can be
    highlighted using different colors at one time."
    (interactive)
    (let ((regex (find-tag-default-as-symbol-regexp)))
      (cond ((member regex sd/highlighted-symbols)
             ;; Remove highlight for this symbol.
             (setq sd/highlighted-symbols (remove regex sd/highlighted-symbols))
             (hi-lock-unface-buffer regex))
            (t
             ;; Add highlight for this symbol.
             (setq sd/highlighted-symbols (cons regex sd/highlighted-symbols))
             (hi-lock-face-symbol-at-point)))
      ;; disable hl-mode when there are highlighted symbols as the
      ;; hl-line face background interferes witht he highlighting
      (if sd/highlighted-symbols
          (progn
            (global-hl-line-mode 0)
            (setq-default cursor-type '(bar . 7))
            (set-cursor-color "red")
            )
        (progn
          (setq-default cursor-type '(bar . 1))
          (set-cursor-color "cyan")
          (global-hl-line-mode +1))
        )))

  (global-set-key (kbd "<f2>") 'sd/highlight-symbol)

  ;; hilight current line
  (global-hl-line-mode +1)
  ;; enables us to turn off hl-line in certain modes
  (make-variable-buffer-local 'global-hl-line-mode)
  (set-face-background hl-line-face "gray26")

  ;; for the sake of org-roam completions
  (setq completion-ignore-case t)
#+END_SRC
* Color customizations
#+BEGIN_SRC emacs-lisp
  ;; Set cursor color to white
  (set-cursor-color "cyan")
  ;; Make cursor a thin bar
  (setq-default cursor-type '(bar . 1))
  ;; set background colors
  ;; (set-background-color "#2F4F4F")
  (set-background-color "gray18")
  ;; color of border of buffer separator
  ;; (set-face-background 'fringe "#2F4F4F")
  (set-face-background 'fringe "gray18")
  ;; color of comments
  (set-face-foreground 'font-lock-comment-face "#FA8278")
  ;; color of keyword
  (set-face-foreground 'font-lock-keyword-face "#FF9664")
  ;; color of background
  (set-face-foreground 'default "#FFF8DC")
  ;; color of srings
  (set-face-foreground 'font-lock-string-face "#00ECC8")
  ;; selection/search background/foreground
  (set-face-attribute 'region nil :background "black" :foreground "yellow" )
  (set-face-attribute 'isearch nil :background "black" :foreground "yellow" )
  (set-face-attribute 'lazy-highlight nil :background "black" :foreground "cyan" )
  ;; color line numbers
  (face-spec-set 'line-number-current-line '((t (:foreground "cyan1"))))
#+END_SRC

* Mac specific
#+BEGIN_SRC emacs-lisp
  ;; don't need this anymore as the command key is swapped with option to mimic windows keyboard layout
  ;;
  ;; make command a meta key on Macs
  ;; (when (eq system-type 'darwin)
  ;;   (setq mac-command-modifier 'meta)
  ;;   (global-set-key (kbd "C-M-h") 'ns-do-hide-emacs)
  ;;   )
#+END_SRC

* Window related
#+BEGIN_SRC emacs-lisp
  ;; Kill current window
  (global-unset-key (kbd "M-<end>"))
  (global-set-key (kbd "M-<end>") 'delete-window)
  (global-set-key (kbd "C-M-<backspace>") 'delete-window)

  ;; Got to other window after horizontal/vertial split
  (global-unset-key (kbd "\C-x2"))
  (global-set-key "\C-x2"
                  (lambda ()
                    (interactive)
                    (split-window-vertically)
                    (other-window 1)))

  (global-unset-key (kbd "\C-x3"))
  (global-set-key "\C-x3" (lambda ()
                            (interactive)
                            (split-window-horizontally)
                            (other-window 1)))

  ;; Window movements
  (global-unset-key (kbd "M-l"))
  (global-set-key (kbd "M-l") 'windmove-right)

  (global-unset-key (kbd "M-h"))
  (global-set-key (kbd "M-h") 'windmove-left)

  (global-unset-key (kbd "M-k"))
  (global-set-key (kbd "M-k") 'windmove-up)

  (global-unset-key (kbd "M-j"))
  (global-set-key (kbd "M-j") 'windmove-down)

  ;; Window sizing commands
  (global-unset-key (kbd "s-<down>"))
  (global-set-key (kbd "s-<down>") '(lambda()
                                    (interactive)
                                    (shrink-window 2)))

  (global-unset-key (kbd "s-<up>"))
  (global-set-key (kbd "s-<up>") '(lambda()
                                    (interactive)
                                    (enlarge-window 2)))

  (global-unset-key (kbd "s-<right>"))
  (global-set-key (kbd "s-<right>") '(lambda()
                                       (interactive)
                                       (enlarge-window-horizontally 2)))

  (global-unset-key (kbd "s-<left>"))
  (global-set-key (kbd "s-<left>") '(lambda()
                                      (interactive)
                                      (shrink-window-horizontally 2)))

  ;; Start maximised (cross-platf)
  (add-hook 'window-setup-hook 'toggle-frame-maximized t)

  ;; update header line's color every time the buffer is switched
  ;;(add-hook 'buffer-list-update-hook
  ;;          'sd/update-header)

#+END_SRC
* Aliases
#+BEGIN_SRC emacs-lisp
  (defalias 'dl  'sd/region-delete-blank-lines)
  (defalias 'a   'align-regexp)
  (defalias 's   'sort-lines)
  (defalias 'n   'narrow-to-defun)
  (defalias 'w   'widen)
#+END_SRC
* Modes
 #+BEGIN_SRC emacs-lisp
   ;; Somehow need to do this first.
   ;; Without this, cannot use :chords
   (use-package use-package-chords
     :ensure t
     :config (key-chord-mode 1))
 #+END_SRC
** ace-jump-mode
#+BEGIN_SRC emacs-lisp
  ;; might want to consider switching to ivyy
  (use-package ace-jump-mode
    :disabled
    :ensure t
    :bind (("M-SPC" . ace-jump-word-mode ))
    :init
    ;; disable gray background
    (setq ace-jump-mode-gray-background nil)

    :config
    ;; use this to always push onto the global mark ring
    ;; when jumping
    (add-hook 'ace-jump-mode-before-jump-hook (lambda ()
						(back-button-push-mark-local-and-global)))
    ;; beacon blink after ace-jump
    (add-hook 'ace-jump-mode-end-hook (lambda ()
					(beacon-blink)))
    (custom-set-faces
     '(ace-jump-face-foreground
       ((t (:inherit ace-jump-face-foreground :height 1.0 :foreground "yellow" :background "black" )))))
    )
#+END_SRC
** ace-window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :init
    (setq aw-background nil)
    (global-set-key (kbd "C-x o") 'ace-window)
    :config
    (setq aw-keys '(?a ?b ?c ?d ?e ?f ?g ?h ?i ?j ?k ?l ?m ?n ?o ?p))
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:inherit ace-jump-face-foreground :height 6.0))))))
#+END_SRC
** all-the-icons
#+BEGIN_SRC emacs-lisp
  ;; don't forget to run (all-the-icons-install-fonts) if setting up
  ;; for the first time
  (use-package all-the-icons
      :ensure t)
#+END_SRC
** avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind (("M-SPC" . avy-goto-char-timer ))
    :config
    ;; match current window only
    (setq avy-all-windows nil
          avy-case-fold-search nil) ; case sensitive
    ;; cyan on black for matching characters
    (custom-set-faces
     '(avy-lead-face
       ((t (:inherit avy-lead-face :height 1.0 :foreground "Cyan" :background "black" :weight normal))))
     '(avy-goto-char-timer-face
       ((t (:inherit avy-goto-char-timer-face :height 1.0 :foreground "Cyan" :background "black" :weight normal))))))
#+END_SRC
** beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :bind (("C-l" . beacon-blink))
    :config
    (beacon-mode 1)
    (setq beacon-blink-when-focused t)
    (setq beacon-color "cyan")
    (setq beacon-size 100)
    (setq beacon-blink-duration 0.006))
#+END_SRC
** cc-mode
#+BEGIN_SRC emacs-lisp
  ;; from https://github.com/philippe-grenet/exordium/blob/master/modules/init-bde-style.el

  ;;; Utility functions and constants

  (defconst exordium-bde-search-max-bound (* 80 25))
  ;;   "Maximum point to search when searching for some regexp/string. Often
  ;; the search is bound to the same line, however sometimes functionality needs to
  ;; account for multi-line definitions. In here we assume 80 (columns) * 25 (lines)
  ;; is enough for everyone.")

  (defun bde-component-name ()
    "Return the name of the component for the current buffer"
    (let ((name (file-name-sans-extension
                 (file-name-nondirectory (buffer-file-name)))))
      (cond ((string-match-p "\\.[gipu]\\.t$" name)
             (substring name 0 (- (length name) 4)))
            ((string-suffix-p ".t" name)
             (substring name 0 (- (length name) 2)))
            (t name))))

  (defun bde-package-name ()
    "Return the name of the package for the current buffer"
    (interactive)
    (let ((component-name (bde-component-name)))
      (substring
       component-name
       0
       (string-match "_" component-name
                     (if (string-prefix-p "s_" component-name)
                         2
                       0)))))

  ;;; Indentation
  ;;;
  ;;; This section define a C style named "bde" using c-add-style.  The offset
  ;;; in the specification (c-offset-alist) can be any of the following:
  ;;;
  ;;; - An integer -> specifies a relative offset. All relative offsets will be
  ;;;   added together and used to calculate the indentation relative to an
  ;;;   anchor position earlier in the buffer.
  ;;; - One of the symbols +, -, ++, --, *, or /
  ;;;   +   = c-basic-offset times 1
  ;;;   -   = c-basic-offset times −1
  ;;;   ++  = c-basic-offset times 2
  ;;;   --  = c-basic-offset times −2
  ;;;   *   = c-basic-offset times 0.5
  ;;;   /   = c-basic-offset times −0.5
  ;;;
  ;;; Note: to debug the indentation of a particular line, type 'C-c C-s'. It
  ;;; will display the variable 'c-syntactic-context' which is a list of the
  ;;; syntactic components affect the offset calculations for that line, with the
  ;;; character position in the buffer for each of them. More details in M-x
  ;;; info, then CC mode, then Interactive Customization.
  ;;; See cc-align.el for examples of line-up functions.

  (eval-when-compile (defvar c-syntactic-context))

  (defun bde-is-member-function-declaration ()
    "Return whether the line ending resembles the member function declaration."
    (re-search-forward
     (concat ") *\\(const\\)?"
             " *\\(noexcept\\|BSLS_CPP11_NOEXCEPT\\)?"
             " *\\(\\(= *\\(0\\|de\\(fault\\|lete\\)\\)\\)"
             "\\|BSLS_CPP11_DE\\(FAULT\\|LETED\\)"
             "\\|override\\|BSLS_CPP11_OVERRIDE\\)?"
             " *\\(&\\(&\\)?\\)?"
             " *; *$")
     (point-at-eol) t))

  (defun bde-comment-offset (element)
    "Custom line-up function for BDE comments.
  Return a symbol for the correct indentation level at the
  current cursor position, if the cursor is within a class definition:
  1. + for method comments:
          int foo() const = 0;
              // tab goes here
          int bar() { return 0; }
              // tab goes here
  2. column number of beginning of comment for data member comments:
          int d_data;     // my comment at whatever column I want
                          // tab goes here
          int d_someLongVariableName;
                          // my comment at whatever column I want
                          // tab goes here
  3. nil otherwise."
    (case (caar c-syntactic-context)
      ((inclass innamespace)
       (save-excursion
         (let ((class-offset         ; extra offset for inner structs
                (c-langelem-col (car c-syntactic-context) t))
               (comment-column nil)) ; column number of last //
           (loop
            (beginning-of-line)
            (cond ((= (point) (point-min))
                   (return nil))
                  ((re-search-forward "^ *//" (point-at-eol) t)
                   ;; looking at a comment line
                   (setq comment-column (- (current-column) 2))
                   (forward-line -1))
                  ((bde-is-member-function-declaration)
                   ;; looking at end of method declaration
                   (return '+))
                  ((re-search-forward "} *$" (point-at-eol) t)
                   ;; looking at end of inline method definition
                   (return '+))
                  ((re-search-forward "; *//" (point-at-eol) t)
                   ;; looking at beginning of data member comment block
                   (return (- (current-column) 2 class-offset c-basic-offset)))
                  ((and comment-column
                        (re-search-forward "[_A-Za-z0-9]+; *$"
                                           (point-at-eol) t))
                   ;; looking at end of (long?) data member declaration
                   (return (- comment-column class-offset c-basic-offset)))
                  (t
                   (return nil)))))))
      (t nil)))

  (defun bde-statement-block-intro-offset (element)
    "Custom line-up function for first line of a statement block.
  The default identation is is '+' (1 basic offset), unless we are in
  a switch statement, in which case the indentation is set to
  '*' (half basic offset). Example:
  switch(val) {
    case 100: {
        return 1;
    } break;
    default: {
        return 0;
    } break;
  }"
    (save-excursion
      (goto-char (c-langelem-pos element))
      (if (looking-at "\\(case\\|default\\)")
          '*
        '+)))

  ;; associate .h file with c++ mode
  (add-to-list 'auto-mode-alist '("\\.[hc]\\'" . c++-mode))

  (use-package cc-mode
    :ensure t
    :bind(
          :map c++-mode-map
               ("C-x i" . sd/find-last-include)
               ;; ("<f1>"  . rtags-display-summary)
               ("M-m"   . counsel-imenu)
               ;; ("C-M-f" . rtags-find-symbol)
               ;; ("C-M-v" . rtags-find-virtuals-at-point)
               )
    :init
    ;; enable electric pair mode for buffers in c-mode

  (add-hook 'c++-mode-hook (lambda ()
                             ;; treat an underscore as word constituent
                             (modify-syntax-entry ?_ "w")
                             ;; turn on fci mode
                             (fci-mode)))
  (setq c-default-style
          '((java-mode . "java")
            (awk-mode  . "awk")
            (c++-mode  . "bde")
            (other     . "gnu")))
    :config
    ;; unbind c++-mode-map keys which interfer with global mappings
    (unbind-key "C-c C-c" c++-mode-map)
    (unbind-key "C-c C-u" c++-mode-map)
    (unbind-key "C-M-h" c++-mode-map)

    ;; trigger company completion via tab
    ;; (define-key c-mode-map [(tab)] 'company-complete)
    ;; (define-key c++-mode-map [(tab)] 'company-complete)

    ;; (add-hook 'c++-mode-hook 'irony-mode)
    ;; (add-hook 'c-mode-hook 'irony-mode)

    ;; See http://cc-mode.sourceforge.net/html-manual/Syntactic-Symbols.html#Syntactic-Symbols
    (c-add-style
     "bde"
     '((c-basic-offset . 4)
       (c-comment-only-line-offset . 0)
       (fill-column . 79)
       (c-backslash-column . 78)
       (c-backslash-max-column . 78)
       (c-offsets-alist
        (comment-intro         . bde-comment-offset)
        (defun-open            . 0)
        (defun-close           . 0)
        (statement-block-intro . bde-statement-block-intro-offset)
        (substatement-open     . 0)
        (substatement-label    . 0)
        (label                 . 0)
        (access-label          . /)
        (case-label            . *)
        (statement-case-intro  . *)
        (statement-case-open   . 0)
        (statement-cont        . +)
        (inline-open           . 0)
        (inline-close          . 0)
        (innamespace           . 0)
        (member-init-intro     . 0)
        (extern-lang-open      . 0)
        (brace-list-entry      . /)
        (extern-lang-close     . 0)))))
#+END_SRC
** ccls
#+BEGIN_SRC emacs-lisp
  (use-package ccls
    :ensure t
    :config

    (defun sd/base()
      "Display base class hierarchy"
      (interactive)
      (ccls-inheritance-hierarchy nil))

    (defun sd/derived()
      "Display derived class hierarchy"
      (interactive)
      (ccls-inheritance-hierarchy t))

    (defalias 'b 'sd/base)
    (defalias 'd 'sd/derived)

    (setq ccls-executable "/usr/local/bin/ccls")
    (setq ccls-args '("--log-file=/Users/sdayts/workspaces/ccls-cache/logs/ccls.log"))
    ;;   (setq ccls-cache-dir "/Users/sdayts/workspaces/ccls-cache/.ccls-cache")
    ;;   (setq ccls-extra-init-params '(:completion (:detailedLabel t)))
    :hook ((c-mode c++-mode objc-mode) .
           (lambda () (require 'ccls) (lsp))))
#+END_SRC
** company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :bind ( ("C-SPC" . company-complete)
            :map company-active-map
            ("C-n" . company-select-next)
            ("C-p" . company-select-previous))
    :config
    (global-company-mode)
    (setq company-idle-delay 0)
    ;; number of candidates to display
    (setq company-tooltip-limit 20)
    (custom-set-faces
     '(company-preview
       ((t (:foreground "cyan" :background "black" :underline t))))
     '(company-preview-common
       ((t (:inherit company-preview))))
     '(company-tooltip
       ((t (:background "black" :foreground "gray"))))
     '(company-tooltip-selection
       ((t (:background "RoyalBlue4" :foreground "yellow"))))
     '(company-tooltip-common
       ((((type x)) (:inherit company-tooltip :weight bold))
        (t (:inherit company-tooltip))))
     '(company-tooltip-annotation
       ((t (:background "black" :foreground "darkgray"))))
     '(company-tooltip-common-selection
       ((((type x)) (:inherit company-tooltip-selection :weight bold))
        (t (:inherit company-tooltip-selection)))))

    ;; company-echo
    ;; company-echo-common
    ;; company-preview
    ;; company-preview-common
    ;; company-preview-search
    ;; company-scrollbar-bg
    ;; company-scrollbar-fg
    ;; company-template-field
    ;; company-tooltip
    ;; company-tooltip-annotation
    ;; company-tooltip-annotation-selection
    ;; company-tooltip-common
    ;; company-tooltip-common-selection
    ;; company-tooltip-mouse
    ;; company-tooltip-search
    ;; company-tooltip-search-selection
    ;; company-tooltip-selection
    )
#+END_SRC
** company-box
#+BEGIN_SRC emacs-lisp
  (use-package company-box
    :ensure t
    :after company
    :hook (company-mode . company-box-mode)
    :config
    (setq company-box-show-single-candidate t)
    (setq company-box-icons-alist 'company-box-icons-all-the-icons)
    (custom-set-faces
   '(company-box-scrollbar
         ((t (:background "gray26" :foreground "gray26"))))))
#+END_SRC
** company-lsp
 #+BEGIN_SRC emacs-lisp
   (use-package company-lsp
     :disabled
     :after (lsp-mode company)
     :ensure t
     :init
     (push 'company-lsp company-backends)
     (setq company-transformers nil company-lsp-async t company-lsp-cache-candidates 'auto))
 #+END_SRC
** company-posframe
#+BEGIN_SRC emacs-lisp
  (use-package company-posframe
    :disabled
    :after (company)
    :ensure t
    :init
    :config
    (company-posframe-mode 1))
#+END_SRC
** counsel
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind ( ("M-y"     . counsel-yank-pop)
            ("C-S-b"   . counsel-ibuffer)
            ("M-x"     . counsel-M-x)
            ("<f1>"    . counsel-imenu)
            ("M-m"     . counsel-imenu)
            ("C-x C-f" . counsel-find-file)
            ("C-M-r"   . counsel-recentf )
            ("C-h f"   . counsel-describe-function)
            ("C-h v"   . counsel-describe-variable))
    :config
    (setq counsel-yank-pop-preselect-last t)
    (setq counsel-yank-pop-separator "\n")
    ;; remove annoying ^ prefix
    ;; should be done via ivy config, but because of the bug described at
    ;; https://github.com/jwiegley/use-package/issues/796, no longer works
    (setq ivy-initial-inputs-alist nil)
    (setq counsel-git-cmd "rg --files")
    (setq counsel-rg-base-command
          "rg -i -M 120 --no-heading --line-number --color never %s .")
    ;; don't use find for file occur
    (setq counsel-find-file-occur-use-find nil)
    (setq counsel-find-file-occur-cmd
          "gls -a | %s | gxargs -d '\\n' gls -d --group-directories-first"))
#+END_SRC
** counsel-dash
#+BEGIN_SRC emacs-lisp
  (use-package counsel-dash
    :disabled
    :ensure t
    :config
    (setq counsel-dash-docsets-path "~/.docsets")
    (setq counsel-dash-browser-func 'eww)
    (setq counsel-dash-common-docsets '("C++" "C")))
#+END_SRC
** counsel-projectile
#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :ensure t
    :bind (("M-o" . counsel-projectile-find-file))
    :config
    ;; make searches case-insensitive
    (setq counsel-projectile-grep-base-command "grep -irnE %s -- %%s .")
    (setq counsel-find-file-ignore-regexp "ccls-cache"))
#+END_SRC
** diff-mode
#+BEGIN_SRC emacs-lisp
  (use-package diff-mode
    :init
    :config
    (unbind-key "M-h" diff-mode-map)
    (unbind-key "M-j" diff-mode-map)
    (unbind-key "M-k" diff-mode-map)
    (unbind-key "M-l" diff-mode-map))
#+END_SRC
** define-word
#+BEGIN_SRC emacs-lisp
  (use-package define-word
    :ensure t
    :bind (("M-?" . define-word-at-point)))
#+END_SRC
** diminish
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t)
#+END_SRC
** dired
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :chords (("LL" . dired-jump))
    :bind ( :map dired-mode-map
                 ("C-M-i" . 'counsel-git-grep)
                 ("M-i" . swiper)
                 ;; End/Back key goes up one directory in dired mode
                 ("<end>" . dired-up-directory)
                 ;; instead of burying the buffer, kill it
                 ("q" . 'kill-current-buffer))
    :init
    (defun sd/dired-config()
      (require 'dired-x)
      (setq dired-omit-files
            ;; omit files I don't care about
            (concat dired-omit-files "\\|\\.o$\\|\\.d$\\|\\.dd$\\|\\.sundev1.c$\\|\\.mapfile$\\|\\.depends$\\|\\.ibm$\\|\\.sundev1$\\|\\.trap$\\|^llcalc_\\|^00"))
      ;; enable dired omit mode
      (dired-omit-mode t)
      ;; unset dired's biding so that the global can take over
      (unbind-key "M-l" dired-mode-map)
      ;; in dired mode don't highlight modified dired buffers
      (face-remap-add-relative 'doom-modeline-buffer-modified '(:foreground "white")))

    (add-hook 'dired-mode-hook 'sd/dired-config)

    :config
    ;; unset Cntl+Shift+b in dired mode which is by default wants to bookmark a file
    ;; while I like it to bring up the helm-mini
    (unbind-key "C-S-b" dired-mode-map)
    ;; if another dired buffer is open, make it a default target
    (setq dired-dwim-target t)
    (setq-local ace-jump-search-filter
                (lambda ()
                  (get-text-property (point) 'dired-filename)))
    ;; subpackages
    (use-package dired-hacks-utils
      :ensure t)
    (use-package dired-narrow
      :ensure t
      :config
      (bind-key "C-f" #'dired-narrow-fuzzy)
      (bind-key "C-x C-N" #'dired-narrow-regexp)
      (bind-key "C-c C-n" #'dired-narrow)))
#+END_SRC
** dired-subtree
#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :ensure t
    :after dired
    :config
    (bind-key "<tab>" #'dired-subtree-toggle dired-mode-map)
    (bind-key "<backtab>" #'dired-subtree-cycle dired-mode-map))
#+END_SRC
** dired-sidebar
#+BEGIN_SRC emacs-lisp
  (use-package dired-sidebar
    :disabled
    :ensure t
    :commands (dired-sidebar-toggle-sidebar)
    :bind (("<M-tab>" . dired-sidebar-toggle-sidebar))
    :config
    (setq dired-sidebar-width 45)
    (setq dired-sidebar-theme 'nerd)
    (unbind-key "M-h" dired-sidebar-mode-map)
    (unbind-key "M-j" dired-sidebar-mode-map)
    (unbind-key "M-k" dired-sidebar-mode-map)
    (unbind-key "M-l" dired-sidebar-mode-map)
  )
#+END_SRC
** dired+
#+BEGIN_SRC emacs-lisp
  (use-package dired+
    :load-path "~/.emacs.d/local-packages/dired+"
    :config
    (diredp-make-find-file-keys-reuse-dirs)
    (setq diredp-wrap-around-flag nil)
    ;; set up better colors
    (set-face-attribute 'diredp-flag-mark-line nil :background "black" :foreground "yellow" )
    (set-face-attribute 'diredp-flag-mark nil :background "black" :foreground "green" )
    (set-face-attribute 'diredp-deletion nil :background "black" :foreground "firebrick1" ))
#+END_SRC
** display-fill-column-indicator
#+BEGIN_SRC emacs-lisp
  (use-package display-fill-column-indicator
    :init
    (setq display-fill-column-indicator-column 80)
    (set-face-attribute 'fill-column-indicator nil
                        :foreground "systemOrangeColor")
    (add-hook 'prog-mode-hook 'display-fill-column-indicator-mode))
#+END_SRC
** docker
#+BEGIN_SRC emacs-lisp
(use-package docker
  :ensure t
  :bind ("C-c d" . docker))
#+END_SRC
** doom-modeline
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'mode-line nil
                      :background "black"
                      :foreground "white"
                      :box '(:line-width 1 :color "yellow")
                      :overline nil
                      :underline nil)

  (set-face-attribute 'mode-line-inactive nil
                      :background "black"
                      :overline nil
                      :underline nil)
  (use-package doom-modeline
    :ensure t
    :hook (after-init . doom-modeline-mode)
    :config
    (setq doom-modeline-height 10)
    (setq column-number-mode t)
    (setq doom-modeline-vcs-max-length 20)
    (set-face-foreground 'doom-modeline-buffer-file "green")
    (set-face-foreground 'doom-modeline-buffer-modified "red")
    (set-face-foreground 'doom-modeline-buffer-major-mode "yellow")
    (set-face-background 'doom-modeline-highlight "black")
    (set-face-foreground 'doom-modeline-highlight "yellow")

    (doom-modeline-def-modeline 'my-simple-line
      '(vcs buffer-info buffer-position selection-info lsp matches workspace-name))

    (defun setup-custom-doom-modeline ()
      (doom-modeline-set-modeline 'my-simple-line 'default))

    (add-hook 'doom-modeline-mode-hook 'setup-custom-doom-modeline))
#+END_SRC
** ediff
#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :config
    (setq ediff-split-window-function 'split-window-horizontally
          ediff-merge-split-window-function 'split-window-horizontally
          ediff-window-setup-function 'ediff-setup-windows-plain)
    (set-face-attribute 'ediff-current-diff-A nil :background "gray18" :box t)
    (set-face-attribute 'ediff-fine-diff-A nil :background "black" :foreground "green")
    (set-face-attribute 'ediff-current-diff-B nil :background "gray18" :box t)
    (set-face-attribute 'ediff-fine-diff-B nil :background "black" :foreground "yellow")
    (set-face-attribute 'ediff-current-diff-C nil :background "gray24" :box nil)
    (set-face-attribute 'ediff-fine-diff-C nil :background "black" :foreground "cyan" :weight 'normal :box t)

    (set-face-attribute 'ediff-even-diff-A nil :background "gray26")
    (set-face-attribute 'ediff-even-diff-B nil :background "gray26")
    (set-face-attribute 'ediff-even-diff-C nil :background "gray26")
    (set-face-attribute 'ediff-odd-diff-A nil :background "gray26")
    (set-face-attribute 'ediff-odd-diff-B nil :background "gray26")
    (set-face-attribute 'ediff-odd-diff-C nil :background "gray26")
    )
#+END_SRC
** el-patch
#+BEGIN_SRC emacs-lisp
  (use-package el-patch
    :disabled
    :ensure t)
#+END_SRC
** esup
#+BEGIN_SRC emacs-lisp
(use-package esup
  :ensure t)
#+END_SRC
** exec-path-from-shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+END_SRC
** expand-region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind (("C-=" . er/expand-region)
           ("C-M-=" . er/contract-region)))
#+END_SRC
** eyebrowse
#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :ensure t
    :disabled
    :bind (("C-M-h" . eyebrowse-prev-window-config)
           ("C-M-l" . eyebrowse-next-window-config))
    :config
    (eyebrowse-mode t))
#+END_SRC
** files
#+BEGIN_SRC emacs-lisp
  (use-package files
    :chords (("RR" . revert-buffer))
    :init
    (add-hook 'find-file-hook 'sd/protect-lcldev-buffers)
    :config)
#+END_SRC
** find-where
#+BEGIN_SRC emacs-lisp
  (use-package find-where
    :disabled
    :load-path "~/.emacs.d/local-packages/find-where")
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :chords (("FF" . flycheck-list-errors))
    :config
    (define-key flycheck-mode-map (kbd "s-p") #'flycheck-previous-error)
    (define-key flycheck-mode-map (kbd "s-n") #'flycheck-next-error))
#+END_SRC
** flyspell
#+BEGIN_SRC emacs-lisp
  ;; dictionary installed via:
  ;; brew install aspell
  (use-package flyspell
    :disabled
    :init
    (unbind-key "C-." flyspell-mode-map)
    (unbind-key "C-," flyspell-mode-map)
    (unbind-key "C-M-i" flyspell-mode-map)
    (setq ispell-program-name "/usr/local/bin/aspell")
    (add-hook 'prog-mode-hook 'flyspell-prog-mode))
#+END_SRC
** frame
#+BEGIN_SRC emacs-lisp
  (use-package frame
    :init
    (unbind-key "C-z" global-map))
#+END_SRC
** gcmh
#+BEGIN_SRC emacs-lisp
(use-package gcmh
  :disabled
  :ensure t
  :init
  (gcmh-mode 1))
#+END_SRC
** git-gutter-fringe+
#+BEGIN_SRC emacs-lisp
    (use-package git-gutter-fringe+
      :ensure    t
      :bind (("C-M-p" . git-gutter+-previous-hunk )
             ("C-M-n" . git-gutter+-next-hunk ))
      :init
      (global-git-gutter+-mode t))
#+END_SRC
** git-timemachine
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t )
#+END_SRC
** golden-ratio
#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :ensure t
    :config
    ;; don't enable golden ratio by default
    ;(golden-ratio-mode 1)
    (setq golden-ratio--value 1.5)
    (setq golden-ratio-max-width 150)
    ;; make sure golden ratio gets triggered after the following commands
    (setq golden-ratio-extra-commands
          (append golden-ratio-extra-commands
                  '(ace-window
                    avy-goto-word-1
                    magit-status))))
#+END_SRC
** goto-last-change
#+BEGIN_SRC emacs-lisp
(use-package goto-last-change
  :ensure t
  :bind ("C-z" . goto-last-change))
#+END_SRC
** grip-mode
#+BEGIN_SRC emacs-lisp
  (use-package grip-mode
    :ensure t
    :config)
#+END_SRC
** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :disabled
    :ensure t
    :bind (
           ;;("C-S-b"   . helm-mini)
           ;;("M-x"     . helm-M-x)             ;; meta-X is handled by Helm
           ;;("<f1>"    . helm-imenu)          ;; Map F1 to helm-imenu
           ;;("M-i"     . helm-swoop)
           ;;("M-y"     . helm-show-kill-ring)
           ;;("C-x C-f" . helm-find-files)
           )
    :init
    (setq helm-split-window-default-side 'same ; display helm in the same window
          helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
          helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
          helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
          helm-ff-file-name-history-use-recentf t
          helm-mode-reverse-history           nil ; place helm command history on top
          helm-ff-transformer-show-only-basename t; only show basename when helm-find-file, to show full path "C-]"

          ;; need to investigate what these do
          ;; just copied them from: https://github.com/yveszoundi/emacs.d/blob/master/bootstrap/startup.org
          ;;helm-adaptive-history-file             ers-helm-adaptive-history-file
          ;;helm-boring-file-regexp-list           '("\\.git$" "\\.svn$" "\\.elc$" "*~$")

          helm-buffer-max-length                 45
          helm-recentf-fuzzy-match               t
          helm-yank-symbol-first                 t
          helm-buffers-fuzzy-matching            t
          helm-ff-auto-update-initial-value      t
          helm-input-idle-delay                  0.1
          helm-idle-delay                        0.1
          )

    (use-package helm-ag
      :ensure    t
      :ensure    helm-projectile
      :bind      )

    (use-package helm-grep
      :defer t
      :bind
      :config
      ;; color file names in helm grep mode using a sensible color
      (set-face-attribute 'helm-grep-file nil
                          :foreground "azure")
      ;; the original value is "grep --color=always -a -d skip %e -n%cH -e %p %f"
      ;; the --color option would override helm-grep-match face and force the "red"
      ;; to be displayed, which does not play well with my color scheme
      ;; hence remove the --color from the command and override the helm-grep-match
      ;; with the color I like better
      (setq helm-grep-default-command "grep -a -d skip %e -n%cH -e %p %f")
      (set-face-attribute 'helm-grep-match nil
                          :background "black"
                          :foreground "yellow")
      )

    :config
    ;; make helm selection yellow on black
    (set-face-attribute 'helm-visible-mark nil
                        :background "black"
                        :foreground "yellow")
    ;; make current line in helm pleasant to look at
    (set-face-attribute 'helm-selection nil
                        :background "DarkCyan"
                        :foreground "white")
    )

    (use-package helm-swoop
      :disabled
      :ensure    t
      :config
      ;; make sure helm swoop plays nice with shackle
      ;; thank you wasamasa!
      (setq helm-swoop-split-window-function 'display-buffer)
      ;; my own faces
      (set-face-attribute 'helm-swoop-target-line-face nil
                          :background "yellow"
                          :foreground "black")

      (set-face-attribute 'helm-swoop-target-word-face nil
                          :background "black"
                          :foreground "yellow"))
#+END_SRC
** helm-projectile
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :disabled
    :ensure    t
  ;;  :bind      ("M-o" . helm-projectile)
    :after     (projectile))
#+END_SRC
** helpful
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :config
    :ensure t
    :bind
    (("C-h v" . helpful-variable)
     ("C-h k" . helpful-key)
     ("C-h f" . helpful-function)))
#+END_SRC
** hilight-indent-guides
#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
      :ensure t
      :config
      (setq highlight-indent-guides-method 'character)
      (setq highlight-indent-guides-character ?\|)
      (setq highlight-indent-guides-responsive 'stack))
#+END_SRC
** hl-todo
#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :ensure t
    :init
    (setq hl-todo-keyword-faces
          `(("TODO"  . "yellow")
            ("FIXME" . "VioletRed1")
            ("NOTE"  . ,(face-foreground 'success))))
    :config
    (global-hl-todo-mode))
#+END_SRC
** hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
    :ensure t
    :config)
#+END_SRC
** ibuffer
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind (("C-'" . ibuffer))
    :chords (("II" . ibuffer))
    :init
    (setq ibuffer-saved-filter-groups
          (quote (("default"
                   ("lcldev" (filename . "/.lcldev/"))
                   ("dired" (mode . dired-mode) )
                   ("eqwrnt2" (filename . "/eqwrnt2/"))
                   ("C++" (mode . c++-mode))
                   ("dired" (mode . dired-mode))
                   ("magit" (or (mode . magit-branch-mode)
                                (mode . magit-clone-mode)
                                (mode . magit-commit-mode)
                                (mode . magit-core-mode)
                                (mode . magit-diff-mode)
                                (mode . magit-ediff-mode)
                                (mode . magit-extras-mode)
                                (mode . magit-fetch-mode)
                                (mode . magit-files-mode)
                                (mode . magit-git-mode)
                                (mode . magit-gitignore-mode)
                                (mode . magit-imenu-mode)
                                (mode . magit-log-mode)
                                (mode . magit-margin-mode)
                                (mode . magit-merge-mode)
                                (mode . magit-mode)
                                (mode . magit-mode-mode)
                                (mode . magit-notes-mode)
                                (mode . magit-obsolete-mode)
                                (mode . magit-patch-mode)
                                (mode . magit-process-mode)
                                (mode . magit-pull-mode)
                                (mode . magit-push-mode)
                                (mode . magit-refs-mode)
                                (mode . magit-remote-mode)
                                (mode . magit-repos-mode)
                                (mode . magit-reset-mode)
                                (mode . magit-section-mode)
                                (mode . magit-sequence-mode)
                                (mode . magit-stash-mode)
                                (mode . magit-status-mode)
                                (mode . magit-submodule-mode)
                                (mode . magit-subtree-mode)
                                (mode . magit-tag-mode)
                                (mode . magit-transient-mode)
                                (mode . magit-utils-mode)
                                (mode . magit-wip-mode)
                                (mode . magit-worktree-mode)))
                   ("org" (name . "^.*org$"))
                   ("shell" (or (mode . eshell-mode) (mode . shell-mode)))
                   ("Emacs" (or
                             (name . "^\\*scratch\\*$")
                             (name . "^\\*Messages\\*$")))))))

    (setq ibuffer-show-empty-filter-groups nil)
    (setq ibuffer-expert t)
    (setq ibuffer-show-empty-filter-groups nil)
    (add-hook 'ibuffer-mode-hook
              '(lambda ()
                 (ibuffer-switch-to-saved-filter-groups "default")))
    :config
    (unbind-key "M-j" ibuffer-mode-map))
#+END_SRC
** iedit
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t
    :bind (("C-;" . iedit-mode))
    :config
    )
#+END_SRC
** ivy
#+BEGIN_SRC emacs-lisp
  (defconst sd/ivy-height 25)

  (defun sd/move-to-begin-word(&optional arg)
    "Move point to beginning of word"
    (with-ivy-window
      ;; if the preceding-char is part of the word or a number, back up
      (let ((char (preceding-char)))
        (if (and (eq (char-syntax char) ?w)
                 (or (> char ?9)
                     (< char ?1)))
            (backward-word arg)))))

  (advice-add 'ivy-yank-word :before 'sd/move-to-begin-word)

  (defun sd/counsel-minimum-height()
    "Set the height of the ivy minibuffer to the value of sd/ivy-height"
    (set-window-text-height nil sd/ivy-height)
    (setq ivy-height sd/ivy-height))

  (add-hook 'minibuffer-setup-hook #'sd/counsel-minimum-height)

  (use-package ivy
    :ensure t
    :diminish ivy-mode
    :bind(("<f10>" . ivy-resume)
          :map ivy-minibuffer-map
          ("M-SPC" . ivy-avy))
    :init
    :config
    (setq ivy-use-selectable-prompt t)
    ;; fix paste in ivy
    (unbind-key "C-v" ivy-minibuffer-map)
    ;; different matching approaches per function
    (setq ivy-re-builders-alist
          '( (counsel-imenu   . ivy--regex)
             (counsel-recentf . ivy--regex)
             (t               . ivy--regex)))
    (setq ivy-use-virtual-buffers t)
    ;; remove annoying ^ prefix
    (setq ivy-initial-inputs-alist nil)
    (set-face-attribute 'ivy-current-match nil :background "RoyalBlue4" :foreground "yellow" :weight 'normal )
    (set-face-attribute 'ivy-minibuffer-match-face-2 nil :background "black" :foreground "yellow"  :weight 'normal)
    (set-face-attribute 'ivy-minibuffer-match-face-3 nil :background "black" :foreground "green"  :weight 'normal)
    (set-face-attribute 'ivy-minibuffer-match-face-4 nil :background "black" :foreground "cyan"  :weight 'normal)
    (ivy-mode 1))
#+END_SRC
** ivy-posframe
#+BEGIN_SRC emacs-lisp
  (use-package ivy-posframe
    :ensure t
    :after (ivy posframe)
    :init
    :config
    (setq ivy-posframe-min-width 190)
    (setq ivy-posframe-display-functions-alist
          '((swiper           . nil)
            (counsel-git-grep . nil)
            (t                . nil)))

    (set-face-attribute 'ivy-posframe nil :background "black" )
    (set-face-attribute 'ivy-posframe-cursor nil :background "red" ))

#+END_SRC
** ivy-rich
#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :ensure t
    :config
    (setcdr (assq t ivy-format-functions-alist)
            #'ivy-format-function-line)
    (ivy-rich-mode 1))
#+END_SRC
** ivy-prescient
#+BEGIN_SRC emacs-lisp
  (use-package ivy-prescient
    :ensure t
    :after (prescient ivy)
    :custom
    (ivy-prescient-sort-commands
     '(:not swiper ivy-switch-buffer counsel-switch-buffer))
    (ivy-prescient-retain-classic-highlighting t)
    (ivy-prescient-enable-filtering t)
    (ivy-prescient-enable-sorting t)
    :config
    (defun sd/ivy-prescient-filters (str)
      "Specify an exception for `prescient-filter-method'.

  This new rule can be used to tailor the results of individual
  Ivy-powered commands, using `ivy-prescient-re-builder'."
      (let ((prescient-filter-method '(literal regexp)))
        (ivy-prescient-re-builder str)))

    (setq ivy-re-builders-alist
          '((counsel-rg       . sd/ivy-prescient-filters)
            (counsel-grep     . sd/ivy-prescient-filters)
            (counsel-yank-pop . sd/ivy-prescient-filters)
            (swiper           . sd/ivy-prescient-filters)
            (swiper-isearch   . sd/ivy-prescient-filters)
            (swiper-all       . sd/ivy-prescient-filters)
            (t                . ivy-prescient-re-builder)))
    (ivy-prescient-mode 1))
#+END_SRC
** ivy-xref
#+BEGIN_SRC emacs-lisp
  (use-package ivy-xref
    :ensure t
    :init
    ;; xref initialization is different in Emacs 27 - there are two different
    ;; variables which can be set rather than just one
    (when (>= emacs-major-version 27)
      (setq xref-show-definitions-function #'ivy-xref-show-defs))
    ;; Necessary in Emacs <27. In Emacs 27 it will affect all xref-based
    ;; commands other than xref-find-definitions (e.g. project-find-regexp)
    ;; as well
    (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+END_SRC
** json-mode
#+BEGIN_SRC emacs-lisp
(use-package json-mode
    :ensure t)
#+END_SRC
** key-chord
#+BEGIN_SRC emacs-lisp
  (use-package key-chord
      :ensure t
      :config)

  ;; turn on the key-chord mode
  (key-chord-mode 1)

  (key-chord-define-global "KK" 'kill-current-buffer)
  (key-chord-define-global "jj" 'xah-copy-to-register-1)
  (key-chord-define-global "kk" 'xah-paste-from-register-1)

#+END_SRC
** lisp-mode
#+BEGIN_SRC emacs-lisp
  (use-package lisp-mode
    :config
    ;; treat dash and underscore as word constituents
    (modify-syntax-entry ?- "w")
    (modify-syntax-entry ?_ "w"))
#+END_SRC
** lsp-mode
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t
    :bind (
           ("C-x r" . xref-find-references)
           ( "C-."  . xref-find-definitions)
           ("C-,"   . xref-pop-marker-stack)
           ("C-M-?" . ccls-member-hierarchy)
           ("M-."   . lsp-find-implementation))
    :config
    (add-to-list 'lsp-file-watch-ignored "[/\\\\]\\.ccls-cache$")
    (add-to-list 'lsp-file-watch-ignored "[/\\\\]\\.lcldev")
    (setq lsp-response-timeout 40
          lsp-auto-guess-root t
          lsp-prefer-flymake nil
          lsp-enable-on-type-formatting nil)
    (set-face-background 'lsp-face-highlight-textual "navy")
    (set-face-background 'lsp-face-highlight-read "blue")
    (set-face-background 'lsp-face-highlight-write "blue")
    (setq read-process-output-max (* 1024 1024)) ;; performance optimization
    (setq lsp-idle-delay 0.500)
    (setq lsp-lens-enable nil)
    (setq lsp-headerline-breadcrumb-enable nil)
    (setq gc-cons-threshold 100000000)
    ;;    (setq lsp-completion-provider :capf)

    ;; my own private version of which uses xref-match face instead of a hard-coded 'hilight face.
    (lsp-defun lsp--xref-make-item (filename (&Range :start (start &as &Position :character start-char :line start-line)
                                                     :end (end &as &Position :character end-char)))
      "Return a xref-item from a RANGE in FILENAME."
      (let* ((line (lsp--extract-line-from-buffer start))
             (len (length line)))
        (add-face-text-property (max (min start-char len) 0)
                                (max (min end-char len) 0)
                                'xref-match t line) ;; sdayts, using xref-match instead of 'highlight
        ;; LINE is nil when FILENAME is not being current visited by any buffer.
        (xref-make (or line filename)
                   (xref-make-file-location
                    filename
                    (lsp-translate-line (1+ start-line))
                    (lsp-translate-column start-char)))))
    :custom
    (lsp-file-watch-threshold nil))
#+END_SRC
** lsp-ivy
#+BEGIN_SRC emacs-lisp
  (use-package lsp-ivy
    :ensure t
    :bind (("C-?" . lsp-ivy-workspace-symbol))
    :config)
#+END_SRC
** lsp-ui
#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :disabled
    :ensure t
    :after lsp-mode
    :bind (("C-?" . lsp-ui-sideline-toggle-symbols-info))
    :hook (lsp-mode . lsp-ui-mode)
    :config
    (add-hook 'lsp-mode-hook 'lsp-ui-mode))
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp
  (defun sd/magit-kill-current-buffer()
    (interactive)
    (magit-mode-bury-buffer t))

  (use-package magit
    :ensure t
    :chords (("MM" . magit-status))
    :bind ( ("C-x g"   . magit-status)
            ("C-x m l" . magit-log-all)
            :map magit-mode-map
            ;; instead of burying the buffer, kill it
            ("q" . sd/magit-kill-current-buffer)
            ("<f8>" . prot/display-buffer-at-bottom))
    :config
    ;; start off with cursor on Unstaged section
    (setq magit-status-initial-section '(2))
    (setq magit-section-initial-visibility-alist
          '((untracked . hide)
            (unpushed  . show)))
    ;; make diff look nicer
    (setq magit-diff-refine-hunk t)
    (set-face-attribute 'diff-refine-removed nil :foreground "tan1" :strike-through t :background "black" :box nil)
    (set-face-attribute 'diff-refine-added nil :foreground "aquamarine" :background "black" :box t :weight 'normal)
    ;; update magit heading line to yellow on black, the way I like it...
    (set-face-attribute 'magit-diff-hunk-heading-highlight nil :background "black" :foreground "yellow")
    ;; make changes look nice
    (set-face-attribute 'magit-diff-removed-highlight nil :background "black" :foreground "red")
    (set-face-attribute 'magit-diff-added-highlight nil :background "black" :foreground "SeaGreen3")
    (set-face-attribute 'magit-diff-removed nil :background "DarkRed")
    (set-face-attribute 'magit-diff-hunk-heading nil :background "black" :foreground "turquoise1" ))
#+END_SRC
** make-mode
#+BEGIN_SRC emacs-lisp
  (use-package make-mode
    :defer t
    :init
    :config
    (unbind-key "C-M-i" makefile-mode-map))
#+END_SRC
** man
#+BEGIN_SRC emacs-lisp
  (use-package man
    :bind ( :map Man-mode-map
                 ("<return>" . sd/man-follow)))
#+END_SRC
** markdown
#+BEGIN_SRC emacs-lisp
    (use-package markdown-mode
      :ensure t
      :config
      (add-hook 'markdown-mode-hook
                (lambda ()
                  (make-local-variable 'before-save-hook)
                  (remove-hook 'before-save-hook 'whitespace-cleanup t))))
#+END_SRC
** modern-cpp-font-lock
#+BEGIN_SRC emacs-lisp
  (use-package modern-cpp-font-lock
    :diminish modern-c++-font-lock-mode
    :ensure t)
  (modern-c++-font-lock-global-mode t)
#+END_SRC
** move-text
#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :ensure t
    ;; Text movement
    :bind (("C-S-<up>"   . move-text-up )
           ("C-S-<down>" . move-text-down ))
    :config)
#+END_SRC
** multi-vterm
#+begin_src emqacs-lisp
  (use-package multi-vterm
    :ensure t)
#+end_src
** multiple-cursors
#+BEGIN_SRC emacs-lisp
  (defvar multiple-cursors-mode-enabled-hook nil
    "Hook that is run after `multiple-cursors-mode' is enabled.")

  (defvar multiple-cursors-mode-disabled-hook nil
    "Hook that is run after `multiple-cursors-mode' is disabled.")

  (defun sd/mc-when-enabled ()
    "Function to be added to `multiple-cursors-mode-enabled-hook'."
    (setq-default cursor-type '(box . 7)))

  (defun sd/mc-when-disabled ()
    "Function to be added to `multiple-cursors-mode-disabled-hook'."
    (setq-default cursor-type '(bar . 1)))

  (use-package multiple-cursors
    :ensure t
    :demand t
    :bind (("C--" . mc/mark-next-like-this  )
           ("C-M--" . mc/mark-all-like-this-in-defun  )
           :map mc/keymap
           ("<return>" . nil))
    :init
    (add-hook 'multiple-cursors-mode-enabled-hook #'sd/mc-when-enabled)
    (add-hook 'multiple-cursors-mode-disabled-hook #'sd/mc-when-disabled)
    ;; add mc cursors on Meta-left mouse click
    (global-unset-key (kbd "M-<down-mouse-1>"))
    (global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click)
    :config
    (set-face-foreground 'mc/cursor-face "red")
    (unbind-key "C-v" mc/keymap))

#+END_SRC
** nxml
#+BEGIN_SRC emacs-lisp
  (defun sd/xml-format ()
    "XML formating"
    (interactive)
    (save-excursion
      (shell-command-on-region (mark) (point) "xmllint --encode utf-8 --format -" (buffer-name) t)))

  (use-package nxml-mode
    :config
    (unbind-key "C-c C-u" nxml-mode-map)
    (unbind-key "M-h" nxml-mode-map)
    (unbind-key "C-M-i" nxml-mode-map))
#+END_SRC
** org
#+BEGIN_SRC emacs-lisp

  (defun sd/org-goto-result()
    (interactive)
    (org-babel-goto-named-result ""))

  (use-package org
    :ensure t
    :chords (("RR" . sd/org-goto-result))
    :init
    ;; stop asking about running embedded code
    (setq org-confirm-babel-evaluate nil)
    ;; add support for running c/c++ embedded code
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . nil)
       (C . t)))

    (unbind-key "M-h" org-mode-map)
    (unbind-key "C-M-i" org-mode-map)

    ;; indent propertly in org babel mode
    (setq org-src-tab-acts-natively t)
    ;; support shift-selection-mode
    (setq org-support-shift-select 'always)
    ;; timestamp TODO items
    ;; (setq org-log-done 'time)
    (setq org-log-done 'nil)

    ;; insert notes for DONE items
    ;; (setq org-log-done 'note)
    (setq org-todo-keyword-faces
          '(("IN-PROGRESS" . "orange1")))
    )
#+END_SRC
** org-bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
** org-roam
#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :after org
    :init
    (setq org-return-follows-link  t)
    (setq org-roam-completion-everywhere t)
    (setq org-roam-v2-ack t) ;; Acknowledge V2 upgrade
    (setq org-roam-directory (file-truename "~/notes/org-roam"))
    :config
    (org-roam-setup)
    (org-roam-db-autosync-mode)
    :bind (("C-c n f" . org-roam-node-find)
           ("<f9>"    . org-roam-node-find)
           (:map org-mode-map
                 (("C-c n i" . org-roam-node-insert)
                  ("C-c n t" . org-roam-tag-add)
                  ("<f9>"    . org-roam-tag-add)
                  ("C-c n a" . org-roam-alias-add)))))
#+end_src
** package
#+BEGIN_SRC emacs-lisp
    (use-package package
      :config
      (setq package-native-compile t))
#+END_SRC
** peep-dired
#+BEGIN_SRC emacs-lisp
  (use-package peep-dired
    :ensure t
    :after dired
    :config
    (setq peep-dired-cleanup-on-disable t)
    (setq peep-dired-enable-on-directories nil)
    (setq peep-dired-ignored-extensions
          '("mkv" "webm" "mp4" "mp3" "ogg" "iso"))
    :bind (:map dired-mode-map
                ("P" . peep-dired)))
#+END_SRC
** posframe
#+BEGIN_SRC emacs-lisp
  (use-package posframe
    :ensure t
    :bind ("C-M-<kp-delete>" . posframe-delete-all)
    :config)
#+END_SRC
** pcre2el
#+BEGIN_SRC emacs-lisp
  (use-package pcre2el
    :ensure t
    :config
    (pcre-mode))
#+END_SRC
** prescient
#+BEGIN_SRC emacs-lisp
  (use-package prescient
    :ensure t
    :disabled
    :custom
    (prescient-history-length 100)
    (prescient-save-file "~/.emacs.d/prescient-items")
    (prescient-filter-method '(fuzzy initialism regexp))
    :config
    (prescient-persist-mode 1))
#+END_SRC
** projectile
#+BEGIN_SRC  emacs-lisp
  (use-package projectile
    :ensure t
    :demand t
    :init
    ;;(setq projectile-completion-system 'helm)
    ;; solves a performance issue
    ;; without this, every cursor movement is incredibly slow
    (setq projectile-mode-line
          '(:eval (if (projectile-project-p)
                      (format " Proj[%s]"
                              (projectile-project-name))
                    "")))
    :config
    ;; make projectile file searches very fast
    (setq projectile-generMic-command "fd . -0 --type f --color=never")
    ;; ignore files
    (add-to-list 'grep-find-ignored-files "*.d")
    (add-to-list 'grep-find-ignored-files "*.dd")
    (add-to-list 'grep-find-ignored-files "*.mapfile")
    (add-to-list 'grep-find-ignored-files "*.tsk")
    (add-to-list 'grep-find-ignored-files "*.depends")
    (add-to-list 'grep-find-ignored-files "*.blob")
    (add-to-list 'grep-find-ignored-files "compile_commands.json")

    ;; ignore directories
    (add-to-list 'projectile-globally-ignored-directories "llcalc*")
    (add-to-list 'projectile-globally-ignored-directories "SunWS_cache*")
    (add-to-list 'projectile-globally-ignored-directories ".svn")
    (add-to-list 'projectile-globally-ignored-directories ".ccls-cache")
    ;; ignore specific file suffixes from projectile
    (setq projectile-globally-ignored-file-suffixes '(".svn-base"))
    (setq projectile-globally-ignored-file-suffixes '(".blob"))
    ;; ignore
    (add-to-list 'projectile-globally-ignored-files ".ccls-cache")
    (projectile-global-mode t))
#+END_SRC
** python
#+BEGIN_SRC emacs-lisp
  (defun sd/python-shell-send-buffer-switch-focus()
    "Python shell send buffer + switch focus to the REPL"
    (interactive)
    (python-shell-send-buffer)
    (switch-to-buffer-other-window "*Python*"))

  (use-package python
    :bind( :map python-mode-map
                ("C-c C-c" . sd/python-shell-send-buffer-switch-focus)
                ("C-c C-v" . sd/duplicate-line-or-region))
    :init
    (add-hook 'python-mode-hook #'lsp)
    (add-hook 'python-mode-hook #'flycheck-mode))

#+END_SRC
** recentf
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    (setq recentf-max-saved-items 500
          recentf-max-menu-items 30
          ;; disable recentf-cleanup on Emacs start, because it can cause
          ;; problems with remote files
          recentf-auto-cleanup 'never)
    (recentf-mode +1))
#+END_SRC
** rectangle-mark-mode
#+BEGIN_SRC emacs-lisp
    (use-package rect
      :bind(("C-M-<down>" . rectangle-mark-mode)
            :map rectangle-mark-mode-map
            ("C-w" . kill-rectangle)))
#+END_SRC
** rotate
#+BEGIN_SRC emacs-lisp
  (use-package rotate
    :bind (("M-<up>"   . rotate-frame-anticlockwise)
           ("M-<down>" . rotate-frame-clockwise) )
    :ensure t)
#+END_SRC

** savehist
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :config
    (savehist-mode +1))
#+END_SRC
** shackle
#+BEGIN_SRC emacs-lisp
  ;; make sure pop up buffers such as helm, help, etc pop up below, always in the same place
  (use-package shackle
    :ensure t
    :init
    (setq helm-display-function 'pop-to-buffer)
    (setq shackle-rules '(("\\`\\*helm.*?\\*\\'" :regexp t :align t :ratio 0.5)
                          ("\\`\\*Help.*?\\*\\'" :regexp t :align t :ratio 0.5)
                          ("*RTags*" :select t :align t :ratio 0.5)))
    :config
    (shackle-mode))
#+END_SRC
** shell
#+BEGIN_SRC emacs-lisp
  (use-package shell-mode
    :bind(:map shell-mode-map
               ("C-p" . comint-previous-input)
               ("C-n" . comint-next-input))
    :config
    (add-hook 'shell-mode-hook (lambda() (set-process-query-on-exit-flag (get-process "shell") nil)) ))
#+END_SRC
** shell-pop
#+BEGIN_SRC emacs-lisp
  (use-package shell-pop
    :ensure t
    :chords (("PP" . shell-pop))
    :config
    ;; Don't ask to kill the shell buffer
    (add-hook 'shell-mode-hook (lambda() (set-process-query-on-exit-flag (get-process "shell") nil)) )
    ;; (setq shell-pop-shell-type
    ;;       (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
    (setq shell-pop-shell-type
          (quote ("vterm" "*vterm*" (lambda nil (vterm)))))
    (setq shell-pop-term-shell "/bin/bash")
    (setq shell-pop-window-height 60)
    (setq shell-pop-full-span t)
    (setq shell-pop-window-position "bottom")
    (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+END_SRC
** sh-script
#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :config
    ;; unbind c++-mode-map keys which interfer with global mappings
    (unbind-key "C-c C-c" sh-mode-map)
    (unbind-key "C-c C-u" sh-mode-map))
#+END_SRC
** smartparens
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :bind ( ("C-M-<right>" . sp-slurp-hybrid-sexp)
            ("C-M-<left>" . sp-forward-barf-sexp))
    :defer t)
#+END_SRC
** swap-buffers
#+BEGIN_SRC emacs-lisp
  (use-package swap-buffers
    :ensure t
    :bind("C-<f12>" . swap-buffers)
    :init
    (setq swap-buffers-keep-focus t)
    :config)
#+END_SRC
** swiper
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind ( ("M-i" . swiper) )
    :config
    (setq swiper-goto-start-of-match t)
    (setq swiper-action-recenter t)
    ;; currently doesn't seem to work, with any luck will get fixed in the future
    (set-face-attribute 'swiper-match-face-1 nil :background "black" :weight 'normal)
    (set-face-attribute 'swiper-match-face-2 nil :foreground "yellow" :weight 'normal)
    (set-face-attribute 'swiper-match-face-3 nil :foreground "green"  :weight 'normal)
    (set-face-attribute 'swiper-match-face-4 nil :foreground "cyan"   :weight 'normal))
#+END_SRC
** tab-bar
#+begin_src emacs-lisp
  (defun sd/delete-vterm-tab-group-buffers (idx last-tab)
    "Delete all vterm buffers which are part of the current tab group."
    (let ((windows (window-list)))
      (while windows
        (let ((window (car windows)))
          (let ((this-buffer (window-buffer window)))
            (if (eq (buffer-local-value 'major-mode this-buffer) 'vterm-mode)
                (kill-buffer this-buffer)))
          (setq windows (cdr windows))))))

  (defun sd/vterm-r-window()
    (interactive)
    (split-window-horizontally)
    (windmove-right)
    (multi-vterm)
    (windmove-left))

  (defun sd/vterm-b-window()
    (interactive)
    (split-window-vertically)
    (windmove-down)
    (multi-vterm)
    (windmove-up))

  (defun sd/new-tabbar(tab-bar-name)
    "Create new tabbar with a provided name"
    (tab-bar-new-tab)
    (tab-bar-rename-tab tab-bar-name)
    ;; top left vterm
    (multi-vterm)
    ;; top right vterm
    (sd/vterm-r-window)
    ;; bottom left vterm
    (sd/vterm-b-window)
    ;;  bottom right vterm
    (windmove-right)
    (sd/vterm-b-window)
    (windmove-down))

  (defun sd/new-tabbar-linux()
    (interactive)
    (sd/new-tabbar "linux"))

  (global-unset-key (kbd "C-x l"))
  (global-set-key (kbd "C-x l") 'sd/new-tabbar-linux)

  (use-package tab-bar
    :bind ( ("C-M-h" . tab-bar-switch-to-prev-tab)
            ("C-M-l" . tab-bar-switch-to-next-tab))
    :config
    (setq tab-bar-show nil)
    (add-hook 'tab-bar-tab-pre-close-functions #'sd/delete-vterm-tab-group-buffers))
#+end_src
** term
#+BEGIN_SRC emacs-lisp
  (defun sd/term-hook ()
    "Term mode hook to set it up."
    ;; colors
    (setq buffer-face-mode-face `(:background "gray18"))
    (set-face-attribute 'term nil :background "gray18" )
    (buffer-face-mode 1)
    ;; eliminate fringes in term mode
    (setq left-fringe-width 0)
    (setq right-fringe-width 0)
    ;; disable hl-line in term
    (setq global-hl-line-mode nil))

  (use-package term
    :init
    (add-hook 'term-mode-hook #'sd/term-hook)
    :bind( :map term-raw-map
                ("C-v" . term-paste))

    :config
    (unbind-key "M-x" term-raw-map)
    (unbind-key "M-h" term-raw-map)
    (unbind-key "M-j" term-raw-map)
    (unbind-key "M-k" term-raw-map)
    (unbind-key "M-l" term-raw-map)
    (unbind-key "C-M-h" term-raw-map)
    (unbind-key "C-M-l" term-raw-map))
#+END_SRC
** text-mode
#+BEGIN_SRC emacs-lisp
  (use-package text-mode
    :init
    (unbind-key "C-M-i" text-mode-map))
#+END_SRC
** thingatpt+
#+BEGIN_SRC emacs-lisp
  (use-package thingatpt+
    :disabled
    :after find-where
    :load-path "~/.emacs.d/local-packages/thingatpt+")
#+END_SRC
** transpose-frame
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :ensure t
    :bind("<f12>" . flop-frame)
    :config)
#+END_SRC
** try
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC
** undo-tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :init
    (global-undo-tree-mode)
    (unbind-key "C-x r u" undo-tree-map)
    (unbind-key "C-x r U" undo-tree-map)
    (unbind-key "C-x r" undo-tree-map)
    (unbind-key "C-?" undo-tree-map))
#+END_SRC
** use-package-chors
#+BEGIN_SRC emacs-lisp
  (use-package use-package-chords
    :ensure t
    :chords (("vv" . sd/comment-line-or-region))
    :config
    (key-chord-mode 1))
#+END_SRC
** vc-svn
#+BEGIN_SRC emacs-lisp
  (use-package vc-svn
    :config
    (setq vc-svn-diff-switches '("-x --ignore-eol-style" "-x -w")))
#+END_SRC
** virtualenvwrapper
#+BEGIN_SRC emacs-lisp
  (use-package virtualenvwrapper
    :ensure t
    :config
    (venv-initialize-interactive-shells)
    (venv-initialize-eshell))

;  (venv-workon "p3")

  (setq lsp-python-executable-cmd "python3")
  (setq python-shell-interpreter "python3"
        python-shell-interpreter-args "-i")
#+END_SRC
** visual-regexp
#+BEGIN_SRC emacs-lisp
  (use-package visual-regexp
    :ensure t
    :config
    (define-key global-map (kbd "s-r") 'vr/replace))
#+END_SRC
** vlf
#+BEGIN_SRC emacs-lisp
  (use-package vlf
    :ensure t
    :init)
#+END_SRC
** vterm
#+BEGIN_SRC emacs-lisp
  (defun sd/vterm-hook ()
    "Term mode hook to set it up."
    ;; colors
    (setq buffer-face-mode-face `(:background "black"))
    (buffer-face-mode 1)
    ;; eliminate fringes in vterm mode
    (setq left-fringe-width 0)
    (setq right-fringe-width 0)
    (setq-local cursor-type '(box . 7))
    ;; disable hl-line in vterm
    (setq global-hl-line-mode nil))

  (use-package vterm
    :ensure t
    :init
    (add-hook 'vterm-mode-hook #'sd/vterm-hook)
    :config
    (unbind-key "M-h"   vterm-mode-map)
    (unbind-key "M-j"   vterm-mode-map)
    (unbind-key "M-k"   vterm-mode-map)
    (unbind-key "M-l"   vterm-mode-map)
    (unbind-key "C-M-l" vterm-mode-map)
    (unbind-key "C-M-h" vterm-mode-map))
#+END_SRC
** wgrep
#+BEGIN_SRC emacs-lisp
  ;; Editable grep buffer
  (use-package wgrep
    :ensure t
    :defer t
    :config
    ;; on wgrep-finish-edit, save all changed buffers
    (setq wgrep-auto-save-buffer t)
    ;; line change face in wgrep
    (set-face-attribute 'wgrep-face nil :foreground "systemTealColor" :background "black" :box t)
    (progn
      (with-eval-after-load 'grep
        (bind-key "C-x C-q" #'wgrep-change-to-wgrep-mode grep-mode-map))
      (with-eval-after-load 'wgrep
        (bind-key "C-c C-c" #'wgrep-finish-edit grep-mode-map))))
#+END_SRC
** which-function
#+BEGIN_SRC emacs-lisp
  (use-package which-func
    :disabled
    :config
    ;; (set-face-attribute 'which-func nil :background "Black" :foreground "Orange" :height 1.5)
    )
#+END_SRC
** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :ensure t
    :config
    (which-key-mode))
#+END_SRC
** whitespace
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :init
    (dolist (hook '(prog-mode-hook))
      (add-hook hook #'whitespace-mode))
    (add-hook 'before-save-hook #'whitespace-cleanup)
    :config
    (setq whitespace-style '(face trailing)))
#+END_SRC
** window
#+BEGIN_SRC emacs-lisp
  (use-package window
    :chords (("SS" . sd/switch-to-scratch))
    :bind ( ("M-r" . recenter) )
    :init
    (setq display-buffer-alist
          '(
            (".*COMMIT_EDITMSG"
             (display-buffer-in-direction)
             (direction . bottom)
             (window-width . 0.5)
             (window-height . fit-window-to-buffer))
            (".*Flycheck errors.*"
             (display-buffer-in-side-window)
             (window-height . 0.25)
             (side . bottom)
             (slot . 0))
            ("\\*vc-diff\\*"
             (display-buffer-in-side-window)
             (window-height . 0.75)
             (side . bottom)
             (slot . 1))
            ("\\*ivy-occur.*"
             (display-buffer-in-side-window)
             (window-height . 0.5)
             (side . bottom)
             (slot . 1))
            ("\\*Calendar*"
             (display-buffer-in-side-window)
             (side . bottom)
             (slot . 2))
            ;; left side window
            ("\\*Help.*"
             (display-buffer-in-side-window)
             (side . bottom)
             (window-height . 0.5)
             (slot . -1))
            ))

    ;; don't want magit buffers in a side window as ediff doesn't play nice with side windows
    (add-to-list 'display-buffer-alist
                 '((lambda(bufname _)
                     (with-current-buffer bufname
                       (equal major-mode 'magit-status-mode)))
                   (display-buffer-reuse-window display-buffer-in-direction)
                   (direction . bottom)
                   (dedicated . t)
                   (reusable-frames . visible)
                   (window-height . 0.5)))

    (add-to-list 'display-buffer-alist
                 '((lambda(bufname _)
                     (with-current-buffer bufname
                       (equal major-mode 'magit-diff-mode)))
                   (display-buffer-reuse-window display-buffer-in-direction)
                   (direction . right)
                   (dedicated . t)
                   (reusable-frames . visible)
                   (window-height . 0.5)))

    (add-to-list 'display-buffer-alist
                 '((lambda(bufname _)
                     (with-current-buffer bufname
                       (equal major-mode 'magit-log-mode)))
                   (display-buffer-reuse-window display-buffer-in-direction)
                   (direction . right)
                   (dedicated . t)
                   (reusable-frames . visible)
                   (window-height . 0.5)))

    (add-to-list 'display-buffer-alist
                 '((lambda(bufname _)
                     (with-current-buffer bufname
                       (equal major-mode 'magit-revision-mode)))
                   (display-buffer-reuse-window display-buffer-in-direction)
                   (direction . bottom)
                   (dedicated . t)
                   (reusable-frames . visible)
                   (window-height . 0.75)))

    (setq window-combination-resize t)
    (setq even-window-sizes 'height-only))
#+END_SRC
** whole-line-or-region
#+BEGIN_SRC emacs-lisp
    (defun sd/whole-line-or-region-kill-ring-save()
      "When in rectangle mode, copy the rectangle"
      (interactive)
      (if rectangle-mark-mode
          (progn
            (message "Copying rectangle.")
            (copy-rectangle-as-kill (region-beginning) (region-end)))
        (progn
          (message "Copying region.")
          (call-interactively 'whole-line-or-region-kill-ring-save))))

      (use-package whole-line-or-region
        :ensure t
        :bind (("C-w" . whole-line-or-region-kill-region)
               ("C-c c" . sd/whole-line-or-region-kill-ring-save))
        :config)
#+END_SRC
** wrap-region
#+BEGIN_SRC emacs-lisp
  (use-package wrap-region
    :diminish wrap-region-mode
    :disabled
    :ensure   t
    :config
    (wrap-region-global-mode t)
    ;; conflicts with magit
    (wrap-region-unset-key "q")
    (wrap-region-add-wrappers
     '(("(" ")")
       ("[" "]")
       ("{" "}")
       ("<" ">")
       ("'" "'")
       ("\"" "\"")
       ("‘" "’"   "q")
       ("“" "”"   "Q")
       ("*" "*"   "b"   org-mode)                 ; bolden
       ("*" "*"   "*"   org-mode)                 ; bolden
       ("/" "/"   "i"   org-mode)                 ; italics
       ("/" "/"   "/"   org-mode)                 ; italics
       ("~" "~"   "c"   org-mode)                 ; code
       ("~" "~"   "~"   org-mode)                 ; code
       ("=" "="   "v"   org-mode)                 ; verbatim
       ("=" "="   "="   org-mode)                 ; verbatim
       ("_" "_"   "u" '(org-mode markdown-mode))  ; underline
       ("**" "**" "b"   markdown-mode)            ; bolden
       ("*" "*"   "i"   markdown-mode)            ; italics
       ("`" "`"   "c" '(markdown-mode ruby-mode)) ; code
       ("`" "'"   "c"   lisp-mode)                ; code
       )))
#+END_SRC
** xref
#+BEGIN_SRC emacs-lisp
  (defun sd/recenter-advice (&rest _args)
    "Invoke recenter as an advice function"
    (recenter))

  (use-package xref
    :config
    (setq xref-prompt-for-identifier '(not xref-find-definitions
                                           xref-find-definitions-other-window
                                           xref-find-definitions-other-frame
                                           xref-find-references))
    (set-face-attribute 'xref-match nil :background "gray0" :foreground "cyan" )
    ;; recenter after popping the xref stack
    (advice-add #'xref-pop-marker-stack :after #'sd/recenter-advice))
#+END_SRC
** yasnippet
#+BEGIN_SRC emacs-lisp
        ;;;###autoload
  (defun sd/yas-no-expand-in-comment/string ()
    "Don't expand snippet while in comment."
    (setq yas-buffer-local-condition
          '(if (nth 8 (syntax-ppss)) ;; non-nil if in a string or comment
               '(require-snippet-condition . force-in-comment)
             t)))

  (add-hook 'prog-mode-hook 'sd/yas-no-expand-in-comment/string)
  (use-package yasnippet
    :diminish yas-minor-mode
    :ensure t
    :init
    (yas-global-mode 1)
    :config
    (define-key yas-minor-mode-map (kbd "<tab>") nil)
    (define-key yas-minor-mode-map (kbd "TAB") nil)
    (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)

    ;;keys for navigation
    ;; (define-key yas-keymap [(tab)]       nil)
    ;; (define-key yas-keymap (kbd "TAB")   nil)
    ;; (define-key yas-keymap [(shift tab)] nil)
    ;; (define-key yas-keymap [backtab]     nil)

    ;; (define-key yas-keymap (kbd "<new-next-field-key>") 'yas-next-field-or-maybe-expand)
    ;; (define-key yas-keymap (kbd "<new-prev-field-key>") 'yas-prev)
    )
#+END_SRC
** zoom-window
#+BEGIN_SRC emacs-lisp
  (use-package zoom-window
    :ensure t
    :bind (("C-M-z" . zoom-window-zoom)
	   )
    :init
    (setq zoom-window-mode-line-color "MidnightBlue")
    :config
    )
#+END_SRC
** Modes to explore in the future
# web-mode
* TODO
** emacs keybindings everywhere
https://gist.github.com/cheapRoc/9670905
** org babel

(setq org-confirm-babel-evaluate nil)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . nil)
   (C . t)))
** look into high cpu usage
https://github.com/emacs-lsp/lsp-mode/issues/1621
setq gc-cons-threshold 600000000)
(setq read-process-output-max (* 4096 1024))
(setq lsp-prefer-capf t)
(setq lsp-idle-delay 0.500)
(setq lsp-print-performance t)
** tab-bar
prevents tab-bar gui from showing up
useful for simulating tmux
(setq tab-bar-show nil)
* Tips
#+BEGIN_SRC emacs-lisp
(setq sd-tips
      '(
        "<C-c C-SPC> jump to the next active ERC buffer. Switch back to last non-ERC buffer visited."
        "<C-x +> will make windows the same heights and widths."
        "<C-x ^> increases the height by 1 line."
        "<C-h i> to open the info manual."
        "<C-t> to `transpose-chars'."
        "<C-x C-j> to `dired-jump' and goes to dired of file being visited."
        "<C-x C-q> to enter Dired Edit mode. When finished <C-c C-c>!"
        "<C-x C-t> to `transpose-lines'"
        "[Magit] s to stage; u to unstange; c for commit; F for pulling; P for pushing."
        "<C-x n n> narrow to region. Press <C-x n w> to widen (or un-narrow)."
        "<C-x n p> narrow to page. Press <C-x n w> to widen (or un-narrow)."
        "<C-x n s> narrow to subtree in org-mode. Press <C-x n w> to widen."
        "<C-x r SPC R> to save a buffer position in register R; jump back to it later."
        "<C-x r f R> to save frame configuration in register R; jump back to it later."
        "<C-x r w R> to save window configuration in register R; jump back to it later."
        "<C-x s> followed by d to see the diff of your buffer before saving it."
        "<M-=> with a region selected to `count-words'"
        "<M-t> to `transpose-words'."
        "<M-z> to use `zap-up-to-char'. Get used to it. Very useful."
        "<C-x => to display information about the character current under the cursor."
        "<M-x> `info-display-manual' to find information to specific mode."
        "<M-x> `occur' and remember that lines can be edited in place in the occur buffer."
        "<M-x> `write-region' to write a selection to a file."
        "After renaming file with `dired-jump', press <C-x k RET> to go back to the renamed file."
        "Syntax for using TRAMP through SSH: C-x C-f /ssh:username@myhost:/path/to/file."
        "Syntax for using TRAMP through SUDO: C-x C-f /su::/etc/hosts."
        "There is a very handy `sort-lines' command available in built-in Emacs."
        "Use `diff-buffer-with-file' to compare your buffer with the corresponding file at disk."
        "You can ask for a `list-registers' to see what is stored in those little monsters."
        "You can use <M-g TAB> to goto column. (move-to-column)"
        "You can use <M-x> `find-name-dired' to find all files recursively matching a pattern."
        "t inside a Dired buffer to mark all files in there. And Q to query-replace inside of them."
        "Use <C-x 4 f> when your cursor is over a filename to open in other window."
        "Use <C-x 5 f> when your cursor is over a filename to open in other frame."
        "<C-x d <directory>> to open in Dired."
        "To copy the name of the file at point, use `dired-copy-filename-as-kill'."
        "<C-x C-r> to open file in READ-ONLY mode."
        "To copy the path to the folder you're looking at in dired: <M-< w>"
        "Enable wdired mode in dired to edit the file name by hitting <C-x C-q>"
        "<C-c C-p> to open `find-file-at-point'."
        "<C-c C-w> to move a headline under another top level headline in org mode."
        "<C-c C-t> to show a painel with all the ORG Keyword options."
        "<C-x }> to enlarge window horizontally."
        "<C-x C-n> to `set-goal-column' to freeze the cursor when moving to the next line."
        "<C-c C-m> to call `smex-major-mode-commands' which will enable only relevant commands to your major mode."
        "<C-c> toggles if a searching of buffer and file names should ignore case."
        "<C-t> toggles matching by Emacs regular expression."
        "<C-SPC / C-@> restricts the completion list to anything that matches your current input."
        "<M-s> inside the IDO mode (C-x C-f) to search for a file matching your input."
        ))

(defun sd/tips ()
  (interactive)
  (random t)
  (message (concat " " (nth (random (length sd-tips)) sd-tips))))
#+END_SRC
