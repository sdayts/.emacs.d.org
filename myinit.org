#+STARTUP: overview

* Global settings
#+BEGIN_SRC emacs-lisp
  ;; set the default font
  (when (member "DejaVu Sans Mono" (font-family-list))
    (set-face-attribute 'default nil :font "DejaVu Sans Mono"))

  (if (file-readable-p "/usr/local/share/emacs/site-lisp/doxymacs")
      (progn
        ;; load doxymacs installed via: brew install doxymacs
        (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/doxymacs/")
        ;; load doxymacs
        (require 'doxymacs)))

  ;; prefer newer source to old bytecode
  (setq load-prefer-newer t)

  ;; when deleting in dired, move to trash
  (setq delete-by-moving-to-trash t)

  ;; this is needed for delete-by-moving-to-trash setting
  ;; to take effect under OSX
  (defun system-move-file-to-trash (file)
    "Use \"trash\" to move FILE to the system trash.
  When using Homebrew, install it using \"brew install trash\"."
    (call-process (executable-find "trash")
                  nil 0 nil
                  file))

  ;; fontify code in code blocks for org mode
  ;; somehow this does not work if I place this line
  ;; in the mode codfiguration section
  (setq org-src-fontify-natively t)

  ;; prevent accidental exits
  (global-unset-key (kbd "C-x C-c"))

  ;; Paste the way I am used to
  (global-unset-key (kbd "C-v"))
  (global-set-key (kbd "C-v") 'yank)

  (global-unset-key (kbd "C-M-y"))
  (global-set-key (kbd "C-M-y") 'yank-rectangle)

  ;; Paste the way I am used to
  (global-unset-key (kbd "C-M-j"))
  (global-set-key (kbd "C-M-j") 'join-line)

  ;; Copy word under the cursor
  (global-unset-key (kbd "M-c"))
  (global-set-key (kbd "M-c") 'sd/copy-word-under-cursor)

  ;; Copy word under the cursor
  (global-unset-key (kbd "C-M-c"))
  (global-set-key (kbd "C-M-c") 'sd/copy-buffer-name-to-clipboard)

  ;; Copy path of the current buffer
  (global-unset-key (kbd "C-M-x"))
  (global-set-key (kbd "C-M-x") 'sd/copy-full-path-of-current-buffer)

  ;; Comment bindings
  (global-unset-key (kbd "C-c C-c"))
  (global-set-key (kbd "C-c C-c") 'sd/comment-line-or-region)
  (global-unset-key (kbd "C-c C-u"))
  (global-set-key (kbd "C-c C-u") 'sd/comment-line-or-region)

  ;; Map F6 to describe-key
  (global-unset-key (kbd "<f6>"))
  (global-set-key (kbd "<f6>") 'describe-key)

  ;; display the fully qualified path in the frame title
  (setq frame-title-format
        '((:eval (if (buffer-file-name)
                     (buffer-file-name))
                 "%b")))

  ;; display full screen
  (global-unset-key (kbd "C-M-+"))
  (global-set-key (kbd "C-M-+") 'toggle-frame-maximized)

  ;; Show corresponding paren
  (show-paren-mode 1)

  ;; keyboard scroll one line at a time
  (setq scroll-step 1)
  ;; don't jump around when scrolling
  (setq scroll-conservatively 101)

  ;; suppress splash screen
  (setq inhibit-startup-message t)

  ;; disable scrollbar, menu bar and tool bar
  (scroll-bar-mode -1)
  (menu-bar-mode t)
  (tool-bar-mode -1)

  ;; turn off blinking cursor
  (blink-cursor-mode -1)

  ;; turn off the annoying beep
  (setq visible-bell nil)

  ;; turn off line wrapping
  (set-default 'truncate-lines t)

  ;; y/n instead of yes/no
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; enable saveplace mode
  (save-place-mode 1)

  ;; Kill current buffer
  (global-unset-key (kbd "C-<end>"))
  (global-set-key (kbd "C-<end>") 'kill-this-buffer)

  ;; Enable deleting of selected text by subsequent input
  (delete-selection-mode 1)

  ;; Match parens
  (global-unset-key (kbd "C-]"))
  (global-set-key (kbd "C-]") 'sd/forward-or-backward-sexp)

  ;; Duplicate line
  (global-unset-key (kbd "C-c C-v"))
  (global-set-key (kbd "C-c C-v") 'sd/duplicate-line-or-region)

  ;; Split current line
  (global-unset-key (kbd "C-M-o"))
  (global-set-key (kbd "C-M-o") 'sd/split-current-line)

  ;; Backup file configuration
  ;; back
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))

  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default t               ; auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
        )

  ;; save desktop on exit
  (when window-system
    (add-to-list 'default-frame-alist '(width . 132))
    (add-to-list 'default-frame-alist '(height . 32))
    (add-to-list 'default-frame-alist '(ns-appearance . dark))
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t)))
  (desktop-save-mode 1)

  ;; toggle h-cpp
  (global-unset-key (kbd "C-<return>"))
  (global-set-key (kbd "C-<return>") 'ff-find-other-file)

  ;; toggle test to implementation and vice versa
  (global-unset-key (kbd "C-t"))
  (global-set-key (kbd "C-t") 'sd/toggle-implementation-test-cpp)

  ;; the following buffers should open in the same emacs window
  (add-to-list 'same-window-buffer-names "*Help*")
  (add-to-list 'same-window-buffer-names "*Backtrace*")
  (add-to-list 'same-window-buffer-names "*shell*")

  ;; mark the entire buffer
  (global-set-key (kbd "M-a") 'mark-whole-buffer)

  ;; indent with spaces
  (setq-default indent-tabs-mode nil)

  ;; unset Meta-x m, so that it can be reused for other purposes
  (global-unset-key (kbd "C-x m"))

  ;; copy text selected via a mouse to system's clipboard
  (setq mouse-drag-copy-region t)

  ;; open development notes
  (global-set-key (kbd "<f9>") 'sd/open-dev-notes)

  ;; open org initialization file
  (global-set-key (kbd "C-<f9>") 'sd/open-org-init)

  ;; use ff-find-related-file as a poor substitute for rtags index db, but that
  ;; is needed right now
  (global-unset-key (kbd "C-M-."))
  (global-set-key (kbd "C-M-.") 'ff-find-related-file)

  ;; setting to 2, original value is t,
  ;; performance enhancement, seems to help a little when commenting out large chunks of c++ code
  (setq font-lock-maximum-decoration t)

  ;; native line number implementation
  (global-display-line-numbers-mode)

  ;; search the entire project
  (global-unset-key (kbd "C-M-i"))
  ;; counsel-project-ag does not seem to work anymore, switching to native counsel command
  ;; (global-set-key (kbd "C-M-i") 'counsel-projectile-ag)
  (global-set-key (kbd "C-M-i") 'counsel-git-grep)

  ;; keybinding for re-centering the buffer
  (global-unset-key (kbd "M-r"))
  (global-set-key (kbd "M-r") 'recenter-top-bottom)

  ;; activate which-function mode
  (which-function-mode 1)

  ;; enable flyspell programming mode
  (flyspell-prog-mode)

  ;; start scrolling when within 3 lines of either top or bottom of the window
  (setq scroll-margin 3)

  ;; conveniently map repeat to F7
  (global-unset-key (kbd "<f7>"))
  (global-set-key (kbd "<f7>") 'repeat)

  ;; man pages
  (global-unset-key (kbd "C-c m"))
  (global-set-key (kbd "C-c m") 'helm-man-woman)
  ;; display man page in the current buffer
  (setq Man-notify-method 'pushy)

  ;; always select help window
  (setq help-window-select t)

  ;; bookmarks
  (global-unset-key (kbd "C-M-b"))
  (global-set-key (kbd "C-M-b") 'counsel-bookmark)

  ;; recenter after imenu jump
  (add-hook 'imenu-after-jump-hook #'recenter-top-bottom)

  ;; helps to prevent weirdly split windows in golden-ratio mode
  (setq split-width-threshold nil)

  ;; leave one space around the point
  (global-unset-key (kbd "C-M-d"))
  (global-set-key (kbd "C-M-d") 'just-one-space)

  ;; move to first non-blank character of the line
  (global-unset-key (kbd "C-b"))
  (global-set-key (kbd "C-b") 'back-to-indentation)

  ;; mark to the end of line
  (global-unset-key (kbd "s-="))
  (global-set-key (kbd "s-=") 'sd/mark-from-point-to-end-of-line)

  ;; mark whole lines
  (global-unset-key (kbd "M-="))
  (global-set-key (kbd "M-=") 'sd/mark-line)

  ;; go to beginning of the next defun
  (global-unset-key (kbd "M-n"))
  (global-set-key (kbd "M-n") 'sd/beginning-of-next-defun)

  ;; go to beginning of the prev defun
  (global-unset-key (kbd "M-p"))
  (global-set-key (kbd "M-p") 'sd/begin-of-prev-defun)

  ;; buffer movement
  (global-unset-key (kbd "s-p"))
  (global-set-key (kbd "s-p") 'previous-buffer)

  (global-unset-key (kbd "s-n"))
  (global-set-key (kbd "s-n") 'next-buffer)

  ;; map goto line to shit-space
  (global-unset-key (kbd "S-SPC"))
  (global-set-key (kbd "S-SPC") 'goto-line)

  ;; choose a snippet
  (global-unset-key (kbd "s-m"))
  (global-set-key (kbd "s-m") 'yas-insert-snippet)

  ;; stop emacs from making any sounds
  (setq ring-bell-function 'ignore)
#+END_SRC

* Custom functions
#+BEGIN_SRC emacs-lisp
  (defun sd/toggle-implementation-test-cpp()
    "Toggle between C++ implementation and test buffers."
    "Relies on the test files to follow \"t.cpp\" convention"
    (interactive)
    (let ((current-file-name-sans-ext (file-name-base buffer-file-name))
          (dominating-file (locate-dominating-file "." ".git")))
      (if (string-suffix-p ".t" current-file-name-sans-ext)
          ;; toggle from test to implementation
            (when dominating-file
              (let ((found-files (directory-files-recursively dominating-file
                                                              (concat (file-name-base current-file-name-sans-ext) ".cpp") )))
                ;; file found, switch
                (if found-files
                    (find-file (car found-files))
                  ;; .cpp file not found, fall back to looking for .h, as the implementation can be templatized
                  (progn
                    (setq found-files (directory-files-recursively dominating-file
                                                                   (concat (file-name-base current-file-name-sans-ext) ".h") ))
                    (if found-files
                        (find-file (car found-files))))))))
      ;; toggle from implementation to test
      (when dominating-file
        (let ((found-files (directory-files-recursively dominating-file
                                                        (concat current-file-name-sans-ext ".t.cpp") )))
          (if found-files
              (find-file (car found-files)))))))

  (defun sd/find-last-include()
    "Find the last include in the current buffer"
    (interactive)
    (rtags-location-stack-push)
    (setq matched-position (search-backward "#include" nil t))
    (if matched-position
        (progn
          (next-line)
          (recenter-top-bottom))
      (message "Did not find a #include")))

                    ;;;###autoload
  (defun sd/forward-or-backward-sexp (&optional arg)
    "Go to the matching parenthesis character if one is adjacent to point."
    (interactive "^p")
    (cond ((looking-at "\\s(") (forward-sexp arg))
          ((looking-back "\\s)" 1) (backward-sexp arg))
          ;; Now, try to succeed from inside of a bracket
          ((looking-at "\\s)") (forward-char) (backward-sexp arg))
          ((looking-back "\\s(" 1) (backward-char) (forward-sexp arg))))

                    ;;;###autoload
  (defun sd/duplicate-line-or-region(arg)
    "Duplicates the current line or region ARG times.
                    If there's no region, the current line will be duplicated. However, if
                    there's a region, all lines that region covers will be duplicated."
    (interactive "p")
    (let (beg end (origin (point)))
      (if (and mark-active (> (point) (mark)))
          (exchange-point-and-mark))
      (setq beg (line-beginning-position))
      (if mark-active
          (exchange-point-and-mark))
      (setq end (line-end-position))
      (let ((region (buffer-substring-no-properties beg end)))
        (dotimes (i arg)
          (goto-char end)
          (newline)
          (insert region)
          (setq end (point)))
        (goto-char (+ origin (* (length region) arg) arg)))))

  (defvar sd/copy-word-under-cursor-regex "[^[:word:]_]"
    "Regular expression to use when copying with `copy-word-under-cursor'.
                    Can be customized for each major mode.")

                    ;;;###autoload
  (defun sd/copy-word-under-cursor ()
    "Copy the word under the cursor to the kill ring."
    (interactive)
    (save-excursion
      (save-excursion (re-search-backward sd/copy-word-under-cursor-regex))
      (let ((beg (+ (match-beginning 0) 1))
            (end (re-search-forward sd/copy-word-under-cursor-regex)))
        (copy-region-as-kill beg (- end 1)))))

                    ;;;###autoload
  (defun sd/update-header()
    (interactive)
    (mapc
     (lambda (window)
       (with-current-buffer (window-buffer window)
         ;; don't mess with buffers that don't have a header line
         (when header-line-format
           (let ((original-format (get 'header-line-format 'original))
                 (inactive-face 'mode-line-inactive)
                 (active-face 'mode-line)
                 ) ; change this to your favorite inactive header line face
             ;; if we didn't save original format yet, do it now
             (when (not original-format)
               (put 'header-line-format 'original header-line-format)
               (setq original-format header-line-format))
             ;; check if this window is selected, set faces accordingly
             (if (eq window (selected-window))
                 (setq header-line-format `(:propertize ,original-format face ,active-face))
               (setq header-line-format `(:propertize ,original-format face ,inactive-face)))))))
     (window-list)))


                    ;;;###autoload
  (defun sd/comment-line-or-region (n)
    "Comment or uncomment current line and leave point after it.
             With positive prefix, apply to N lines including current one.
             With negative prefix, apply to -N lines above.
             If region is active, apply to active region instead."
    (interactive "p")
    (save-excursion
      (if (use-region-p)
          (comment-or-uncomment-region
           (region-beginning) (region-end))
        (let ((range
               (list (line-beginning-position)
                     (goto-char (line-end-position n)))))
          (comment-or-uncomment-region
           (apply #'min range)
           (apply #'max range)))
        (forward-line 1)
        (back-to-indentation))))

                    ;;;###autoload
  (defun sd/open-org-init()
    (interactive)
    "Open initialization file and move to the end of the buffer."
    (sd/open-file-move-to-end "~/.emacs.d/myinit.org"))

                    ;;;###autoload
  (defun sd/open-dev-notes()
    (interactive)
    "Load org initialization file and move to the end of the buffer."
    (sd/open-file-move-to-end "~/notes/development_notes.org"))

                    ;;;###autoload
  (defun sd/open-file-move-to-end(file-name)
    (interactive)
    "Open a file and move to the end of the buffer."
    (find-file file-name)
    (end-of-buffer))

                    ;;;###autoload
  (defmacro sd/advise-commands-after (advice-name commands &rest body)
    "Apply advice named ADVICE-NAME to multiple COMMANDS.
                The body of the advice is in BODY."
    `(progn
       ,@(mapcar (lambda (command)
                   `(defadvice ,command (after ,(intern (concat (symbol-name command) "-" advice-name)) activate)
                      ,@body))
                 commands)))

                    ;;;###autoload
  (defun sd/copy-file-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the clipboard." filename))))

                    ;;;###autoload
  (defun sd/copy-buffer-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (kill-new (buffer-name)))

                    ;;;###autoload
  (defun sd/copy-full-path-of-current-buffer ()
    "copy full path into the yank ring and OS clipboard"
    (interactive)
    (when buffer-file-name
      (let ((current-directory (file-name-directory (file-truename buffer-file-name))))
            (kill-new current-directory)
            (message "%s" current-directory))))

  (defun sd/revert-all-buffers ()
    "Refreshes all open buffers from their respective files."
    (interactive)
    (dolist (buf (buffer-list))
      (with-current-buffer buf
        (when (and (buffer-file-name) (file-exists-p (buffer-file-name)) (not (buffer-modified-p)))
          (revert-buffer t t t) )))
    (message "Refreshed open files.") )

  (defun sd/man-follow ()
    "When viewing cppman man page, format the arguments in a way built in man command understands."
    (interactive)
    (if ( and (string-match-p "std::" (buffer-name)) (string-match-p "::" (Man-default-man-entry)))
        (man-follow (concat "std::" (Man-default-man-entry))))
    (man (Man-default-man-entry)))

  (defun sd/split-current-line ()
    "Split current line."
    (interactive)
    (move-beginning-of-line nil)
    (set-mark-command nil)
    (move-end-of-line nil)
    (replace-regexp "[ \t]+" "\n" nil (region-beginning) (region-end)))


  (defun sd/region-delete-blank-lines()
    (interactive)
    "Delete blank lines in a region"
    (flush-lines "^$" (region-beginning) (region-end)))

  (defun sd/mark-from-point-to-end-of-line ()
    "Marks everything from point to end of line"
    (interactive)
    (set-mark (line-end-position))
    (activate-mark))

  (defun sd/beginning-of-next-defun ()
    "Go to the beginning of the next defun"
    (interactive)
    (let ((current-prefix-arg -1))
      (call-interactively 'beginning-of-defun)))

  (defun sd/begin-of-prev-defun ()
    "Go to the beginning of the prev defun"
    (interactive)
    (let ((current-prefix-arg 1))
      (call-interactively 'beginning-of-defun)))

  (defun sd/mark-line (&optional arg)
    (interactive "p")
    (if (not mark-active)
        (progn
          (beginning-of-line)
          (push-mark)
          (setq mark-active t)))
    (forward-line))
#+END_SRC

* Highlighting related customizations
#+BEGIN_SRC emacs-lisp

; adopted from the excellent exordium, by Philippe Grenet. All the credit is his.
(defvar sd/highlighted-symbols ()
  "list of regexps for the currently highlighted symbols. This
  variable is buffer-local.")

(make-variable-buffer-local 'sd/highlighted-symbols)

(defun sd/highlight-symbol ()
  "Toggles highlighting of occurrences of the symbol under point
in the current buffer. Up to 4 different symbols can be
highlighted using different colors at one time."
  (interactive)
  (let ((regex (find-tag-default-as-symbol-regexp)))
    (cond ((member regex sd/highlighted-symbols)
           ;; Remove highlight for this symbol.
           (setq sd/highlighted-symbols (remove regex sd/highlighted-symbols))
           (hi-lock-unface-buffer regex))
          (t
           ;; Add highlight for this symbol.
           (setq sd/highlighted-symbols (cons regex sd/highlighted-symbols))
           (hi-lock-face-symbol-at-point)))
    ; disable hl-mode when there are highlighted symbols as the
    ; hl-line face background interferes witht he highlighting
    (if sd/highlighted-symbols
      (progn
        (global-hl-line-mode 0)
	(setq-default cursor-type '(bar . 7))
        (set-cursor-color "red")
        )
      (progn
        (setq-default cursor-type '(bar . 1))
        (set-cursor-color "cyan")
        (global-hl-line-mode +1))
)))

(global-set-key (kbd "<f2>") 'sd/highlight-symbol)

;; hilight current line
(global-hl-line-mode +1)
;; enables us to turn off hl-line in certain modes
(make-variable-buffer-local 'global-hl-line-mode)
;; slightly prefer this color for the current line
;; (set-face-background hl-line-face "#345858")
(set-face-background hl-line-face "#345865")
#+END_SRC
* Color customizations
#+BEGIN_SRC emacs-lisp
  ;; Set cursor color to white
  (set-cursor-color "cyan")
  ;; Make cursor a thin bar
  (setq-default cursor-type '(bar . 1))
  ;; set background colors
  (set-background-color "#2F4F4F")
  ;; color of border of buffer separator
  (set-face-background 'fringe "#2F4F4F")
  ;; color of comments
  (set-face-foreground 'font-lock-comment-face "#FA8278")
  ;; color of keyword
  (set-face-foreground 'font-lock-keyword-face "#FF9664")
  ;; color of background
  (set-face-foreground 'default "#FFF8DC")
  ;; color of srings
  (set-face-foreground 'font-lock-string-face "#00ECC8")
  ;; selection/search background/foreground
  (set-face-attribute 'region nil :background "black" :foreground "yellow" )
  (set-face-attribute 'isearch nil :background "black" :foreground "yellow" )
  (set-face-attribute 'lazy-highlight nil :background "black" :foreground "cyan" )
  ;; color line numbers
  (face-spec-set 'line-number-current-line '((t (:foreground "cyan1"))))
#+END_SRC

* Mac specific
#+BEGIN_SRC emacs-lisp
  ;; don't need this anymore as the command key is swapped with option to mimic windows keyboard layout
  ;;
  ;; make command a meta key on Macs
  ;; (when (eq system-type 'darwin)
  ;;   (setq mac-command-modifier 'meta)
  ;;   (global-set-key (kbd "C-M-h") 'ns-do-hide-emacs)
  ;;   )
#+END_SRC

* Window related
#+BEGIN_SRC emacs-lisp
  ;; Kill current window
  (global-unset-key (kbd "M-<end>"))
  (global-set-key (kbd "M-<end>") 'delete-window)
  (global-set-key (kbd "C-M-<backspace>") 'delete-window)

  ;; Got to other window after horizontal/vertial split
  (global-unset-key (kbd "\C-x2"))
  (global-set-key "\C-x2"
                  (lambda ()
                    (interactive)
                    (split-window-vertically)
                    (other-window 1)))

  (global-unset-key (kbd "\C-x3"))
  (global-set-key "\C-x3" (lambda ()
                            (interactive)
                            (split-window-horizontally)
                            (other-window 1)))

  ;; Window movements
  (global-unset-key (kbd "M-l"))
  (global-set-key (kbd "M-l") 'windmove-right)

  (global-unset-key (kbd "M-h"))
  (global-set-key (kbd "M-h") 'windmove-left)

  (global-unset-key (kbd "M-k"))
  (global-set-key (kbd "M-k") 'windmove-up)

  (global-unset-key (kbd "M-j"))
  (global-set-key (kbd "M-j") 'windmove-down)

  ;; Window sizing commands
  (global-unset-key (kbd "s-<down>"))
  (global-set-key (kbd "s-<down>") '(lambda()
                                    (interactive)
                                    (shrink-window 2)))

  (global-unset-key (kbd "s-<up>"))
  (global-set-key (kbd "s-<up>") '(lambda()
                                    (interactive)
                                    (enlarge-window 2)))

  (global-unset-key (kbd "s-<right>"))
  (global-set-key (kbd "s-<right>") '(lambda()
                                       (interactive)
                                       (enlarge-window-horizontally 2)))

  (global-unset-key (kbd "s-<left>"))
  (global-set-key (kbd "s-<left>") '(lambda()
                                      (interactive)
                                      (shrink-window-horizontally 2)))

  ;; Start maximised (cross-platf)
  (add-hook 'window-setup-hook 'toggle-frame-maximized t)

  ;; update header line's color every time the buffer is switched
  ;;(add-hook 'buffer-list-update-hook
  ;;          'sd/update-header)

#+END_SRC
* Aliases
#+BEGIN_SRC emacs-lisp
  (defalias 'dbl 'sd/region-delete-blank-lines)
  (defalias 're  'align-regexp)
  (defalias 'sl  'sort-lines)
  (defalias 'n   'narrow-to-defun)
  (defalias 'w   'widen)
  (defalias 'h   'rtags-print-class-hierarchy)
  (defalias 'u   'sd/uncrustify)
#+END_SRC
* Modes
 #+BEGIN_SRC emacs-lisp
   ;; Somehow need to do this first.
   ;; Without this, cannot use :chords
   (use-package use-package-chords
     :ensure t
     :config (key-chord-mode 1))
 #+END_SRC
** ac-rtags
#+BEGIN_SRC emacs-lisp
  ;;(use-package ac-rtags
  ;;    :ensure t)
#+END_SRC
** ace-jump-mode
#+BEGIN_SRC emacs-lisp
  ;; might want to consider switching to ivyy
  (use-package ace-jump-mode
    :disabled
    :ensure t
    :bind (("M-SPC" . ace-jump-word-mode ))
    :init
    ;; disable gray background
    (setq ace-jump-mode-gray-background nil)

    :config
    ;; use this to always push onto the global mark ring
    ;; when jumping
    (add-hook 'ace-jump-mode-before-jump-hook (lambda ()
						(back-button-push-mark-local-and-global)))
    ;; beacon blink after ace-jump
    (add-hook 'ace-jump-mode-end-hook (lambda ()
					(beacon-blink)))
    (custom-set-faces
     '(ace-jump-face-foreground
       ((t (:inherit ace-jump-face-foreground :height 1.0 :foreground "yellow" :background "black" )))))
    )
#+END_SRC
** ace-window
#+BEGIN_SRC emacs-lisp
   (use-package ace-window
     :ensure t
     :init
     (setq aw-background nil)
     (global-set-key (kbd "C-x o") 'ace-window)
     :config
     (custom-set-faces
      '(aw-leading-char-face
        ((t (:inherit ace-jump-face-foreground :height 6.0)))))
     :diminish ace-window-mode)
#+END_SRC
** autocomplete
#+BEGIN_SRC emacs-lisp
  ;; (use-package auto-complete
  ;;   :diminish auto-complete-mode
  ;;   :disabled
  ;;   :ensure t
  ;;   :bind (("C-S-SPC" . auto-complete))
  ;;   :init
  ;;   (ac-config-default)
  ;;   (global-auto-complete-mode t)
  ;;   (setq ac-use-menu-map t)
  ;;   (setq ac-delay 0.1)
  ;;   ;; auto-completion after 2 characters
  ;;   (setq ac-auto-start 2))
#+END_SRC
** auto-complete-c-headers
#+BEGIN_SRC emacs-lisp
  ;; (use-package auto-complete-c-headers
  ;;   :ensure t
  ;;   :disabled)
#+END_SRC
** avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind (("M-SPC" . avy-goto-word-1 ))
    :config
    ;; match all windows in the current frame
    (setq avy-all-windows t)
    ;; yellow on black for matching characters
    (custom-set-faces
     '(avy-lead-face
       ((t (:inherit avy-lead-face :height 1.0 :foreground "yellow" :background "black" ))))))
#+END_SRC
** backbutton
#+BEGIN_SRC emacs-lisp
  (defun sd/pop-global-mark-ring()
    (interactive)
    (back-button-global-backward)
    (setq global-mark-ring (butlast global-mark-ring 1))
    )

  (use-package back-button
    :ensure t
    ;; :bind (("C-," . sd/pop-global-mark-ring )
           ;; )
    :init
    :config
    )
#+END_SRC
** beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :bind (("C-l" . beacon-blink))
    :config
    (beacon-mode 1)
    (setq beacon-blink-when-focused t)
    (setq beacon-color "cyan")
    (setq beacon-size 50)
    (setq beacon-blink-duration 0.6))
#+END_SRC
** cc-mode
#+BEGIN_SRC emacs-lisp
  ;; from https://github.com/philippe-grenet/exordium/blob/master/modules/init-bde-style.el

  ;;; Utility functions and constants

  (defconst exordium-bde-search-max-bound (* 80 25))
  ;;   "Maximum point to search when searching for some regexp/string. Often
  ;; the search is bound to the same line, however sometimes functionality needs to
  ;; account for multi-line definitions. In here we assume 80 (columns) * 25 (lines)
  ;; is enough for everyone.")

  (defun bde-component-name ()
    "Return the name of the component for the current buffer"
    (let ((name (file-name-sans-extension
                 (file-name-nondirectory (buffer-file-name)))))
      (cond ((string-match-p "\\.[gipu]\\.t$" name)
             (substring name 0 (- (length name) 4)))
            ((string-suffix-p ".t" name)
             (substring name 0 (- (length name) 2)))
            (t name))))

  (defun bde-package-name ()
    "Return the name of the package for the current buffer"
    (interactive)
    (let ((component-name (bde-component-name)))
      (substring
       component-name
       0
       (string-match "_" component-name
                     (if (string-prefix-p "s_" component-name)
                         2
                       0)))))

  ;;; Indentation
  ;;;
  ;;; This section define a C style named "bde" using c-add-style.  The offset
  ;;; in the specification (c-offset-alist) can be any of the following:
  ;;;
  ;;; - An integer -> specifies a relative offset. All relative offsets will be
  ;;;   added together and used to calculate the indentation relative to an
  ;;;   anchor position earlier in the buffer.
  ;;; - One of the symbols +, -, ++, --, *, or /
  ;;;   +   = c-basic-offset times 1
  ;;;   -   = c-basic-offset times −1
  ;;;   ++  = c-basic-offset times 2
  ;;;   --  = c-basic-offset times −2
  ;;;   *   = c-basic-offset times 0.5
  ;;;   /   = c-basic-offset times −0.5
  ;;;
  ;;; Note: to debug the indentation of a particular line, type 'C-c C-s'. It
  ;;; will display the variable 'c-syntactic-context' which is a list of the
  ;;; syntactic components affect the offset calculations for that line, with the
  ;;; character position in the buffer for each of them. More details in M-x
  ;;; info, then CC mode, then Interactive Customization.
  ;;; See cc-align.el for examples of line-up functions.

  (eval-when-compile (defvar c-syntactic-context))

  (defun bde-is-member-function-declaration ()
    "Return whether the line ending resembles the member function declaration."
    (re-search-forward
     (concat ") *\\(const\\)?"
             " *\\(noexcept\\|BSLS_CPP11_NOEXCEPT\\)?"
             " *\\(\\(= *\\(0\\|de\\(fault\\|lete\\)\\)\\)"
             "\\|BSLS_CPP11_DE\\(FAULT\\|LETED\\)"
             "\\|override\\|BSLS_CPP11_OVERRIDE\\)?"
             " *\\(&\\(&\\)?\\)?"
             " *; *$")
     (point-at-eol) t))

  (defun bde-comment-offset (element)
    "Custom line-up function for BDE comments.
  Return a symbol for the correct indentation level at the
  current cursor position, if the cursor is within a class definition:
  1. + for method comments:
          int foo() const = 0;
              // tab goes here
          int bar() { return 0; }
              // tab goes here
  2. column number of beginning of comment for data member comments:
          int d_data;     // my comment at whatever column I want
                          // tab goes here
          int d_someLongVariableName;
                          // my comment at whatever column I want
                          // tab goes here
  3. nil otherwise."
    (case (caar c-syntactic-context)
      ((inclass innamespace)
       (save-excursion
         (let ((class-offset         ; extra offset for inner structs
                (c-langelem-col (car c-syntactic-context) t))
               (comment-column nil)) ; column number of last //
           (loop
            (beginning-of-line)
            (cond ((= (point) (point-min))
                   (return nil))
                  ((re-search-forward "^ *//" (point-at-eol) t)
                   ;; looking at a comment line
                   (setq comment-column (- (current-column) 2))
                   (forward-line -1))
                  ((bde-is-member-function-declaration)
                   ;; looking at end of method declaration
                   (return '+))
                  ((re-search-forward "} *$" (point-at-eol) t)
                   ;; looking at end of inline method definition
                   (return '+))
                  ((re-search-forward "; *//" (point-at-eol) t)
                   ;; looking at beginning of data member comment block
                   (return (- (current-column) 2 class-offset c-basic-offset)))
                  ((and comment-column
                        (re-search-forward "[_A-Za-z0-9]+; *$"
                                           (point-at-eol) t))
                   ;; looking at end of (long?) data member declaration
                   (return (- comment-column class-offset c-basic-offset)))
                  (t
                   (return nil)))))))
      (t nil)))

  (defun bde-statement-block-intro-offset (element)
    "Custom line-up function for first line of a statement block.
  The default identation is is '+' (1 basic offset), unless we are in
  a switch statement, in which case the indentation is set to
  '*' (half basic offset). Example:
  switch(val) {
    case 100: {
        return 1;
    } break;
    default: {
        return 0;
    } break;
  }"
    (save-excursion
      (goto-char (c-langelem-pos element))
      (if (looking-at "\\(case\\|default\\)")
          '*
        '+)))

  ;; associate .h file with c++ mode
  (add-to-list 'auto-mode-alist '("\\.[hc]\\'" . c++-mode))

  (use-package cc-mode
    :ensure t
    :bind(
          :map c++-mode-map
               ("C-x i" . sd/find-last-include)
               ("<f1>"  . rtags-display-summary)
               ("M-m"   . rtags-imenu)
               ("C-M-f" . rtags-find-symbol)
               ("C-M-v" . rtags-find-virtuals-at-point))
    :init
    ;; enable electric pair mode for buffers in c-mode
    ;; (add-hook 'c++-mode-hook #'electric-pair-local-mode)
    (setq c-default-style
          '((java-mode . "java")
            (awk-mode  . "awk")
            (c++-mode  . "bde")
            (other     . "gnu")))
    :config
    ;; unbind c++-mode-map keys which interfer with global mappings
    (unbind-key "C-c C-c" c++-mode-map)
    (unbind-key "C-c C-u" c++-mode-map)
    (unbind-key "C-M-h" c++-mode-map)

    ;; trigger company completion via tab
    ;; (define-key c-mode-map [(tab)] 'company-complete)
    ;; (define-key c++-mode-map [(tab)] 'company-complete)

    ;; (add-hook 'c++-mode-hook 'irony-mode)
    ;; (add-hook 'c-mode-hook 'irony-mode)

    ;; See http://cc-mode.sourceforge.net/html-manual/Syntactic-Symbols.html#Syntactic-Symbols
    (c-add-style
     "bde"
     '((c-basic-offset . 4)
       (c-comment-only-line-offset . 0)
       (fill-column . 79)
       (c-backslash-column . 78)
       (c-backslash-max-column . 78)
       (c-offsets-alist
        (comment-intro         . bde-comment-offset)
        (defun-open            . 0)
        (defun-close           . 0)
        (statement-block-intro . bde-statement-block-intro-offset)
        (substatement-open     . 0)
        (substatement-label    . 0)
        (label                 . 0)
        (access-label          . /)
        (case-label            . *)
        (statement-case-intro  . *)
        (statement-case-open   . 0)
        (statement-cont        . +)
        (inline-open           . 0)
        (inline-close          . 0)
        (innamespace           . 0)
        (member-init-intro     . 0)
        (extern-lang-open      . 0)
        (brace-list-entry      . /)
        (extern-lang-close     . 0)))))
#+END_SRC
** ccls
#+BEGIN_SRC emacs-lisp
  (defun ccls//enable ()
    (interactive)
    (condition-case nil
        (lsp-ccls-enable)
      (user-error nil)))

  (use-package ccls
    :ensure t
    :after (lsp-mode)
    :commands lsp-ccls-enable
    :init
    (setq ccls-executable "/usr/local/bin/ccls")
    (setq ccls-cache-dir "/Users/sdayts/workspaces/ccls-cache/.ccls-cache")
    (add-hook 'c-mode-hook #'ccls//enable)
    (add-hook 'c++-mode-hook #'ccls//enable)
    (setq ccls-extra-init-params '(:completion (:detailedLabel t)))
    (setq ccls-extra-args '("--log-file=/Users/sdayts/workspaces/ccls-cache/logs/ccls.log")))
#+END_SRC
** clang-format
#+BEGIN_SRC emacs-lisp
  (use-package clang-format
    :ensure t
    :config)
#+END_SRC
** company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :bind (("C-SPC" . company-complete))
    :config
    (global-company-mode)
    (setq company-idle-delay 0.4)
    (custom-set-faces
     '(company-preview
       ((t (:foreground "cyan" :background "black" :underline t))))
     '(company-preview-common
       ((t (:inherit company-preview))))
     '(company-tooltip
       ((t (:background "black" :foreground "gray"))))
     '(company-tooltip-selection
       ((t (:background "black" :foreground "yellow"))))
     '(company-tooltip-common
       ((((type x)) (:inherit company-tooltip :weight bold))
        (t (:inherit company-tooltip))))
     '(company-tooltip-annotation
       ((t (:background "black" :foreground "darkgray"))))
     '(company-tooltip-common-selection
       ((((type x)) (:inherit company-tooltip-selection :weight bold))
        (t (:inherit company-tooltip-selection)))))

    ;; company-echo
    ;; company-echo-common
    ;; company-preview
    ;; company-preview-common
    ;; company-preview-search
    ;; company-scrollbar-bg
    ;; company-scrollbar-fg
    ;; company-template-field
    ;; company-tooltip
    ;; company-tooltip-annotation
    ;; company-tooltip-annotation-selection
    ;; company-tooltip-common
    ;; company-tooltip-common-selection
    ;; company-tooltip-mouse
    ;; company-tooltip-search
    ;; company-tooltip-search-selection
    ;; company-tooltip-selection
    )
#+END_SRC
** company-lsp
 #+BEGIN_SRC emacs-lisp
   (use-package company-lsp
     :after (lsp-mode company)
     :ensure t
     :init
     (push 'company-lsp company-backends)
     (setq company-transformers nil company-lsp-async t company-lsp-cache-candidates nil))
 #+END_SRC
** company-irony
#+BEGIN_SRC emacs-lisp
  ;; (use-package company-irony
  ;;   :disabled
  ;;   :ensure t
  ;;   :bind (("C-SPC" . company-complete))
  ;;   :init
  ;;   (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
  ;;   (setq company-backends (delete 'company-semantic company-backends))
  ;;   (setq company-backends (delete 'company-clang company-backends))
  ;;   :config
  ;;   (eval-after-load 'company
  ;;   '(add-to-list
  ;;     'company-backends '(company-irony-c-headers company-irony))))
#+END_SRC
** company-irony-c-headers
#+BEGIN_SRC emacs-lisp
  ;; (use-package company-irony-c-headers
  ;;   :disabled
  ;;   :ensure t)
#+END_SRC
** company-posframe
#+BEGIN_SRC emacs-lisp
  (use-package company-posframe
    :after (company)
    :ensure t
    :init
    :config
    (company-posframe-mode 1))
#+END_SRC
** company-rtags
#+BEGIN_SRC emacs-lisp
  (use-package company-rtags
    ;; disable for now, very slow and most importantly doesn't work
    :disabled
    :ensure t
    :config
    (push 'company-rtags company-backends))
#+END_SRC
** corral
#+BEGIN_SRC emacs-lisp
  (use-package corral
    :ensure t
    :bind ( ("M-9" . 'corral-parentheses-backward)
            ("M-0" . 'corral-parentheses-forward)
            ("M-[" . 'corral-brackets-backward)
            ("M-]" . 'corral-brackets-forward)
            ("M-{" . 'corral-braces-backward)
            ("M-}" . 'corral-braces-forward))
      :init
      :config
      (setq corral-preserve-point t))
#+END_SRC
** counsel
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :bind ( ("M-y"     . counsel-yank-pop)
            ("C-S-b"   . counsel-ibuffer)
            ("M-x"     . counsel-M-x)
            ("<f1>"    . counsel-imenu)
            ("M-m"     . counsel-imenu)
            ("C-c C-f" . counsel-find-file)
            ("C-M-r"   . counsel-recentf ))
    :ensure t)
#+END_SRC
** counsel-projectile
#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :ensure t
    :bind (("M-o" . counsel-projectile-find-file))
    :config
    ;; make searches case-insensitive
    (setq counsel-projectile-grep-base-command "grep -irnE %s -- %%s .")
    (setq counsel-find-file-ignore-regexp "ccls-cache"))
#+END_SRC
** diff-mode
#+BEGIN_SRC emacs-lisp
  (use-package diff-mode
    :init
    :config
    (unbind-key "M-h" diff-mode-map)
    (unbind-key "M-j" diff-mode-map)
    (unbind-key "M-k" diff-mode-map)
    (unbind-key "M-l" diff-mode-map))
#+END_SRC
** define-word
#+BEGIN_SRC emacs-lisp
  (use-package define-word
    :ensure t
    :bind (("M-?" . define-word-at-point)))
#+END_SRC
** diminish
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t)
#+END_SRC
** dired
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :after    (helm-swoop)
    :chords (("LL" . dired-jump))
    :bind ( :map dired-mode-map
                 ("C-M-i" . 'counsel-git-grep)
                 ("M-i" . swiper)
                 ;; End/Back key goes up one directory in dired mode
                 ("<end>" . dired-up-directory))
    :init
    ;; unset dired's biding so that the global can take over
    (unbind-key "M-l" dired-mode-map)
    (defun sd/dired-config()
      (require 'dired-x)
      (setq dired-omit-files
            ;; omit files I don't care about
            (concat dired-omit-files "\\|\\.o$\\|\\.d$\\|\\.dd$\\|\\.sundev1.c$\\|\\.mapfile$\\|\\.depends$\\|\\.ibm$\\|\\.sundev1$\\|\\.trap$\\|^llcalc_\\|^00"))
      ;; enable dired omit mode
      (dired-omit-mode t))

    (add-hook 'dired-mode-hook 'sd/dired-config)

    :config
    ;; unset Cntl+Shift+b in dired mode which is by default wants to bookmark a file
    ;; while I like it to bring up the helm-mini
    (local-unset-key (kbd "C-S-b"))
    (setq-local ace-jump-search-filter
                (lambda ()
                  (get-text-property (point) 'dired-filename)))
    ;; subpackages
    (use-package dired-hacks-utils
      :ensure t)
    (use-package dired-narrow
      :ensure t
      :config))
#+END_SRC
** dired+
#+BEGIN_SRC emacs-lisp
  (use-package dired+
    :load-path "~/.emacs.d/local-packages/dired+"
    :config
    (diredp-make-find-file-keys-reuse-dirs)
    ;; set up better colors
    (set-face-attribute 'diredp-flag-mark-line nil :background "black" :foreground "yellow" )
    (set-face-attribute 'diredp-flag-mark nil :background "black" :foreground "green" )
    (set-face-attribute 'diredp-deletion nil :background "black" :foreground "firebrick1" ))
#+END_SRC
** esup
#+BEGIN_SRC emacs-lisp
(use-package esup
  :ensure t)
#+END_SRC
** exordium
Relevant code from exordium, by Philippe Grenet. All the credit is his.
*** init-prefs
#+BEGIN_SRC emacs-lisp
(defcustom exordium-complete-mode :auto-complete
  "Slect the completion engine for exordium. Possible values are
  :auto-complete, :company, and nil. Default is :auto-complete. See also
  `exordium-rtags-auto-complete'."
  :group 'exordium
  :type  'symbol)
;;; RTags

;;; See init-rtags.el
(defcustom exordium-rtags-rdm-args nil
  "Command-line arguments passed to rdm, if needed. This should
be a list of strings."
  :group 'exordium
  :type  'sexp)

(defcustom exordium-rtags-syntax-checker :flymake
  "The syntax checker to be used with rtags. If set to :flycheck the
`flycheck-rtags' will be used. Otherwise, the built-in flymake will be used."
  :group 'exordium
  :type  'symbol)

;;; See init-rtags-cdb.el
(defcustom exordium-rtags-source-file-extensions '("*.cpp" "*.c")
  "List of source file extension patterns for creating a
  compilation database using command
  `rtags-create-compilation-database'. Not needed for CMake projects."
  :group 'exordium
  :type  'sexp)

;;; See init-helm.el
(defcustom exordium-helm-everywhere t
  "Whether Helm should be used as a substitute for common key bindings."
  :group 'exordium
  :type  'boolean)

;;; See init-rtags-helm.el
(defcustom exordium-rtags-helm-everywhere t
  "Whether RTags uses Helm to display list of results, rather
  than its own UI"
  :group 'exordium
  :type  'boolean)

#+END_SRC
*** init-lib
#+BEGIN_SRC emacs-lisp
  ;;;; Init lib
  ;;;
  ;;; This file defines utility functions reused in other modules. It should be
  ;;; loaded before any other module.

  (with-no-warnings (require 'cl))

  
  ;;; Files

  (defun exordium-directory-tree (dir)
    "Returns the list of subdirs of 'dir' excluding any dot
  dirs. Input is a string and output is a list of strings."
    (let* ((dir   (directory-file-name dir))
           (dirs  '())
           (files (directory-files dir nil nil t)))
      (dolist (f files)
        (unless (string-equal "." (substring f 0 1))
          (let ((f (concat dir "/" f)))
            (when (file-directory-p f)
              (setq dirs (append (cons f (exordium-directory-tree f))
                                 dirs))))))
      dirs))

  (defun exordium-read-file-lines (file)
    "Return a list of lines (strings) of the specified file"
    (with-temp-buffer
      (insert-file-contents file)
      (split-string (buffer-string) "\n" t)))

  (defun exordium-read-file-as-string (file)
    "Return the content of the specified file as a string."
    (with-temp-buffer
      (insert-file-contents file)
      (buffer-string)))

  (defun exordium-parent-directory (dir)
    "Return the path of the dir's parent directory"
    (file-name-directory (directory-file-name dir)))

  
  ;;; String manipulation functions

  (require 'subr-x)

  ;; string-prefix-p has been in Emacs for years, but string-suffix-p was
  ;; introduced only in Emacs 24.4.

  (unless (fboundp 'string-suffix-p)
    (defun string-suffix-p (suffix string  &optional ignore-case)
      "Return non-nil if SUFFIX is a suffix of STRING.
  If IGNORE-CASE is non-nil, the comparison is done without paying
  attention to case differences."
      (let ((start-pos (- (length string) (length suffix))))
        (and (>= start-pos 0)
             (eq t (compare-strings suffix nil nil
                                    string start-pos nil ignore-case))))))

  ;; Other string functions introduced in Emacs 24.4:

  (unless (fboundp 'string-trim-left)
    (defsubst string-trim-left (string)
      "Remove leading whitespace from STRING."
      (if (string-match "\\`[ \t\n\r]+" string)
          (replace-match "" t t string)
        string)))

  (unless (fboundp 'string-trim-right)
    (defsubst string-trim-right (string)
      "Remove trailing whitespace from STRING."
      (if (string-match "[ \t\n\r]+\\'" string)
          (replace-match "" t t string)
        string)))

  (unless (fboundp 'string-trim)
    (defsubst string-trim (string)
      "Remove leading and trailing whitespace from STRING."
      (string-trim-left (string-trim-right string))))

  (defun string-truncate (string n)
    "Return STRING minus the last N characters."
    (substring string 0 (max 0(- (length string) n))))

  
  ;;; Add backtick to electric pair mode. It makes buffer local variable with
  ;;; an extra back tick added
  (defun exordium-electric-mode-add-back-tick ()
    (when exordium-enable-electric-pair-mode
      (setq-local electric-pair-pairs
                  (append electric-pair-pairs '((?` . ?`))))
      (setq-local electric-pair-text-pairs
                  (append electric-pair-text-pairs '((?` . ?`))))))
#+END_SRC
*** init-rtags
#+BEGIN_SRC emacs-lisp
    ;;;; Rtags - see `https://github.com/Andersbakken/rtags'
    ;;;
    ;;; Rtags keys use prefix C-c r
    ;;; ---------- ----------------------------------------------------------------
    ;;; Key        Function
    ;;; ---------- ----------------------------------------------------------------
    ;;; C-c r .    `rtags-find-symbol-at-point'
    ;;; M-.
    ;;; C-c r ,    `rtags-find-references-at-point'
    ;;; M-,
    ;;;
    ;;; C-c r >    `rtags-find-symbol' (prompts for symbol name)
    ;;; C-c r <    `rtags-find-references' (prompts for symbol name)
    ;;;
    ;;; M-C-g      List all buffer symbols with Helm
    ;;;
    ;;; ---------- ----------------------------------------------------------------
    ;;; C-c r v    `rtags-find-virtuals-at-point' list all impl. of function
    ;;; C-c r ;    `rtags-find-file' find file in project using partial name
    ;;;
    ;;; C-c r R    `rtags-rename-symbol'
    ;;; C-c r F    `rtags-fixit' fix the error using clang "did you mean".
    ;;;
    ;;; C-c r [    `rtags-location-stack-back' go back to previous location
    ;;; C-{
    ;;; C-c r ]    `rtags-location-stack-forward' the opposite
    ;;; C-}
    ;;;
    ;;; ---------- ----------------------------------------------------------------
    ;;;            `rtags-start': start rdm in a subprocess and start RTags
    ;;;            diagnostics.
    ;;;            `rtags-stop': kill rdm subprocess and RTags diagnostics.
    ;;; C-c r l    `rtags-show-rdm-buffer' show rdm log buffer.
    ;;;            `rtags-set-current-project' switch between projects
    ;;; C-c r e    `rtags-reparse-file' force recompile current buffer.
    ;;;
    ;;; ---------- ----------------------------------------------------------------
    ;;; C-c r D    `rtags-diagnostics' start diagnostics/force reparse
    ;;; C-c r Q    `rtags-stop-diagnostics' stop the diagnostic subprocess
    ;;; C-c r d    `rtags-show-diagnostics-buffer' toggle diag window
    ;;;            (without reparsing)
    ;;; C-c r down `rtags-next-diag' goes to the next problem.
    ;;; C-c r up   `rtags-previous-diag' goes to previous problem.
    ;;; C-c r c    `rtags-clear-diagnostics' clears any error or warning overlay.
    ;;;            `rtags-stop-diagnostics' stops the process.
    ;;;
    ;;; ---------- ----------------------------------------------------------------
    ;;; C-c r U    `rtags-print-cursorinfo' show what we know about symbol
    ;;; C-c r P    `rtags-print-dependencies' show all includes
    ;;; C-c r T    `rtags-taglist' show all tags in a window on left side
    ;;;
    ;;;
    ;;; Building rtags
    ;;; ==============
    ;;; $ git clone https://github.com/Andersbakken/rtags.git
    ;;; $ cd rtags
    ;;; $ git submodule init && git submodule update
    ;;; $ cmake .
    ;;; $ make
    ;;;
    ;;; Files
    ;;; =====
    ;;; Rtags uses the following files:
    ;;; `~/.rtags' (created automatically)
    ;;;     Where rdm stores its index files. They are reloaded when it restarts.
    ;;; `~/.rdmrc' (optional)
    ;;;     Config file for rdm (see rdm.cpp) containing default command line args.
    ;;; `.rtags-config' (optional, located in project root dir)
    ;;;     Project configuration file. Not needed if there is a .git or .svn at
    ;;;     the project root.
    ;;; `compile_commands.json' (optional, located in project root dir)
    ;;;     Compilation database for a given project, containing for each file the
    ;;;     clang command to build it. Not needed if you use RTags's compiler
    ;;;     wrapper scripts.
    ;;;
    ;;; Running rdm in a shell
    ;;; ======================
    ;;; Run `rdm' in a shell or in the background. Use -L to specify a log file.
    ;;; Use --help for the list of options. You can stop it gracefully with: rc -q
    ;;;
    ;;; You can control rdm with the rc client (use --help to see all options):
    ;;; $ rc -w
    ;;;     List the loaded projects and show the active one.
    ;;; $ rc -w proj
    ;;;     Make "proj" the active project ("proj" is a regex).
    ;;; $ rc -J
    ;;;     Reload the compilation DB from the current directory.
    ;;; $ rc -W proj
    ;;;     Delete project.
    ;;; $ rc --find-project-root /path/to/sourcefile.cpp
    ;;;     Print what it determines to be the correct project root.
    ;;; $ rc -T sourcefile.cpp
    ;;;     Say wether this component is indexed or not.
    ;;; $ rc -q
    ;;;     Shutdown rdm.
    ;;;
    ;;; Running rdm in Emacs
    ;;; ====================
    ;;; M-x `rtags-start'. A buffer will be created with rdm logs; you can show
    ;;; it with "C-c r l".
    ;;; M-x `rtags-stop' to kill it.
    ;;;
    ;;; Setting up a new project
    ;;; ========================
    ;;; 1. If the project root dir does not contain a .git or .svn repo, create a
    ;;;    file `.rtags-config' in the root dir with the specified content:
    ;;;    project: /path/to/project
    ;;;
    ;;; 2. The next step is to create the compilation database
    ;;;    `compile_commands.json'. For that, use CMake or use module
    ;;;     init-rtags-cdb.el.
    ;;;
    ;;; Diagnostics mode
    ;;; ================
    ;;; RTags diagnostics is a subprocess that highlight compilation errors and
    ;;; warnings in the code (using flymake or flycheck). Click on a highlighted
    ;;; region to view the error message. Use "C-c r d" (lowercase d) to display
    ;;; the diagnostics buffer containing the error messages without forcing a
    ;;; reparsing of the current file.
    ;;;
    ;;; It is started by default, but you can control it with:
    ;;; - "C-c r D" or M-x `rtags-diagnostics' to start,
    ;;; - "C-c r q" or M-x `rtags-stop-diagnostics' to terminate the subprocess.

    (with-no-warnings (require 'cl))
    (require 'rtags)
    ;;(require 'ac-rtags)
    ;;(require 'auto-complete-c-headers)
    (require 'projectile)

    
    ;;; Turn on flycheck support when requested
    (when (eq exordium-rtags-syntax-checker :flycheck)
      (require 'flycheck-rtags)
      ;; As per: https://github.com/Andersbakken/rtags#rtags-flycheck-integration
      (cl-flet ((flycheck-rtags-hook ()
                                     (flycheck-select-checker 'rtags)
                                     (setq-local flycheck-highlighting-mode nil)
                                     (setq-local flycheck-check-syntax-automatically nil)))
        (add-hook 'c-mode-hook #'flycheck-rtags-hook)
        (add-hook 'c++-mode-hook #'flycheck-rtags-hook)
        (add-hook 'objc-mode-hook #'flycheck-rtags-hook)))

    ;;; Key bindings

    ;; Enable default keys from rtags with prefix "Ctrl-C r"".
    ;; The default prefix is "Ctrl-x r" but almost all keys are bound;
    ;; "Ctrl-c r" is not defined by default, so we get the whole keyboard.
    (rtags-enable-standard-keybindings c-mode-base-map "\C-cr")


  (defun sd/rtags-find-symbol-at-point(other-window)
    "Customized version of rtags-find-symbol-at-point"
    (interactive "P")
    (let ((rtags-after-find-file-hook rtags-after-find-file-hook))
      (add-hook 'rtags-after-find-file-hook #'(lambda ()
                                                (recenter)))
      (rtags-find-symbol-at-point other-window)))

    ;; Alias for C-c r [
    (define-key c-mode-base-map [(control c) (r) (left)] (function rtags-location-stack-back))
    ;; Alias for C-c r [
    (define-key c-mode-base-map [(control c) (r) (right)] (function rtags-location-stack-forward))

    (define-key c-mode-base-map [(meta control g)] (function rtags-imenu))

    (define-key c-mode-base-map [(control c) (r) (down)] (function rtags-next-diag))
    (define-key c-mode-base-map [(control c) (r) (up)] (function rtags-previous-diag))
    (define-key c-mode-base-map [(control c) (r) (c)] (function rtags-clear-diagnostics))

    (define-key c-mode-base-map "\C-crQ" (function rtags-stop-diagnostics))

    
    ;;; Start rdm as a subprocess, with output in a buffer

    (defun exordium-rtags-start-rdm-maybe ()
      "Start rdm if not already running. Return t if started and nil
    otherwise."
      (unless (exordium-rtags-rdm-running-p)
        (exordium-rtags-start-rdm-impl nil)
        t))

    (defun exordium-rtags-rdm-running-p ()
      "Predicate testing if rdm is running"
      (let ((process (get-process "rdm")))
        (or
         ;; Rdm runs in a process started from Emacs
         (and (processp process)
              (not (eq (process-status process) 'exit))
              (not (eq (process-status process) 'signal)))
         ;; User has started rdm outside of Emacs
         ;; Note: sadly this does not work on macOS
         (let ((uuid (user-uid)))
           (dolist (pid (reverse (list-system-processes)))
             (let* ((attrs (process-attributes pid))
                    (pname (cdr (assoc 'comm attrs)))
                    (puid  (cdr (assoc 'euid attrs))))
               (when (and (eq puid uuid)
                          (string= pname "rdm"))
                  (return t))))))))

    (defun exordium-rtags-start-rdm-impl (&optional open-buffer)
      "Start rdm in a subprocess. Open the rdm log buffer if
    open-buffer is true."
      (let ((buffer (get-buffer-create "*RTags rdm*")))
        (when open-buffer
          (switch-to-buffer buffer))
        (with-current-buffer buffer
          (rtags-rdm-mode)
          (read-only-mode))
        (let ((process
               (apply #'start-process "rdm" buffer "rdm" exordium-rtags-rdm-args)))
          (message "Started rdm - PID %d" (process-id process))))
      ;; Add RTags to company backends
      (when (and (eq exordium-complete-mode :company)
                 (not (member 'company-rtags company-backends)))
        (push 'company-rtags company-backends)))

    (defun rtags-start ()
      "Start the rdm deamon in a subprocess and display output in a
    buffer. Also start the RTag diagostics mode."
      (interactive)
      (setq rtags-autostart-diagnostics t)
      (exordium-rtags-start-rdm-impl t))

    (defun rtags-stop ()
      "Stop both RTags diagnostics and rdm, if they are running."
      (interactive)
      ;; Remove RTags from company backends
      (when (and (eq exordium-complete-mode :company)
                 (member 'company-rtags company-backends))
        (setq company-backends (delete 'company-rtags company-backends)))
      ;; Stop RTags Diagnostics and kill its buffer without prompt
      (when (and rtags-diagnostics-process
                 (not (eq (process-status rtags-diagnostics-process) 'exit)))
        (kill-process rtags-diagnostics-process))
      (when (get-buffer "*RTags Diagnostics*")
        (let ((kill-buffer-query-functions nil))
          (kill-buffer "*RTags Diagnostics*")))
      ;; Stop rdm and kill its buffer without prompt
      (rtags-quit-rdm)
      (when (get-buffer "*RTags rdm*")
        (let ((kill-buffer-query-functions nil))
          (kill-buffer "*RTags rdm*"))))

    (defun rtags-show-rdm-buffer ()
      "Show/hide the rdm log buffer"
      (interactive)
      (let* ((buffer-name "*RTags rdm*")
             (buffer (get-buffer buffer-name))
             (window (and buffer (get-buffer-window buffer))))
        (cond (window
               (bury-buffer buffer)
               (delete-window window))
              (buffer
               (display-buffer buffer))
              (t
               (message "Rtags rdm is not running (use M-x rtags-start)")))))

    (define-key c-mode-base-map [(control c)(r)(l)] 'rtags-show-rdm-buffer)

    
    ;;; Mode for rdm log output
    ;;; See http://ergoemacs.org/emacs/elisp_syntax_coloring.html

    (defsubst rtags-rdm-record-search-forward (&optional regexp bound)
      "Search forward from point for a log line matching REGEXP.
    Set point to the end of the occurrence found, and return point.
    An optional second argument BOUND bounds the search: the match
    found must not extend after that position. This function also
    sets `match-data' to the entire match."
      (let ((org-pos (point)))
        (block while-loop
          ;; While there are more matches for REGEXP
          (while (re-search-forward regexp bound t)
            (if (re-search-backward "^" org-pos t)
                (let ((begin-pos (point)))
                  ;; If we found a matching log line, set match data and return
                  (if (re-search-forward "$" bound t)
                      (progn
                        (set-match-data (list begin-pos (point)))
                        (return-from while-loop (point)))
                    (return-from while-loop))))))))

    (defun rtags-rdm-match-record-error (bound)
      "Search forward from point to BOUND for error."
      (rtags-rdm-record-search-forward "\\(error:\\)" bound))

    (defun rtags-rdm-match-record-warning (bound)
      "Search forward from point to BOUND for warning."
      (rtags-rdm-record-search-forward "\\(warning:\\)" bound))

    (defun rtags-rdm-match-record-note (bound)
      "Search forward from point to BOUND for note."
      (rtags-rdm-record-search-forward "\\(note:\\)" bound))

    (defun rtags-rdm-match-record-done (bound)
      "Search forward from point to BOUND for Jobs."
      (rtags-rdm-record-search-forward "\\(Jobs\\)" bound))

    (defconst rtags-rdm-mode-keywords
      (list '(rtags-rdm-match-record-error 0 'compilation-error)
            '(rtags-rdm-match-record-warning 0 'compilation-warning)
            '(rtags-rdm-match-record-note 0 'compilation-info)
            '(rtags-rdm-match-record-done 0 'underline))
      "Describes how to syntax highlight keywords in rtags-rdm-mode.")

    (defconst rtags-rdm-mode-syntax-table
      ;; Defines a "comment" as anything that starts with a square bracket, e.g.
      ;; [100%] /path/to/file.cpp in 437ms. (1259 syms, etc) (dirty)
      (let ((synTable (make-syntax-table)))
        (modify-syntax-entry ?\[ "< b" synTable)
        (modify-syntax-entry ?\n "> b" synTable)
        synTable))

    (define-derived-mode rtags-rdm-mode fundamental-mode
      "rdm-log"
      "Mode for viewing rdm logs"
      :syntax-table rtags-rdm-mode-syntax-table
      ;; Syntax highlighting:
      (setq font-lock-defaults '(rtags-rdm-mode-keywords t t)))

    
    ;;; Using the diagnostics buffer

    (defun rtags-show-diagnostics-buffer ()
      "Show/hide the diagnostics buffer in a dedicated
    window (similar to `rtags-diagnostics' but without reparsing)."
      (interactive)
      (if (rtags-has-diagnostics)
          (let* ((buffer-name "*RTags Diagnostics*")
                 (buffer (get-buffer buffer-name))
                 (window (get-buffer-window buffer)))
            (cond (window
                   (bury-buffer buffer)
                   (delete-window window))
                  (buffer
                   (display-buffer buffer-name)
                   (other-window 1)
                   (goto-char (point-min))
                   (fit-window-to-buffer (get-buffer-window (current-buffer)) 10 2)
                   (set-window-dedicated-p (get-buffer-window (current-buffer)) t)
                   (other-window -1))))
        (message "Rtags diagnostics is not running (use C-c r D)")))

    (define-key c-mode-base-map [(control c)(r)(d)] 'rtags-show-diagnostics-buffer)

    ;; Used in powerline:
    (defun rtags-diagnostics-has-errors ()
      "Return t or nil depending if RTags diagnostics displays errors"
      (let ((diag-buff (get-buffer "*RTags Diagnostics*")))
        (if (and diag-buff
                 rtags-diagnostics-process
                 (not (eq (process-status rtags-diagnostics-process) 'exit))
                 (not (eq (process-status rtags-diagnostics-process) 'signal)))
            (> (buffer-size diag-buff) 0)
          nil)))

    
    ;;; RTags auto-complete (EXPERIMENTAL)
    ;;; FIXME: this is broken, need to revisit the whole thing.

    ;;; AC source for #include

    ;;; The following function fixes a bug in achead:documentation-for-candidate
    (defun my-documentation-for-candidate (candidate)
      "Generate documentation for a candidate `candidate'. For now,
    just returns the path and content of the header file which
    `candidate' specifies."
      (let ((path
             (assoc-default candidate achead:ac-latest-results-alist 'string=)))
        (ignore-errors
          (with-temp-buffer
            (insert path)
            (unless (file-directory-p path)
              (insert "\n--------------------------\n")
              (insert-file-contents path nil 0 200)) ;; first 200 content bytes
            (buffer-string)))))

    ;;(ac-define-source my-c-headers
    ;;  `((init       . (setq achead:include-cache nil))
    ;;    (candidates . achead:ac-candidates)
    ;;    (prefix     . ,achead:ac-prefix)
    ;;    (document   . my-documentation-for-candidate)
    ;;    (requires   . 0)
    ;;    (symbol     . "h")
    ;;    (action     . ac-start)
    ;;    (limit      . nil)))

    ;;; AC source for RTags

    ;;(defun ac-rtags-init ()
    ;;  (unless rtags-diagnostics-process
    ;;    (rtags-diagnostics)))

    ;;(ac-define-source my-rtags
    ;;  '((init       . rtags-ac-init)
    ;;    (prefix     . rtags-ac-prefix)
    ;;    (candidates . rtags-ac-candidates)
    ;;    (action     . rtags-ac-action)
    ;;    (document   . rtags-ac-document)
    ;;    (requires   . 0)
    ;;    (symbol     . "r")))

    ;;; Functions to enable auto-complete

    ;;(defun rtags-auto-complete ()
    ;;  "Enables auto-complete with RTags.
    ;;Note that RTags becomes the only source for auto-complete in all
    ;;C and C++ buffers. Also note that RTags Diagostics must be turned
    ;;on."
    ;;  (interactive)
    ;;  ;;(require 'ac-rtags)
    ;;  (setq rtags-completions-enabled t)
    ;;  (add-hook 'c++-mode-hook
    ;;            (lambda ()
    ;;              (setq ac-sources '(ac-source-my-rtags)))))

    ;;(defun rtags-diagnostics-auto-complete ()
    ;;  "Starts diagnostics and auto-complete with RTags and #includes.
    ;;Note that this function replaces all other sources of auto-complete
    ;; for C++ files. Any previously opened C++ file needs to be reopen
    ;;for this to be effective."
    ;;  (interactive)
    ;;  ;; Require
    ;;  ;; Start RTags diagnostics
    ;;  (unless rtags-diagnostics-process
    ;;    (rtags-diagnostics))
    ;;  ;; FIXME: this is broken, should not depend on compile_includes
    ;;  ;; Create an auto-complete source for headers using compile_includes
    ;;  ;; (let ((plist (rtags-load-compile-includes-file (projectile-project-root))))
    ;;  ;;   (dolist (dir (plist-get plist :src-dirs))
    ;;  ;;     (add-to-list 'achead:include-directories dir))
    ;;  ;;   (dolist (dir (plist-get plist :include-dirs))
    ;;  ;;     (add-to-list 'achead:include-directories dir)))
    ;;  ;; Turn on RTags auto-complete
    ;;  (setq rtags-completions-enabled t)
    ;;  (add-hook 'c++-mode-hook
    ;;            (lambda ()
    ;;              (setq ac-sources '(ac-source-my-rtags
    ;;                                 ;;ac-source-my-c-headers
    ;;                                 )))))

    ;;(define-key c-mode-base-map [(control c)(r)(A)]
    ;;  'rtags-diagnostics-auto-complete)

    
    ;; Local Variables:
    ;; byte-compile-warnings: (not cl-functions)
    ;; End:
#+END_SRC
*** init-rtags-cdb
#+BEGIN_SRC emacs-lisp
;;;; Command to create a compilation database.
;;;
;;; ---------- ----------------------------------------------------------------
;;; Key        Command
;;; ---------- ----------------------------------------------------------------
;;;            `rtags-create-compilation-database': see doc below.
;;; ---------- ----------------------------------------------------------------
;;;
;;; This module provides a single command, `rtags-create-compilation-database',
;;; which is an easy way to generate a CLang compilation database
;;; (`compile_commands.json') for non-CMake projects.
;;;
;;; The first step is to create a file `compile_includes' in the project root
;;; dir, which specifies how to compile your project and in particular where
;;; are all the source files and all the include files. For example:
;;;
;;;   # Where are the source files (there could be multiple directories).
;;;   # We will scan recursively any subdirectories that do not match any
;;;   # 'exclude' regex.
;;;   src .
;;;
;;;   # What to put in -I directives (in addition to the source files above).
;;;   # We will scan recursively any subdirectories that do not match any
;;;   # 'exclude' regex.
;;;   include /Users/phil/Code/cpp/include/bsl
;;;   include /Users/phil/Code/cpp/include/bdl
;;;
;;;   # Optional: patterns to exclude in -I directives and for looking for
;;;   # sources:
;;;   exclude /test$
;;;   exclude /doc$
;;;   exclude /group$
;;;   exclude /package$
;;;
;;;   # Optional: if any file name pattern must be excluded from the "src" files,
;;;   # use the "excludesrc" directive. For example this will exclude all test
;;;   # drivers:
;;;   excludesrc \.t\.cpp$
;;;
;;; In addition, the creation of a compilation database uses these variables:
;;;
;;; - `rtags-compile-includes-base-dir': set this to your workspace path
;;;   if you want to use relative paths in `compile_includes' (by default any
;;;   relative path in this file is relative to the project root dir).
;;; - `rtags-clang-command-prefix': default is "/usr/bin/clang++ -Irelative"
;;;   (Note that rtags ignores the clang++ command because it uses libclang).
;;; - `rtags-clang-command-suffix': default is "-c -o".
;;;
;;; Once you have created the `compile_includes' file, run the command
;;; M-x `rtags-create-compilation-database'. It will:
;;;
;;; - Prompt for the project root dir
;;; - Scan all source dirs and include dirs
;;; - Create `compilation_database.json' (it overwrites without asking)
;;; - Ask if you want to reload it (if rdm is running).

(with-no-warnings (require 'cl))

;; Override these variables in your .emacs as needed:

(defvar rtags-clang-command-prefix
  "/usr/bin/clang++ "
  "Compilation command prefix to use for creating compilation
  databases. Override this variable for your local environment.")

(defvar rtags-clang-command-suffix
  " -c -o "
  "Compilation command suffix to use for creating compilation
  databases. Override this variable for you local environment.")

(defvar rtags-compile-includes-base-dir
  nil
  "If non-nil, base directory to use for all relative paths in
  `compile_include'. Use nil for absolute paths.")


;;; Creating a compilation DB

(defun rtags-load-compile-includes-file-content (compile-includes-file)
  "Read and parse the specified compile-includes file, and return
a list of five sublists:
- The list of `src' directives,
- The list of `include' directives,
- The list of `exclude' directives,
- The list of `excludesrc' directives,
- The list of `macro' directives."
  (let ((line-number      1)
        (value            nil)
        (src-list         ())
        (include-list     ())
        (exclude-list     ())
        (exclude-src-list ())
        (macro-list       ()))
    (dolist (record (exordium-read-file-lines compile-includes-file))
      (incf line-number)
      (setq value (second (split-string record " ")))
      (cond ((or (eq "" record)
                 (string-prefix-p "#" record))
             ;; Comment or empty string; skip it
             nil)
            ((string-prefix-p "src" record)
             (when value
               (setq src-list (cons value src-list))))
            ((string-prefix-p "include" record)
             (when value
               (setq include-list (cons value include-list))))
            ((string-prefix-p "excludesrc" record)
             (when value
               (setq exclude-src-list (cons value exclude-src-list))))
            ((string-prefix-p "exclude" record)
             (when value
               (setq exclude-list (cons value exclude-list))))
            ((string-prefix-p "macro" record)
             (when value
               (setq macro-list (cons value macro-list))))
            (t
             (error "Syntax error line %d: %s" line-number record))))
    (list src-list include-list exclude-list exclude-src-list macro-list)))

(defun rtags-is-excluded-p (path excluded-regexs)
  "Return non-nil if the specified path matches any regex in
the list of excluded regexs"
  (catch 'return
    (dolist (excluded excluded-regexs)
      (when (string-match excluded path)
        (throw 'return t)))
    (throw 'return nil)))

(defun rtags-directory-contains-sources-p (path)
  "Return non-nil if the specified path contains any C/C++ source
  or header file"
  (directory-files path nil ".*\\.\\(c\\|cpp\\|h\\|hpp\\)$" nil))

(defun rtags-scan-subdirectories (dir excluded-regexs)
  "Return a list of subdirectories under the specified root dir,
excluding any that match any regex in the specified excluded
regex list."
  (let ((result ()))
    (dolist (subdir (cons dir (exordium-directory-tree dir)))
      (when (and (rtags-directory-contains-sources-p subdir)
                 (not (rtags-is-excluded-p subdir excluded-regexs)))
        (setq result (cons subdir result))))
    result))

(defun rtags-load-compile-includes-file (dir)
  "Loads the `compile_includes' file from the specified directory
and returns its content as a property list, or nil if the file
could not be loaded. The property list looks like this:
'(:src-dirs (...)
  :include-dirs (...)
  :exclude-src (...)
  :macros (...))"
  (let ((compile-includes-file (concat (file-name-as-directory dir)
                                       "compile_includes")))
    (cond ((file-exists-p compile-includes-file)
           ;; Parse the file and return 3 lists: src, include, exclude
           (let ((directives (rtags-load-compile-includes-file-content
                              compile-includes-file)))
             (let ((src-dirs    (first directives))
                   (incl-dirs   (second directives))
                   (excl-regexs (third directives))
                   (excl-src    (fourth directives))
                   (macros      (fifth directives))
                   (result      ()))
               ;; Scan src to get all subdirs that do not match the excludes
               (let (dirs)
                 (dolist (path src-dirs)
                   (unless (file-name-absolute-p path)
                     (setq path (expand-file-name path
                                                  (or rtags-compile-includes-base-dir
                                                      dir))))
                   (message "Scanning source dir: %s ..." path)
                   (setq dirs (nconc dirs (rtags-scan-subdirectories path excl-regexs))))
                 (setq result (list :src-dirs dirs)))
               ;; Same with includes
               (let (dirs)
                 (dolist (path incl-dirs)
                   (setq path (expand-file-name path rtags-compile-includes-base-dir))
                   (message "Scanning include dir: %s ..." path)
                   (setq dirs (nconc dirs (rtags-scan-subdirectories path excl-regexs))))
                 (setq result (nconc result (list :include-dirs dirs))))
               ;; Add exclude-src and macros into the result
               (setq result (nconc result (list :exclude-src excl-src
                                                :macros macros)))
               ;; Done
               (message "Project has %d source dirs and %d include dirs"
                        (length (plist-get result :src-dirs))
                        (length (plist-get result :include-dirs)))
               result)))
          (t
           (message "No compilation_includes file")
           nil))))

(defun rtags-create-compilation-command (plist)
  "Returns a string containing the clang compilation command to
use for the compilation database, using the content of PLIST."
  (let ((command rtags-clang-command-prefix))
    ;; -D options:
    (dolist (m (plist-get plist :macros))
      (setq command (concat command " -D" m)))
    ;; -I options
    (dolist (path (plist-get plist :src-dirs))
      (setq command (concat command " -I" path)))
    (dolist (path (plist-get plist :include-dirs))
      (setq command (concat command " -I" path)))
    (concat command rtags-clang-command-suffix)))

(defun rtags-prompt-compilation-database-dir ()
  "Prompts the user for the directory where to generate the
compilation database. If we're in a projectile project, propose
the project root first, and prompt for a dir if the user
declines. Returns the directory string."
  (let ((project-root (and (featurep 'projectile)
                           (projectile-project-root))))
    (if (and project-root
             (y-or-n-p (format "Create at project root (%s)?" project-root)))
        project-root
      (read-directory-name "Project root: "))))

(defun rtags-create-compilation-database (dir)
  "Regenerates `compile_commands.json' from `compile_includes' in
the specified directory."
  (interactive (list (rtags-prompt-compilation-database-dir)))
  (let ((plist (rtags-load-compile-includes-file dir)))
    (when plist
      (let ((dbfilename (concat (file-name-as-directory dir)
                                "compile_commands.json"))
            (compile-command (rtags-create-compilation-command plist))
            (exclude-files (plist-get plist :exclude-src))
            (num-files 0))
        (with-temp-buffer
          (insert "[")
          (newline)
          ;; Note: dynamic binding of variable default-directory
          (dolist (default-directory (plist-get plist :src-dirs))
            (message "Processing directory: %s ..." default-directory)
            (let ((files (mapcan #'file-expand-wildcards
                                 exordium-rtags-source-file-extensions))
                  ;; rdm does not like directories starting with "~/"
                  (dirname (if (string-prefix-p "~/" default-directory)
                               (substitute-in-file-name
                                (concat "$HOME/" (substring default-directory 2)))
                             default-directory)))
              (dolist (file files)
                (unless (rtags-is-excluded-p file exclude-files)
                  (incf num-files)
                  (insert "  { \"directory\": \"" dirname "\",")
                  (newline)
                  (insert "    \"command\":   \""
                          compile-command
                          (file-name-sans-extension file) ".o "
                          file "\",")
                  (newline)
                  (insert "    \"file\":      \"" file "\" },")
                  (newline)))))
          (insert "];")
          (newline)
          (write-region (buffer-string) nil dbfilename))
        (when (yes-or-no-p
               (format "Wrote compile_commands.json (%d files). Reload it?" num-files))
          ;; FIXME: rtags-call-rc does not work if you don't specify a current buffer?
          ;; That seems broken.
          (rtags-call-rc :path t :output nil :unsaved (current-buffer) "-J" dir)
          (message "Reloaded (check rdm's logs)"))))))


;;; Mode for compile_includes files

(defconst rtags-compile-includes-mode-keywords
  ;; Words and associated face.
  `(( "\\(^src\\|^include\\|^excludesrc\\|^exclude\\|^macro\\)"
     . font-lock-keyword-face)))

(defconst rtags-compile-includes-mode-syntax-table
  ;; Defines a "comment" as anything that starts with hash tag
  (let ((synTable (make-syntax-table)))
    (modify-syntax-entry ?\# "< b" synTable)
    (modify-syntax-entry ?\n "> b" synTable)
    synTable))

(define-derived-mode rtags-compile-includes-mode fundamental-mode
  "compile-includes"
  "Mode for editing compile_includes files"
  :syntax-table rtags-compile-includes-mode-syntax-table
  ;; Syntax highlighting:
  (setq font-lock-defaults '((rtags-compile-includes-mode-keywords))))

(add-to-list 'auto-mode-alist
             '("compile_includes" . rtags-compile-includes-mode))
#+END_SRC
*** init-rtags-helm
#+BEGIN_SRC emacs-lisp
  ;;;; RTags and Helm integration
  ;;;
  ;;; -------------- -------------------------------------------------------
  ;;; Key            Definition
  ;;; -------------- -------------------------------------------------------
  ;;; M-C-g          `rtags-helm-select-taglist' = select a symbol in the
  ;;;                current file using Helm.
  ;;; C-c r r        `helm-flycheck' show rtags errors in helm buffer
  ;;; -------------- -------------------------------------------------------

  (when (eq exordium-rtags-syntax-checker :flycheck)
    (require 'helm-flycheck)
    (define-key c-mode-base-map
      (kbd "C-c r r")
      (lambda ()
        (interactive)
        (unless flycheck-mode
          (flycheck-mode)
          (diminish 'flycheck-mode))
        (helm-flycheck))))

  (defcustom rtags-helm-show-variables nil
    "Whether `rtags-helm-select-taglist' shows variables and parameters"
    :group 'rtags
    :type 'boolean)

  (defcustom rtags-helm-show-enums nil
    "Whether `rtags-helm-select-taglist' shows enums"
    :group 'rtags
    :type 'boolean)

  (when (or exordium-helm-everywhere exordium-rtags-helm-everywhere)
    (setq rtags-helm-show-variables t)
    (setq rtags-helm-show-enums t)
    (setq rtags-use-helm t))

  (defun rtags-helm-sort-list (pairs)
    (sort pairs #'(lambda (p1 p2) (< (cdr p1) (cdr p2)))))

  (defun rtags-helm-jump-to-line (line)
    ;;Compiler-happy equivalent of (goto-line line):
    (goto-char (point-min))
    (forward-line (1- line))
    (recenter))

  (defun rtags-helm-propertize-function (text)
    "Return a colored string for a method, constructor or function declaration"
    (cond ((string-match "^\\(.*\\) \\(.*\\)::\\(.*\\)$" text)
           (let ((return-type (match-string-no-properties 1 text))
                 (class (match-string-no-properties 2 text))
                 (method (match-string-no-properties 3 text)))
             (format "%s %s::%s"
                     (propertize return-type 'face 'font-lock-type-face)
                     (propertize class 'face 'font-lock-constant-face)
                     (propertize method 'face 'font-lock-function-name-face))))
          ((string-match "^\\(.*\\)::\\(.*\\)$" text)
           (let ((class (match-string-no-properties 1 text))
                 (ctor (match-string-no-properties 2 text)))
             (format "%s::%s"
                     (propertize class 'face 'font-lock-constant-face)
                     (propertize ctor 'face 'font-lock-function-name-face))))
          ((string-match "^\\(.*\\) \\(.*\\)$" text)
           (let ((return-type (match-string-no-properties 1 text))
                 (function (match-string-no-properties 2 text)))
             (format "%s %s"
                     (propertize return-type 'face 'font-lock-type-face)
                     (propertize function 'face 'font-lock-function-name-face))))
          (t text)))

  (defun rtags-helm-propertize-variable (text)
    "Return a colored string for a variable declaration"
    (cond ((string-match "^const \\(.*\\) \\(.*\\)$" text)
           (let ((type (match-string-no-properties 1 text))
                 (var (match-string-no-properties 2 text)))
             (format "%s %s %s"
                     (propertize "const" 'face 'font-lock-keyword-face)
                     (propertize type 'face 'font-lock-type-face)
                     var)))
          ((string-match "^\\(.*\\) \\(.*\\)$" text)
           (let ((type (match-string-no-properties 1 text))
                 (var (match-string-no-properties 2 text)))
             (format "%s %s"
                     (propertize type 'face 'font-lock-type-face)
                     var)))
          (t text)))

  (defun rtags-helm-propertize-macro (text)
    "Return a colored string for a #include or a #define"
    (cond ((string-match "^#include \\(.*\\)$" text)
           (let ((file (match-string-no-properties 1 text)))
             (format "%s %s"
                     (propertize "#include" 'face 'font-lock-preprocessor-face)
                     (propertize (concat "<" file ">") 'face 'font-lock-string-face))))
          (t text)))

  ;;;###autoload
  (defun rtags-helm-select-taglist ()
    "Display the list of symbols of the current file in an Helm
  buffer (classes, functions, variables, enums and other)"
    (interactive)
    (let* ((fn (buffer-file-name))
           functions classes variables enums macros other)
      ;; Fetch taglists. Each list is a list of pairs (text . line-number)
      (with-temp-buffer
        (rtags-call-rc :path fn :path-filter fn "-F" "--cursor-kind" "--display-name" "--no-context")
        ;;(message "%s" (buffer-string))
        (unless (= (point-min) (point-max))
          (while (not (eobp))
            (let ((line (buffer-substring-no-properties (point-at-bol) (point-at-eol))))
              (when (string-match "^\\(.*:\\)\\([0-9]+\\)\\(:[0-9]+:\\)\t\\(.*\\)\t\\(.*\\)$" line)
                  (let ((loc-start (match-string-no-properties 1 line))
                        (linenum (match-string-no-properties 2 line))
                        (loc-end (match-string-no-properties 3 line))
                        (text (match-string-no-properties 4 line))
                        (type (match-string-no-properties 5 line)))
                    (cond ((or (string= type "FunctionDecl")
                               (string= type "CXXMethod")
                               (string= type "CXXConstructor")
                               (string= type "CXXDestructor"))
                           (add-to-list 'functions
                                        (cons (rtags-helm-propertize-function text)
                                              (string-to-number linenum))))
                          ((or (string= type "ClassDecl")
                               (string= type "StructDecl"))
                           (add-to-list 'classes
                                        (cons (propertize text 'face 'font-lock-type-face)
                                              (string-to-number linenum))))
                          ((string= type "FieldDecl")
                           (add-to-list 'variables
                                        (cons (rtags-helm-propertize-variable text)
                                              (string-to-number linenum))))
                          ((and rtags-helm-show-variables
                                (or (string= type "VarDecl")
                                    (string= type "ParmDecl")))
                           (add-to-list 'variables
                                        (cons (rtags-helm-propertize-variable text)
                                              (string-to-number linenum))))
                          ((and rtags-helm-show-enums
                                (or (string= type "EnumDecl")
                                    (string= type "EnumConstantDecl")))
                           (add-to-list 'enums
                                        (cons text (string-to-number linenum))))
                          ((or (string= type "macro definition")
                               (string= type "include directive")
                               (string= type "inclusion directive"))
                           (add-to-list 'macros
                                        (cons (rtags-helm-propertize-macro text)
                                              (string-to-number linenum))))
                          (t
                           (add-to-list 'other
                                        (cons text (string-to-number linenum))))))))
            (forward-line))))
      ;; Display them in Helm
      (helm :sources
            `(((name . "Classes")
               (candidates . ,(rtags-helm-sort-list classes))
               (action . rtags-helm-jump-to-line))
              ((name . "Functions")
               (candidates . ,(rtags-helm-sort-list functions))
               (action . rtags-helm-jump-to-line))
              ((name . ,(if rtags-helm-show-variables "Fields and Variables" "Fields"))
               (candidates . ,(rtags-helm-sort-list variables))
               (action . rtags-helm-jump-to-line))
              ((name . "Enums")
               (candidates . ,(rtags-helm-sort-list enums))
               (action . rtags-helm-jump-to-line))
              ((name . "Macros and Includes")
               (candidates . ,(rtags-helm-sort-list macros))
               (action . rtags-helm-jump-to-line))))))

  (define-key c-mode-base-map [(meta control g)] 'rtags-helm-select-taglist)
#+END_SRC
** expand-region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind (("C-=" . er/expand-region)
           ("C-M-=" . er/contract-region)))
#+END_SRC
** eyebrowse
#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :ensure t
    :bind (("C-M-h" . eyebrowse-prev-window-config)
           ("C-M-l" . eyebrowse-next-window-config))
    :config
    (eyebrowse-mode t))
#+END_SRC
** find-where
#+BEGIN_SRC emacs-lisp
  (use-package find-where
    :disabled
    :load-path "~/.emacs.d/local-packages/find-where")
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
  ;; (use-package flycheck
  ;;   :disabled
  ;;   :ensure t
  ;;   :init
  ;;   ;;(setq-default flycheck-disabled-checkers '(c/c++-clang))
  ;;   (global-flycheck-mode)
  ;;   :config
  ;;   (setq-default flycheck-c/c++-clang-executable "/usr/local/opt/llvm/bin/clang" )
  ;;   (setq-default flycheck-clang-standard-library "libc++")
  ;;   (setq-default flycheck-clang-language-standard "c++11"))
#+END_SRC
** flyspell
#+BEGIN_SRC emacs-lisp
  ;; dictionary installed via:
  ;; brew install aspell
  (use-package flyspell
    :init
    (unbind-key "C-." flyspell-mode-map)
    (unbind-key "C-," flyspell-mode-map)
    (unbind-key "C-M-i" flyspell-mode-map)
    (setq ispell-program-name "/usr/local/bin/aspell")
    (add-hook 'prog-mode-hook 'flyspell-prog-mode))
#+END_SRC
** git-gutter-fringe+
#+BEGIN_SRC emacs-lisp
    (use-package git-gutter-fringe+
      :ensure    t
      :bind (("C-M-p" . git-gutter+-previous-hunk )
             ("C-M-n" . git-gutter+-next-hunk ))
      :init
      (global-git-gutter+-mode t))
#+END_SRC
** git-timemachine
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t )
#+END_SRC
** golden-ratio
#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :ensure t
    :disabled
    :config
    (golden-ratio-mode 1)
    (golden-ratio-toggle-widescreen))
#+END_SRC
** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :bind (
           ;;("C-S-b"   . helm-mini)
           ;;("M-x"     . helm-M-x)             ;; meta-X is handled by Helm
           ;;("<f1>"    . helm-imenu)          ;; Map F1 to helm-imenu
           ;;("M-i"     . helm-swoop)
           ;;("M-y"     . helm-show-kill-ring)
           ;;("C-x C-f" . helm-find-files)
           )
    :init
    (setq helm-split-window-default-side 'same ; display helm in the same window
          helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
          helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
          helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
          helm-ff-file-name-history-use-recentf t
          helm-mode-reverse-history           nil ; place helm command history on top
          helm-ff-transformer-show-only-basename t; only show basename when helm-find-file, to show full path "C-]"

          ;; need to investigate what these do
          ;; just copied them from: https://github.com/yveszoundi/emacs.d/blob/master/bootstrap/startup.org
          ;;helm-adaptive-history-file             ers-helm-adaptive-history-file
          ;;helm-boring-file-regexp-list           '("\\.git$" "\\.svn$" "\\.elc$" "*~$")

          helm-buffer-max-length                 45
          helm-recentf-fuzzy-match               t
          helm-yank-symbol-first                 t
          helm-buffers-fuzzy-matching            t
          helm-ff-auto-update-initial-value      t
          helm-input-idle-delay                  0.1
          helm-idle-delay                        0.1
          )

    (use-package helm-ag
      :ensure    t
      :ensure    helm-projectile
      :bind      )

    (use-package helm-grep
      :defer t
      :bind
      :config
      ;; color file names in helm grep mode using a sensible color
      (set-face-attribute 'helm-grep-file nil
                          :foreground "azure")
      ;; the original value is "grep --color=always -a -d skip %e -n%cH -e %p %f"
      ;; the --color option would override helm-grep-match face and force the "red"
      ;; to be displayed, which does not play well with my color scheme
      ;; hence remove the --color from the command and override the helm-grep-match
      ;; with the color I like better
      (setq helm-grep-default-command "grep -a -d skip %e -n%cH -e %p %f")
      (set-face-attribute 'helm-grep-match nil
                          :background "black"
                          :foreground "yellow")
      )

    :config
    ;; make helm selection yellow on black
    (set-face-attribute 'helm-visible-mark nil
                        :background "black"
                        :foreground "yellow")
    ;; make current line in helm pleasant to look at
    (set-face-attribute 'helm-selection nil
                        :background "DarkCyan"
                        :foreground "white")
    )

    (use-package helm-swoop
      :ensure    t
      :config
      ;; make sure helm swoop plays nice with shackle
      ;; thank you wasamasa!
      (setq helm-swoop-split-window-function 'display-buffer)
      ;; my own faces
      (set-face-attribute 'helm-swoop-target-line-face nil
                          :background "yellow"
                          :foreground "black")

      (set-face-attribute 'helm-swoop-target-word-face nil
                          :background "black"
                          :foreground "yellow"))
#+END_SRC
** helm-projectile
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :ensure    t
  ;;  :bind      ("M-o" . helm-projectile)
    :after     (projectile))
#+END_SRC
** helm-rtags
#+BEGIN_SRC emacs-lisp
  (use-package helm-rtags
      :ensure    t )
#+END_SRC
** hilight-indent-guides
#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
      :ensure t
      :config
      (setq highlight-indent-guides-method 'character)
      (setq highlight-indent-guides-character ?\|)
      (setq highlight-indent-guides-responsive 'stack))
#+END_SRC
** hl-todo
#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :ensure t
    :init
    (setq hl-todo-keyword-faces
          `(("TODO"  . "yellow")
            ("FIXME" . "VioletRed1")
            ("NOTE"  . ,(face-foreground 'success))))
    :config
    (global-hl-todo-mode))
#+END_SRC
** hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
    :ensure t
    :config)
#+END_SRC
** ibuffer
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind (("C-'" . ibuffer))
    :init
    (setq ibuffer-saved-filter-groups
          (quote (("default"
                   ("eqwrnt2" (filename . "/eqwrnt2/"))
                   ("C++" (mode . c++-mode))
                   ("dired" (mode . dired-mode))
                   ("magit" (name . "^.*magit*$"))
                   ("org" (name . "^.*org$"))
                   ("shell" (or (mode . eshell-mode) (mode . shell-mode)))
                   ("Emacs" (or
                             (name . "^\\*scratch\\*$")
                             (name . "^\\*Messages\\*$")))))))

    (setq ibuffer-show-empty-filter-groups nil)
    (setq ibuffer-expert t)
    (setq ibuffer-show-empty-filter-groups nil)
    (add-hook 'ibuffer-mode-hook
              '(lambda ()
                 (ibuffer-switch-to-saved-filter-groups "default"))))
#+END_SRC
** iedit
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t
    :bind (("C-;" . iedit-mode))
    :config
    )
#+END_SRC
** irony
#+BEGIN_SRC emacs-lisp
  ;; (defun my-irony-mode-hook ()
  ;;   (define-key irony-mode-map [remap completion-at-point]
  ;;     'irony-completion-at-point-async)
  ;;   (define-key irony-mode-map [remap complete-symbol]
  ;;     'irony-completion-at-point-async))

  ;; (use-package irony
  ;;   :disabled
  ;;   :ensure t
  ;;   :init
  ;;   (add-hook 'irony-mode-hook 'my-irony-mode-hook)
  ;;   (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC
** ivy
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish ivy-mode
    :bind(("<f10>" . ivy-resume))
    :ensure t
    :init
    :config
    ;; fix paste in ivy
    (unbind-key "C-v" ivy-minibuffer-map)
    (setq ivy-height 25)
    ;; for completions, the order does not matter
    (setq ivy-re-builders-alist
          '((t . ivy--regex-ignore-order)))
    (setq ivy-use-virtual-buffers t)
    ;; remove annoying ^ prefix
    (setq ivy-initial-inputs-alist nil)
    (set-face-attribute 'ivy-current-match nil :foreground "green" :weight 'normal )
    (set-face-attribute 'ivy-minibuffer-match-face-2 nil :background "black" :foreground "yellow"  :weight 'normal)
    (set-face-attribute 'ivy-minibuffer-match-face-3 nil :background "black" :foreground "green"  :weight 'normal)
    (set-face-attribute 'ivy-minibuffer-match-face-4 nil :background "black" :foreground "cyan"  :weight 'normal)
    (ivy-mode 1)
    ;; seems that counsel-yank-pop will respect ivy-height if ivy-height-alist is set to nil
    (setq ivy-height-alist nil))
#+END_SRC
** ivy-posframe
#+BEGIN_SRC emacs-lisp
  (defun sd/posframe_toggle()
    (interactive)
    "Move ivy-poswin out of the way"
    (let ((display_func (symbol-value 'ivy-display-function))
          )
      (if (eq display_func 'ivy-posframe-display-at-frame-bottom-left)
          (setq ivy-display-function #'ivy-posframe-display-at-frame-center)
        (setq ivy-display-function #'ivy-posframe-display-at-frame-bottom-left))))

  (use-package ivy-posframe
    :ensure t
    :after ivy
    :config
    (setq ivy-display-function #'ivy-posframe-display-at-frame-center)
    ;; maximum width
    (setq ivy-posframe-width 150))

  (global-unset-key (kbd "<f8>"))
  (global-set-key (kbd "<f8>") 'sd/posframe_toggle)

#+END_SRC
** json-mode
#+BEGIN_SRC emacs-lisp
(use-package json-mode
    :ensure t)
#+END_SRC
** key-chord
#+BEGIN_SRC emacs-lisp
  (use-package key-chord
      :ensure t
      :config)

  ;; turn on the key-chord mode
  (key-chord-mode 1)

  ;; fast copy
  ;;(key-chord-define-global "cc" 'sd/whole-line-or-region-kill-ring-save)
  ;; fast paste
  ;;(key-chord-define-global "vv" 'yank)
#+END_SRC
** lsp-mode
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :bind (("C-x r" . xref-find-references)
           ( "C-."  . xref-find-definitions)
           ("C-,"   . xref-pop-marker-stack))
    :ensure t)
#+END_SRC
** lsp-ui
#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :disabled
    :ensure t
    :after lsp-mode
    :bind (("C-?" . lsp-ui-sideline-toggle-symbols-info))
    :hook (lsp-mode . lsp-ui-mode)
    :config
    (add-hook 'lsp-mode-hook 'lsp-ui-mode))
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :chords (("MM" . magit-status))
    :bind (("C-x g" . magit-status)
           ("C-x m l" . magit-log-all))
    :config
    ;; update magit heading line to yellow on black, the way I like it...
    (set-face-attribute 'magit-diff-hunk-heading-highlight nil :background "black" :foreground "yellow")
    ;; make changes look nice
    (set-face-attribute 'magit-diff-removed-highlight nil :background "black" :foreground "red")
    (set-face-attribute 'magit-diff-added-highlight nil :background "black" :foreground "SeaGreen3")
    (set-face-attribute 'magit-diff-removed nil :background "DarkRed")
    (set-face-attribute 'magit-diff-hunk-heading nil :background "black" :foreground "turquoise1" ))
#+END_SRC
** make-mode
#+BEGIN_SRC emacs-lisp
  (use-package make-mode
    :defer t
    :init
    :config
    (unbind-key "C-M-i" makefile-mode-map))
#+END_SRC
** man
#+BEGIN_SRC emacs-lisp
  (use-package man
    :bind ( :map Man-mode-map
                 ("<return>" . sd/man-follow)))
#+END_SRC
** modern-cpp-font-lock
#+BEGIN_SRC emacs-lisp
  (use-package modern-cpp-font-lock
    :diminish ‘modern-c++-font-lock-mode
    :ensure t)
  (modern-c++-font-lock-global-mode t)
#+END_SRC
** move-text
#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :ensure t
    ;; Text movement
    :bind (("C-S-<up>"   . move-text-up )
           ("C-S-<down>" . move-text-down ))
    :config)
#+END_SRC

** multiple-cursors
#+BEGIN_SRC emacs-lisp
  (defvar multiple-cursors-mode-enabled-hook nil
    "Hook that is run after `multiple-cursors-mode' is enabled.")

  (defvar multiple-cursors-mode-disabled-hook nil
    "Hook that is run after `multiple-cursors-mode' is disabled.")

  (defun sd/mc-when-enabled ()
    "Function to be added to `multiple-cursors-mode-enabled-hook'."
    (setq-default cursor-type '(box . 7)))

  (defun sd/mc-when-disabled ()
    "Function to be added to `multiple-cursors-mode-disabled-hook'."
    (setq-default cursor-type '(bar . 1)))

  (use-package multiple-cursors
    :ensure t
    :demand t
    :bind (("C--" . mc/mark-next-like-this  )
           ("C-M--" . mc/mark-all-like-this-in-defun  )
           :map mc/keymap
           ("<return>" . nil))
    :init
    (add-hook 'multiple-cursors-mode-enabled-hook #'sd/mc-when-enabled)
    (add-hook 'multiple-cursors-mode-disabled-hook #'sd/mc-when-disabled)
    ;; add mc cursors on Meta-left mouse click
    (global-unset-key (kbd "M-<down-mouse-1>"))
    (global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click)
    :config
    (set-face-foreground 'mc/cursor-face "red")
    (unbind-key "C-v" mc/keymap))

#+END_SRC
** nxml
#+BEGIN_SRC emacs-lisp
  (use-package nxml-mode
      :config
      (unbind-key "C-c C-u" nxml-mode-map)
      (unbind-key "M-h" nxml-mode-map)
      (unbind-key "C-M-i" nxml-mode-map))
#+END_SRC
** org
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :init
    (unbind-key "M-h" org-mode-map)
    (unbind-key "C-M-i" org-mode-map)
    ;; indent propertly in org babel mode
    (setq org-src-tab-acts-natively t)
    ;; support shift-selection-mode
    (setq org-support-shift-select t)
    ;; timestamp TODO items
    (setq org-log-done 'time)
    ;; insert notes for DONE items
    ;; (setq org-log-done 'note)
    (setq org-todo-keyword-faces
          '(("IN-PROGRESS" . "orange1")))
    )
#+END_SRC
** org-bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
** posframe
#+BEGIN_SRC emacs-lisp
  (use-package posframe
    :ensure t
    :bind ("C-M-<kp-delete>" . posframe-delete-all)
    :config)
#+END_SRC
** pcre2el
#+BEGIN_SRC emacs-lisp
  (use-package pcre2el
    :ensure t
    :config
    (pcre-mode))
#+END_SRC
** projectile
#+BEGIN_SRC  emacs-lisp
  (use-package projectile
    :ensure t
    :demand t
    :init
    ;;(setq projectile-completion-system 'helm)
    ;; solves a performance issue
    ;; without this, every cursor movement is incredibly slow
    (setq projectile-mode-line
          '(:eval (if (projectile-project-p)
                      (format " Proj[%s]"
                              (projectile-project-name))
                    "")))
    :config
    ;; ignore files
    (add-to-list 'grep-find-ignored-files "*.d")
    (add-to-list 'grep-find-ignored-files "*.dd")
    (add-to-list 'grep-find-ignored-files "*.mapfile")
    (add-to-list 'grep-find-ignored-files "*.tsk")
    (add-to-list 'grep-find-ignored-files "*.depends")
    (add-to-list 'grep-find-ignored-files "*.blob")
    (add-to-list 'grep-find-ignored-files "compile_commands.json")

    ;; ignore directories
    (add-to-list 'projectile-globally-ignored-directories "llcalc*")
    (add-to-list 'projectile-globally-ignored-directories "SunWS_cache*")
    (add-to-list 'projectile-globally-ignored-directories ".svn")
    (add-to-list 'projectile-globally-ignored-directories ".ccls-cache")
    ;; ignore specific file suffixes from projectile
    (setq projectile-globally-ignored-file-suffixes '(".svn-base"))
    (setq projectile-globally-ignored-file-suffixes '(".blob"))
    ;; ignore
    (add-to-list 'projectile-globally-ignored-files ".ccls-cache")
    (projectile-global-mode t))
#+END_SRC
** python
#+BEGIN_SRC emacs-lisp
  (use-package python
    :bind( :map python-mode-map
                ("C-c C-c" . sd/comment-line-or-region)
                ("C-c C-v" . sd/duplicate-line-or-region)))

#+END_SRC
** recentf
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    (setq recentf-max-saved-items 500
          recentf-max-menu-items 30
          ;; disable recentf-cleanup on Emacs start, because it can cause
          ;; problems with remote files
          recentf-auto-cleanup 'never)
    (recentf-mode +1))
#+END_SRC
** rectangle-mark-mode
#+BEGIN_SRC emacs-lisp
    (use-package rect
      :bind(("C-M-<down>" . rectangle-mark-mode)
            :map rectangle-mark-mode-map
            ("C-w" . kill-rectangle)))
#+END_SRC
** rtags
#+BEGIN_SRC emacs-lisp
  (use-package rtags
    :ensure t
    :bind (("M-." . sd/rtags-find-symbol-at-point)
           ("M-," . rtags-location-stack-back)
           ;;("C-x r" . rtags-find-all-references-at-point)
           ("C-<f1>" . rtags-imenu))
    :config
    (setq rtags-display-result-backend 'helm)
    ;; don't jump to first match, very annoying
    (setq rtags-jump-to-first-match nil))
#+END_SRC
** savehist
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :config
    (savehist-mode +1))
#+END_SRC
** shackle
#+BEGIN_SRC emacs-lisp
  ;; make sure pop up buffers such as helm, help, etc pop up below, always in the same place
  (use-package shackle
    :ensure t
    :init
    (setq helm-display-function 'pop-to-buffer)
    (setq shackle-rules '(("\\`\\*helm.*?\\*\\'" :regexp t :align t :ratio 0.5)
                          ("\\`\\*Help.*?\\*\\'" :regexp t :align t :ratio 0.5)
                          ("*RTags*" :select t :align t :ratio 0.5)))
    :config
    (shackle-mode))
#+END_SRC
** shell
#+BEGIN_SRC emacs-lisp
  (use-package shell-mode
    :bind(:map shell-mode-map
               ("C-p" . comint-previous-input)
               ("C-n" . comint-next-input))
    :config
    (add-hook 'shell-mode-hook (lambda() (set-process-query-on-exit-flag (get-process "shell") nil)) ))
#+END_SRC
** shell-pop
#+BEGIN_SRC emacs-lisp
  (use-package shell-pop
    :ensure t
    :bind (("C-S-m" . shell-pop))
    :config
    ;; Don't ask to kill the shell buffer
    (add-hook 'shell-mode-hook (lambda() (set-process-query-on-exit-flag (get-process "shell") nil)) )
    (setq shell-pop-shell-type
          (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
    (setq shell-pop-term-shell "/bin/bash")
    (setq shell-pop-window-height 60)
    (setq shell-pop-full-span t)
    (setq shell-pop-window-position "bottom")
    (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+END_SRC
** sh-script
#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :config
    ;; unbind c++-mode-map keys which interfer with global mappings
    (unbind-key "C-c C-c" sh-mode-map)
    (unbind-key "C-c C-u" sh-mode-map))
#+END_SRC
** smartparens
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :bind ( ("C-M-<right>" . sp-slurp-hybrid-sexp)
            ("C-M-<left>" . sp-forward-barf-sexp))
    :defer t)
#+END_SRC
** spaceline
#+BEGIN_SRC emacs-lisp
  (use-package spaceline :ensure t
    :config
    (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main)))))

  (use-package spaceline-config :ensure spaceline
    :config
    (spaceline-helm-mode 1)

    (spaceline-define-segment my/buffer-status
      "Buffer status (read-only, modified), with color"
      (cond (buffer-read-only (propertize "RO" 'face 'my/spaceline-read-only))
            ((buffer-modified-p) (propertize "MODIFIED" 'face 'my/spaceline-modified))
            (t "  ")))

    (spaceline-define-segment amitp/buffer-id
      "Name of filename relative to project, or buffer id"
      (propertize
       (amitp/spaceline-buffer-id)
       'face 'amitp/spaceline-filename))

    ;; When there are segments that may or may not appear, they will
    ;; affect the alternating background colors. I try to put the
    ;; indicators that appear/disappear the most towards the center.
    (spaceline-install
      'main
      '((my/buffer-status :tight-left t)
        (amitp/buffer-id :tight-left t :face highlight-face)
        (which-function :tight-left t)
        (("L" line column) :separator ":" :when active)
        (selection-info :face region :when mark-active)
        (projectile-root :when active)
        (workspace-number :face my/spaceline-perspective-name :when active))
      '(((flycheck-error flycheck-warning flycheck-info) :when active)
        (version-control :when active)
        (global :face highlight-face)
        (major-mode))))

  (defun amitp/spaceline-buffer-id ()
    (cond (buffer-file-name
           (file-name-nondirectory buffer-file-name))
          (t (s-trim (powerline-buffer-id 'mode-line-buffer-id)))))

  (defun hsl (H S L) ; convenience fn
    (apply 'color-rgb-to-hex (color-hsl-to-rgb (/ H 360.0) S L)))
  (defun face (face &rest spec) ; convenience fn
    (face-spec-set face (list (cons t spec))))
  (setq powerline-text-scale-factor 0.8)

  (face 'mode-line :family "M+ 1m" :height 1.0 :background "gray20" :foreground "gray80" :box nil)
  (face 'mode-line-inactive :inherit 'mode-line :background "gray55" :foreground "gray80" :box nil)
  (face 'mode-line-highlight :inherit 'mode-line :background "GoldenRod2" :foreground "white"
        :box '(:line-width -2 :color "GoldenRod2" :style released-button))

  (face 'powerline-active1   :inherit 'mode-line          :height powerline-text-scale-factor :background "gray30")
  (face 'powerline-inactive1 :inherit 'mode-line-inactive :height powerline-text-scale-factor)
  (face 'powerline-active2   :inherit 'mode-line          :height powerline-text-scale-factor :background "gray40")
  (face 'powerline-inactive2 :inherit 'mode-line-inactive :height powerline-text-scale-factor)

  (face 'spaceline-highlight :inherit 'mode-line :foreground "white" :background "gray80" :height powerline-text-scale-factor)

  (face 'my/spaceline-read-only :background (hsl 300 0.15 0.5) :foreground "gray80" :box `(:line-width -2 :color ,(hsl 300 0.4 0.5)))
  (face 'my/spaceline-modified :background "Red" :foreground "Black" :weight 'extra-bold)
  (face 'my/spaceline-perspective-name :background "Black" :foreground "turquoise1" :height (/ 1.0 powerline-text-scale-factor))
  (face 'my/spaceline-unicode-character :inherit 'mode-line :foreground "black" :background (hsl 50 1.0 0.5))
  (face 'amitp/spaceline-filename :family "Helvetica Neue" :foreground nil :background nil :weight 'normal :height (/ 1.0 powerline-text-scale-factor))
#+END_SRC
** swap-buffers
#+BEGIN_SRC emacs-lisp
  (use-package swap-buffers
    :ensure t
    :bind("C-<f12>" . swap-buffers)
    :init
    (setq swap-buffers-keep-focus t)
    :config)
#+END_SRC
** swiper
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :bind ( ("M-i" . swiper) )
    :config
    ;; currently doesn't seem to work, with any luck will get fixed in the future
    (set-face-attribute 'swiper-match-face-1 nil :background "black" :weight 'normal)
    (set-face-attribute 'swiper-match-face-2 nil :foreground "yellow" :weight 'normal)
    (set-face-attribute 'swiper-match-face-3 nil :foreground "green"  :weight 'normal)
    (set-face-attribute 'swiper-match-face-4 nil :foreground "cyan"   :weight 'normal)
    :ensure t)
#+END_SRC
** term
#+BEGIN_SRC emacs-lisp
  (defun sd/term-hook ()
    "Term mode hook to set it up."
    ;; colors
    (setq buffer-face-mode-face `(:background "black"))
    (set-face-attribute 'term nil :background "black" )
    (buffer-face-mode 1)
    ;; disable hl-line in term
    (setq global-hl-line-mode nil))

  (use-package term
    :init
    (add-hook 'term-mode-hook #'sd/term-hook)
    :config
    (unbind-key "M-x" term-raw-map)
    (unbind-key "M-h" term-raw-map)
    (unbind-key "M-j" term-raw-map)
    (unbind-key "M-k" term-raw-map)
    (unbind-key "M-k" term-raw-map))
#+END_SRC
** thingatpt+
#+BEGIN_SRC emacs-lisp
  (use-package thingatpt+
    :disabled
    :after find-where
    :load-path "~/.emacs.d/local-packages/thingatpt+")
#+END_SRC
** transpose-frame
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :ensure t
    :bind("<f12>" . flop-frame)
    :config)
#+END_SRC
** try
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC
** uncrustify-mode
#+BEGIN_SRC emacs-lisp
  (defun sd/uncrustify ()
    "Uncrustify text selection or whole buffer."
    (interactive)
    (let (p1 p2)
      (progn (if (use-region-p)
                 (progn (setq p1 (region-beginning))
                        (setq p2 (region-end)))
               (progn (setq p1 (point-min))
                      (setq p2 (point-max)))))
      (require 'uncrustify-mode)
      (uncrustify-invoke-command (uncrustify-get-lang-from-mode) p1 p2)))

  (use-package uncrustify-mode
    :ensure t)

;;uncrustify-config-path is a variable defined in ‘uncrustify-mode.el’.
;;Its value is "~/.uncrustify.cfg"
;; uncrustify -q -c ~/.uncrustify.cfg -l CPP
#+END_SRC
** undo-tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :init
    (global-undo-tree-mode)
    (unbind-key "C-x r u" undo-tree-map)
    (unbind-key "C-x r U" undo-tree-map)
    (unbind-key "C-x r" undo-tree-map))
#+END_SRC
** use-package-chors
#+BEGIN_SRC emacs-lisp
(use-package use-package-chords
  :ensure t
  :config (key-chord-mode 1))
#+END_SRC
** vc-svn
#+BEGIN_SRC emacs-lisp
  (use-package vc-svn
    :config
    (setq vc-svn-diff-switches '("-x --ignore-eol-style" "-x -w")))
#+END_SRC
** vlf
#+BEGIN_SRC emacs-lisp
  (use-package vlf
    :ensure t
    :init)
#+END_SRC
** wgrep
#+BEGIN_SRC emacs-lisp
    ;; Editable grep buffer
    (use-package wgrep
      :ensure t
      :defer t
      :config
      ;; on wgrep-finish-edit, save all changed buffers
      (setq wgrep-auto-save-buffer t)

      (progn
        (with-eval-after-load 'grep
          (bind-key "C-x C-q" #'wgrep-change-to-wgrep-mode grep-mode-map))
        (with-eval-after-load 'wgrep
          (bind-key "C-c C-c" #'wgrep-finish-edit grep-mode-map))))
#+END_SRC
** which-function
#+BEGIN_SRC emacs-lisp
  (use-package which-func
    :config
    (set-face-attribute 'which-func nil :background "Black" :foreground "Orange" :height 1.5))
#+END_SRC
** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :ensure t
    :config
    (which-key-mode))
#+END_SRC
** whitespace
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :init
    (dolist (hook '(prog-mode-hook))
      (add-hook hook #'whitespace-mode))
    (add-hook 'before-save-hook #'whitespace-cleanup)
    :config
    (setq whitespace-style '(face trailing)))
#+END_SRC
** whole-line-or-region
#+BEGIN_SRC emacs-lisp
  (defun sd/whole-line-or-region-kill-ring-save()
    "When in rectangle mode, copy the rectangle"
    (interactive)
    (if rectangle-mark-mode
        (progn
          (message "Copying rectangle.")
          (copy-rectangle-as-kill (region-beginning) (region-end)))
      (progn
        (message "Copying region.")
        (whole-line-or-region-kill-ring-save nil))))

    (use-package whole-line-or-region
      :ensure t
      :bind (("C-w" . whole-line-or-region-kill-region)
             ("C-c c" . sd/whole-line-or-region-kill-ring-save))
      :config)
#+END_SRC
** wrap-region
#+BEGIN_SRC emacs-lisp
  (use-package wrap-region
    :diminish wrap-region-mode
    :ensure   t
    :config
    (wrap-region-global-mode t)
    (wrap-region-add-wrappers
     '(("(" ")")
       ("[" "]")
       ("{" "}")
       ("<" ">")
       ("'" "'")
       ("\"" "\"")
       ("‘" "’"   "q")
       ("“" "”"   "Q")
       ("*" "*"   "b"   org-mode)                 ; bolden
       ("*" "*"   "*"   org-mode)                 ; bolden
       ("/" "/"   "i"   org-mode)                 ; italics
       ("/" "/"   "/"   org-mode)                 ; italics
       ("~" "~"   "c"   org-mode)                 ; code
       ("~" "~"   "~"   org-mode)                 ; code
       ("=" "="   "v"   org-mode)                 ; verbatim
       ("=" "="   "="   org-mode)                 ; verbatim
       ("_" "_"   "u" '(org-mode markdown-mode))  ; underline
       ("**" "**" "b"   markdown-mode)            ; bolden
       ("*" "*"   "i"   markdown-mode)            ; italics
       ("`" "`"   "c" '(markdown-mode ruby-mode)) ; code
       ("`" "'"   "c"   lisp-mode)                ; code
       )))
#+END_SRC
** yasnippet
#+BEGIN_SRC emacs-lisp
        ;;;###autoload
  (defun sd/yas-no-expand-in-comment/string ()
    "Don't expand snippet while in comment."
    (setq yas-buffer-local-condition
          '(if (nth 8 (syntax-ppss)) ;; non-nil if in a string or comment
               '(require-snippet-condition . force-in-comment)
             t)))

  (add-hook 'prog-mode-hook 'sd/yas-no-expand-in-comment/string)
  (use-package yasnippet
    :diminish yas-minor-mode
    :ensure t
    :init
    (yas-global-mode 1)
    :config
    (define-key yas-minor-mode-map (kbd "<tab>") nil)
    (define-key yas-minor-mode-map (kbd "TAB") nil)
    (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)

    ;;keys for navigation
    ;; (define-key yas-keymap [(tab)]       nil)
    ;; (define-key yas-keymap (kbd "TAB")   nil)
    ;; (define-key yas-keymap [(shift tab)] nil)
    ;; (define-key yas-keymap [backtab]     nil)

    ;; (define-key yas-keymap (kbd "<new-next-field-key>") 'yas-next-field-or-maybe-expand)
    ;; (define-key yas-keymap (kbd "<new-prev-field-key>") 'yas-prev)
    )
#+END_SRC
** zoom-window
#+BEGIN_SRC emacs-lisp
  (use-package zoom-window
    :ensure t
    :bind (("C-M-z" . zoom-window-zoom)
	   )
    :init
    (setq zoom-window-mode-line-color "SteelBlue")
    :config
    )
#+END_SRC
** Modes to explore in the future
# 'ensime
# 'paredit
# 'rtags-ac
# web-mode
# simpleclip-mode
* TODO
** random snippets
(use-package projectile
  :diminish "Pj"
  :init
  (progn
    (projectile-global-mode)
    (setq projectile-indexing-method 'alien
          projectile-sort-order 'recentf
          projectile-cache-file "~/.emacs.d/cache/projectile.cache"
          projectile-known-projects-file "~/.emacs.d/cache/projectile-bookmarks.eld"
          projectile-enable-caching t)
    (add-to-list 'projectile-globally-ignored-directories "elpa")
    (add-to-list 'projectile-globally-ignored-directories ".cask")
    (add-to-list 'projectile-globally-ignored-directories ".cache")))
** smartparens mode
** exec-path-from-shell mode
** rtags-helm/helm-rtags
http://syamajala.github.io/c-ide.html
(require 'rtags)
(require 'company-rtags)
(setq rtags-completions-enabled t)

(eval-after-load 'company
  '(add-to-list
    'company-backends 'company-rtags))
(setq rtags-autostart-diagnostics t)

(require 'rtags-helm)
(setq rtags-use-helm t)
** ediff horizontally
(setq ediff-split-window-function 'split-window-horizontally)
* Tips
#+BEGIN_SRC emacs-lisp
(setq sd-tips
      '(
        "<C-c C-SPC> jump to the next active ERC buffer. Switch back to last non-ERC buffer visited."
        "<C-x +> will make windows the same heights and widths."
        "<C-x ^> increases the height by 1 line."
        "<C-h i> to open the info manual."
        "<C-t> to `transpose-chars'."
        "<C-x C-j> to `dired-jump' and goes to dired of file being visited."
        "<C-x C-q> to enter Dired Edit mode. When finished <C-c C-c>!"
        "<C-x C-t> to `transpose-lines'"
        "[Magit] s to stage; u to unstange; c for commit; F for pulling; P for pushing."
        "<C-x n n> narrow to region. Press <C-x n w> to widen (or un-narrow)."
        "<C-x n p> narrow to page. Press <C-x n w> to widen (or un-narrow)."
        "<C-x n s> narrow to subtree in org-mode. Press <C-x n w> to widen."
        "<C-x r SPC R> to save a buffer position in register R; jump back to it later."
        "<C-x r f R> to save frame configuration in register R; jump back to it later."
        "<C-x r w R> to save window configuration in register R; jump back to it later."
        "<C-x s> followed by d to see the diff of your buffer before saving it."
        "<M-=> with a region selected to `count-words'"
        "<M-t> to `transpose-words'."
        "<M-z> to use `zap-up-to-char'. Get used to it. Very useful."
        "<C-x => to display information about the character current under the cursor."
        "<M-x> `info-display-manual' to find information to specific mode."
        "<M-x> `occur' and remember that lines can be edited in place in the occur buffer."
        "<M-x> `write-region' to write a selection to a file."
        "After renaming file with `dired-jump', press <C-x k RET> to go back to the renamed file."
        "Syntax for using TRAMP through SSH: C-x C-f /ssh:username@myhost:/path/to/file."
        "Syntax for using TRAMP through SUDO: C-x C-f /su::/etc/hosts."
        "There is a very handy `sort-lines' command available in built-in Emacs."
        "Use `diff-buffer-with-file' to compare your buffer with the corresponding file at disk."
        "You can ask for a `list-registers' to see what is stored in those little monsters."
        "You can use <M-g TAB> to goto column. (move-to-column)"
        "You can use <M-x> `find-name-dired' to find all files recursively matching a pattern."
        "t inside a Dired buffer to mark all files in there. And Q to query-replace inside of them."
        "Use <C-x 4 f> when your cursor is over a filename to open in other window."
        "Use <C-x 5 f> when your cursor is over a filename to open in other frame."
        "<C-x d <directory>> to open in Dired."
        "To copy the name of the file at point, use `dired-copy-filename-as-kill'."
        "<C-x C-r> to open file in READ-ONLY mode."
        "To copy the path to the folder you're looking at in dired: <M-< w>"
        "Enable wdired mode in dired to edit the file name by hitting <C-x C-q>"
        "<C-c C-p> to open `find-file-at-point'."
        "<C-c C-w> to move a headline under another top level headline in org mode."
        "<C-c C-t> to show a painel with all the ORG Keyword options."
        "<C-x }> to enlarge window horizontally."
        "<C-x C-n> to `set-goal-column' to freeze the cursor when moving to the next line."
        "<C-c C-m> to call `smex-major-mode-commands' which will enable only relevant commands to your major mode."
        "<C-c> toggles if a searching of buffer and file names should ignore case."
        "<C-t> toggles matching by Emacs regular expression."
        "<C-SPC / C-@> restricts the completion list to anything that matches your current input."
        "<M-s> inside the IDO mode (C-x C-f) to search for a file matching your input."
        ))

(defun sd/tips ()
  (interactive)
  (random t)
  (message (concat " " (nth (random (length sd-tips)) sd-tips))))
#+END_SRC
